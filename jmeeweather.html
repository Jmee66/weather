<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jmee Weather Station</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --sunny-gradient: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            --rainy-gradient: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            --cloudy-gradient: linear-gradient(135deg, #1a1a2e 0%, #2c3e50 100%);
            --night-gradient: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            --marine-gradient: linear-gradient(135deg, #0a1628 0%, #0d2137 50%, #0a1a2e 100%);
            --glass-bg: rgba(255,255,255,0.08);
            --glass-border: rgba(255,255,255,0.12);
            --accent-blue: #00b4d8;
            --accent-orange: #ff6b35;
            --accent-green: #2ecc71;
            --accent-purple: #9b59b6;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            background: var(--sunny-gradient);
            color: white;
            overflow-x: hidden;
        }

        .app-container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 10px 15px;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        /* Header Windy Style */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            flex-wrap: wrap;
            gap: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 15px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.3rem;
            font-weight: 700;
        }

        .logo-icon {
            font-size: 1.6rem;
        }

        /* Mode Toggle */
        .mode-toggle {
            display: flex;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 3px;
        }

        .mode-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background: transparent;
            color: rgba(255,255,255,0.6);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }

        .mode-btn.active {
            background: var(--accent-blue);
            color: white;
        }

        .search-container {
            display: flex;
            gap: 6px;
        }

        .search-input {
            padding: 10px 16px;
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            font-size: 0.9rem;
            width: 220px;
            min-width: 120px;
            max-width: 100%;
            background: rgba(0,0,0,0.3);
            color: white;
            outline: none;
            transition: all 0.2s;
            flex-shrink: 1;
        }

        .search-input::placeholder {
            color: rgba(255,255,255,0.5);
        }

        .search-input:focus {
            border-color: var(--accent-blue);
            background: rgba(0,0,0,0.4);
        }

        .btn {
            padding: 10px 14px;
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .btn-icon {
            width: 40px;
            padding: 10px;
        }

        .btn-add {
            background: rgba(46,204,113,0.2);
            border-color: rgba(46,204,113,0.3);
        }

        .btn-add:hover {
            background: rgba(46,204,113,0.3);
        }

        /* Control Bar - Windy Style */
        .control-bar {
            display: flex;
            gap: 15px;
            padding: 12px 15px;
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-label {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-select {
            padding: 6px 10px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            background: rgba(0,0,0,0.4);
            color: white;
            font-size: 0.85rem;
            cursor: pointer;
            outline: none;
        }

        .control-select option {
            background: #1a1a2e;
        }

        /* Unit Selector */
        .unit-selector {
            display: flex;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            padding: 2px;
        }

        .unit-btn {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            background: transparent;
            color: rgba(255,255,255,0.6);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .unit-btn.active {
            background: var(--accent-blue);
            color: white;
        }

        /* Location Badge */
        .location-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(0,180,216,0.2);
            border: 1px solid rgba(0,180,216,0.3);
            border-radius: 20px;
            font-size: 0.85rem;
        }

        .location-badge .dot {
            width: 8px;
            height: 8px;
            background: var(--accent-green);
            border-radius: 50%;
            animation: pulse-dot 2s infinite;
        }

        .location-badge.live .dot {
            background: #ff4444;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* API Status Badge */
        .api-status {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: rgba(46,204,113,0.2);
            border: 1px solid rgba(46,204,113,0.3);
            border-radius: 15px;
            font-size: 0.75rem;
        }

        .api-status.error {
            background: rgba(231,76,60,0.2);
            border-color: rgba(231,76,60,0.3);
        }

        .api-status .status-dot {
            width: 6px;
            height: 6px;
            background: var(--accent-green);
            border-radius: 50%;
        }

        .api-status.error .status-dot {
            background: #e74c3c;
        }

        /* Favorites Section */
        .favorites-section {
            margin-bottom: 15px;
        }

        .favorites-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .favorites-title {
            font-size: 0.85rem;
            color: rgba(255,255,255,0.7);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .favorites-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .favorite-chip {
            padding: 6px 14px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            color: rgba(255,255,255,0.8);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .favorite-chip:hover {
            background: rgba(255,255,255,0.1);
            border-color: var(--accent-blue);
        }

        .favorite-chip.active {
            background: rgba(0,180,216,0.2);
            border-color: var(--accent-blue);
            color: white;
        }

        .favorite-chip.port {
            border-color: rgba(155,89,182,0.4);
        }

        .favorite-chip.port.active {
            background: rgba(155,89,182,0.2);
            border-color: var(--accent-purple);
        }

        .favorite-chip .delete-fav {
            margin-left: 4px;
            opacity: 0;
            font-size: 0.7rem;
            transition: opacity 0.2s;
        }

        .favorite-chip:hover .delete-fav {
            opacity: 0.7;
        }

        .favorite-chip .delete-fav:hover {
            opacity: 1;
            color: #e74c3c;
        }

        /* Main Grid */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr minmax(300px, 380px);
            gap: 15px;
            max-width: 100%;
            overflow: hidden;
        }

        @media (max-width: 1000px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 600px) {
            .app-container {
                padding: 8px 10px;
            }
        }

        /* Weather Card - Windy Style */
        .weather-card {
            background: rgba(0,0,0,0.4);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.08);
            margin-bottom: 15px;
        }

        .current-weather {
            display: flex;
            align-items: center;
            gap: 25px;
            margin-bottom: 20px;
        }

        .weather-icon-large {
            font-size: 5rem;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
        }

        .weather-info {
            flex: 1;
        }

        .city-name {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .weather-date {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.6);
            margin-bottom: 10px;
        }

        .temp-display {
            display: flex;
            align-items: baseline;
            gap: 8px;
        }

        .temp-main {
            font-size: 3.5rem;
            font-weight: 300;
        }

        .temp-feels {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.6);
        }

        .weather-desc {
            font-size: 1.1rem;
            color: rgba(255,255,255,0.8);
            margin-top: 5px;
        }

        /* Wind Particles Visualization - Windy Style */
        .wind-particles-container {
            background: linear-gradient(135deg, rgba(0,30,60,0.9) 0%, rgba(0,50,100,0.7) 100%);
            border-radius: 12px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
            height: 140px;
        }

        .wind-particles-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .wind-particles-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 12px 15px;
            pointer-events: none;
            z-index: 10;
        }

        .wind-data-box {
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            border-radius: 10px;
            padding: 10px 14px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .wind-data-speed {
            font-size: 2.2rem;
            font-weight: 700;
            color: #4fc3f7;
            line-height: 1;
            text-shadow: 0 2px 10px rgba(79,195,247,0.5);
        }

        .wind-data-speed .unit {
            font-size: 0.9rem;
            font-weight: 400;
            opacity: 0.8;
        }

        .wind-data-dir {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.8);
            margin-top: 4px;
        }

        .wind-data-beaufort {
            display: flex;
            gap: 2px;
            margin-top: 6px;
        }

        .bf-seg {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(255,255,255,0.15);
        }

        .bf-seg.active { background: #4fc3f7; box-shadow: 0 0 6px #4fc3f7; }
        .bf-seg.gust { background: #ff7043; box-shadow: 0 0 6px #ff7043; }

        .wind-gust-box {
            background: rgba(255,107,53,0.25);
            backdrop-filter: blur(8px);
            border-radius: 10px;
            padding: 10px 14px;
            border: 1px solid rgba(255,107,53,0.4);
            text-align: center;
        }

        .wind-gust-val {
            font-size: 1.6rem;
            font-weight: 700;
            color: #ff7043;
            text-shadow: 0 2px 10px rgba(255,112,67,0.5);
        }

        .wind-gust-lbl {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.7);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .wind-compass-overlay {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 55px;
            height: 55px;
            z-index: 10;
        }

        .wind-compass-overlay svg {
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        /* Rain Forecast Widget */
        .rain-forecast {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 12px 15px;
            margin: 10px 0;
        }

        .rain-forecast-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .rain-forecast-title {
            font-size: 0.85rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .rain-status {
            font-size: 0.75rem;
            padding: 3px 8px;
            border-radius: 10px;
        }

        .rain-status.dry {
            background: rgba(46,204,113,0.2);
            color: #2ecc71;
        }

        .rain-status.light {
            background: rgba(0,180,216,0.2);
            color: var(--accent-blue);
        }

        .rain-status.moderate {
            background: rgba(241,196,15,0.2);
            color: #f1c40f;
        }

        .rain-status.heavy {
            background: rgba(231,76,60,0.2);
            color: #e74c3c;
        }

        .rain-timeline {
            display: flex;
            gap: 6px;
        }

        .rain-slot {
            flex: 1;
            text-align: center;
            padding: 8px 4px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            transition: all 0.3s;
        }

        .rain-slot.has-rain {
            background: rgba(0,180,216,0.15);
            border: 1px solid rgba(0,180,216,0.3);
        }

        .rain-slot.heavy-rain {
            background: rgba(231,76,60,0.15);
            border: 1px solid rgba(231,76,60,0.3);
        }

        .rain-slot-time {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            margin-bottom: 4px;
        }

        .rain-slot-icon {
            font-size: 1.2rem;
            margin-bottom: 2px;
        }

        .rain-slot-amount {
            font-size: 0.75rem;
            font-weight: 600;
        }

        .rain-slot-amount.none {
            color: rgba(255,255,255,0.4);
        }

        .rain-slot-amount.light {
            color: var(--accent-blue);
        }

        .rain-slot-amount.moderate {
            color: #f1c40f;
        }

        .rain-slot-amount.heavy {
            color: #e74c3c;
        }

        /* Mini Rain Bar */
        .rain-mini-bar {
            display: flex;
            gap: 1px;
            height: 20px;
            margin-top: 8px;
            border-radius: 4px;
            overflow: hidden;
        }

        .rain-mini-segment {
            flex: 1;
            background: rgba(255,255,255,0.05);
            transition: background 0.3s;
        }

        .rain-mini-segment.level-1 { background: rgba(0,180,216,0.4); }
        .rain-mini-segment.level-2 { background: rgba(0,180,216,0.7); }
        .rain-mini-segment.level-3 { background: rgba(241,196,15,0.7); }
        .rain-mini-segment.level-4 { background: rgba(255,107,53,0.8); }
        .rain-mini-segment.level-5 { background: rgba(231,76,60,0.9); }

        .model-tag {
            font-size: 0.7rem;
            padding: 3px 8px;
            background: rgba(0,180,216,0.3);
            border-radius: 10px;
            font-weight: 500;
        }

        .model-tag.hd {
            background: linear-gradient(135deg, rgba(255,107,53,0.4), rgba(255,165,0,0.4));
            border: 1px solid rgba(255,165,0,0.5);
        }

        /* Swell Direction */
        .swell-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(155,89,182,0.15);
            border: 1px solid rgba(155,89,182,0.3);
            border-radius: 10px;
            margin: 15px 0;
        }

        .swell-compass {
            width: 80px;
            height: 80px;
            position: relative;
        }

        .swell-compass svg {
            width: 100%;
            height: 100%;
        }

        .swell-arrow {
            fill: var(--accent-purple);
            transition: transform 0.5s ease;
        }

        .swell-info {
            flex: 1;
        }

        .swell-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .swell-details {
            display: flex;
            gap: 20px;
        }

        .swell-detail {
            text-align: center;
        }

        .swell-detail .value {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--accent-purple);
        }

        .swell-detail .label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
        }

        /* Details Grid */
        .details-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        @media (max-width: 600px) {
            .details-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .detail-item {
            background: rgba(0,0,0,0.25);
            border-radius: 10px;
            padding: 12px;
            text-align: center;
        }

        .detail-icon {
            font-size: 1.4rem;
            margin-bottom: 6px;
        }

        .detail-value {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .detail-label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            margin-top: 3px;
        }

        /* Side Panel */
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 0;
            overflow: hidden;
        }

        .panel-card {
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255,255,255,0.08);
            overflow: hidden;
        }

        .left-panel {
            min-width: 0;
            overflow: hidden;
        }

        .panel-title {
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Tides Section */
        .tides-container {
            padding: 15px;
            background: rgba(0,119,182,0.15);
            border: 1px solid rgba(0,119,182,0.3);
            border-radius: 12px;
        }

        .tides-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .tides-title {
            font-size: 0.9rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tides-coefficient {
            padding: 4px 10px;
            background: rgba(0,180,216,0.3);
            border-radius: 15px;
            font-size: 0.75rem;
        }

        .tides-chart {
            height: 80px;
            position: relative;
            margin: 15px 0;
        }

        .tides-chart svg {
            width: 100%;
            height: 100%;
        }

        .tide-curve {
            fill: none;
            stroke: var(--accent-blue);
            stroke-width: 2;
        }

        .tide-area {
            fill: url(#tideGrad);
        }

        .tide-now-line {
            stroke: var(--accent-orange);
            stroke-width: 2;
            stroke-dasharray: 4 2;
        }

        .tide-now-dot {
            fill: var(--accent-orange);
        }

        .tides-times {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .tide-time {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .tide-icon {
            font-size: 1.5rem;
        }

        .tide-info .time {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .tide-info .height {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.6);
        }

        .tide-info .label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
        }

        /* Port Info */
        .port-info {
            background: rgba(155,89,182,0.15);
            border: 1px solid rgba(155,89,182,0.3);
            border-radius: 12px;
            padding: 15px;
        }

        .port-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .port-title {
            font-size: 0.9rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .port-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .port-item {
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            text-align: center;
        }

        .port-item .value {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent-purple);
        }

        .port-item .label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            margin-top: 4px;
        }

        /* Bulletin Côtier */
        .bulletin-container {
            background: rgba(46,204,113,0.1);
            border: 1px solid rgba(46,204,113,0.3);
            border-radius: 12px;
            padding: 15px;
        }

        .bulletin-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .bulletin-title {
            font-size: 0.9rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .bulletin-date {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
        }

        .bulletin-zone {
            padding: 4px 10px;
            background: rgba(46,204,113,0.3);
            border-radius: 15px;
            font-size: 0.75rem;
        }

        /* Bulletin Marine Détaillé */
        .marine-bulletin {
            background: linear-gradient(135deg, rgba(0,119,182,0.2) 0%, rgba(0,80,120,0.15) 100%);
            border: 1px solid rgba(0,119,182,0.3);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .marine-bulletin-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .marine-bulletin-title {
            font-size: 1rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .marine-bulletin-title img {
            height: 24px;
        }

        .zone-selector {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .zone-select {
            padding: 6px 12px;
            border: 1px solid rgba(0,119,182,0.4);
            border-radius: 8px;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 0.85rem;
            cursor: pointer;
            outline: none;
        }

        .zone-select option {
            background: #1a1a2e;
        }

        .zone-select:focus {
            border-color: var(--accent-blue);
        }

        .marine-bulletin-meta {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            font-size: 0.75rem;
            color: rgba(255,255,255,0.6);
            flex-wrap: wrap;
        }

        .marine-bulletin-meta span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .bulletin-block {
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .bulletin-block:last-child {
            margin-bottom: 0;
        }

        .bulletin-block-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--accent-blue);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .bulletin-block-content {
            font-size: 0.85rem;
            line-height: 1.6;
            color: rgba(255,255,255,0.9);
        }

        .bulletin-warning {
            background: rgba(241,196,15,0.15);
            border: 1px solid rgba(241,196,15,0.3);
            border-radius: 8px;
            padding: 10px 12px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bulletin-warning.danger {
            background: rgba(231,76,60,0.15);
            border-color: rgba(231,76,60,0.3);
        }

        .bulletin-warning-icon {
            font-size: 1.2rem;
        }

        .bulletin-warning-text {
            font-size: 0.8rem;
            font-weight: 500;
        }

        .bulletin-forecast-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        @media (max-width: 600px) {
            .bulletin-forecast-grid {
                grid-template-columns: 1fr;
            }
        }

        .bulletin-forecast-item {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }

        .bulletin-forecast-period {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            margin-bottom: 5px;
        }

        .bulletin-forecast-wind {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent-blue);
        }

        .bulletin-forecast-sea {
            font-size: 0.75rem;
            color: var(--accent-purple);
            margin-top: 4px;
        }

        .bulletin-content {
            font-size: 0.85rem;
            line-height: 1.6;
            color: rgba(255,255,255,0.9);
        }

        .bulletin-section {
            margin-bottom: 12px;
        }

        .bulletin-section-title {
            font-weight: 600;
            color: var(--accent-green);
            margin-bottom: 4px;
            font-size: 0.8rem;
        }

        .bulletin-section-text {
            font-size: 0.8rem;
            opacity: 0.9;
        }

        /* Hourly Scroll */
        .hourly-scroll {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding-bottom: 8px;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.2) transparent;
        }

        .hourly-scroll::-webkit-scrollbar {
            height: 4px;
        }

        .hourly-scroll::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }

        .hour-item {
            min-width: 65px;
            padding: 10px 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            text-align: center;
            flex-shrink: 0;
            transition: all 0.2s;
            cursor: pointer;
        }

        .hour-item:hover {
            background: rgba(255,255,255,0.1);
        }

        .hour-item.active {
            background: rgba(0,180,216,0.2);
            border: 1px solid rgba(0,180,216,0.3);
        }

        .hour-time {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.6);
            margin-bottom: 6px;
        }

        .hour-icon {
            font-size: 1.3rem;
            margin-bottom: 6px;
        }

        .hour-temp {
            font-size: 0.9rem;
            font-weight: 600;
        }

        .hour-wind {
            font-size: 0.7rem;
            color: var(--accent-blue);
            margin-top: 4px;
        }

        .hour-gust {
            font-size: 0.65rem;
            color: var(--accent-orange);
        }

        .hour-wave {
            font-size: 0.65rem;
            color: var(--accent-purple);
            margin-top: 2px;
        }

        /* Pressure Chart */
        .pressure-chart {
            height: 100px;
            position: relative;
            margin: 10px 0;
        }

        .chart-svg {
            width: 100%;
            height: 100%;
        }

        .chart-line {
            fill: none;
            stroke: var(--accent-blue);
            stroke-width: 2;
            stroke-linecap: round;
        }

        .chart-area {
            fill: url(#pressureGrad);
        }

        .chart-grid {
            stroke: rgba(255,255,255,0.1);
            stroke-width: 1;
        }

        .pressure-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 0.75rem;
        }

        .pressure-stat {
            text-align: center;
        }

        .pressure-stat .value {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .pressure-stat .label {
            color: rgba(255,255,255,0.5);
            font-size: 0.65rem;
        }

        .trend-up { color: var(--accent-green); }
        .trend-down { color: var(--accent-orange); }
        .trend-stable { color: var(--accent-blue); }

        /* Marine Specific */
        .marine-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .marine-item {
            background: rgba(0,0,0,0.25);
            border-radius: 10px;
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .marine-icon {
            font-size: 1.5rem;
        }

        .marine-info .value {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .marine-info .label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
        }

        /* Wave Display */
        .wave-visual {
            height: 80px;
            background: linear-gradient(180deg, transparent, rgba(0,119,182,0.3));
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            margin: 10px 0;
        }

        .wave-line {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 200%;
            height: 100%;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1200 120'%3E%3Cpath fill='rgba(0,180,216,0.4)' d='M0,60 C150,120 350,0 600,60 C850,120 1050,0 1200,60 L1200,120 L0,120 Z'/%3E%3C/svg%3E") repeat-x;
            animation: wave-move 4s linear infinite;
        }

        @keyframes wave-move {
            from { transform: translateX(0); }
            to { transform: translateX(-50%); }
        }

        .wave-stats {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .wave-height-value {
            font-size: 2rem;
            font-weight: 700;
        }

        .wave-height-label {
            font-size: 0.75rem;
            opacity: 0.7;
        }

        /* Wind/Gust Chart */
        .wind-chart-container {
            background: rgba(0,0,0,0.25);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
        }

        .wind-chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .wind-chart-title {
            font-size: 0.9rem;
            font-weight: 600;
        }

        .wind-chart-legend {
            display: flex;
            gap: 15px;
            font-size: 0.75rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .legend-dot.wind {
            background: var(--accent-blue);
        }

        .legend-dot.gust {
            background: var(--accent-orange);
        }

        .wind-chart {
            height: 120px;
            position: relative;
        }

        .wind-chart svg {
            width: 100%;
            height: 100%;
        }

        .wind-line {
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .wind-line.main {
            stroke: var(--accent-blue);
        }

        .wind-line.gust {
            stroke: var(--accent-orange);
            stroke-dasharray: 4 2;
        }

        .wind-area {
            fill: url(#windGrad);
        }

        .gust-area {
            fill: url(#gustGrad);
        }

        .wind-chart-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.65rem;
            color: rgba(255,255,255,0.5);
            margin-top: 5px;
        }

        /* Wave Chart */
        .wave-chart-container {
            background: linear-gradient(135deg, rgba(155,89,182,0.15), rgba(155,89,182,0.05));
            border: 1px solid rgba(155,89,182,0.2);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
        }

        .wave-chart {
            height: 100px;
            position: relative;
        }

        .wave-chart svg {
            width: 100%;
            height: 100%;
        }

        .wave-line-chart {
            fill: none;
            stroke: var(--accent-purple);
            stroke-width: 2.5;
            stroke-linecap: round;
        }

        .wave-area-fill {
            fill: url(#waveGrad);
        }

        /* Tide Curve */
        .tide-curve-container {
            background: linear-gradient(135deg, rgba(0,119,182,0.15), rgba(0,119,182,0.05));
            border: 1px solid rgba(0,119,182,0.2);
            border-radius: 12px;
            padding: 15px;
            margin-top: 15px;
        }

        .tide-curve-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .tide-curve-chart {
            height: 100px;
            position: relative;
        }

        .tide-curve-chart svg {
            width: 100%;
            height: 100%;
        }

        .tide-curve-path {
            fill: none;
            stroke: var(--accent-blue);
            stroke-width: 2.5;
        }

        .tide-area-fill {
            fill: url(#tideGradient);
        }

        .tide-now-marker {
            fill: var(--accent-orange);
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }

        .tide-time-marker {
            fill: rgba(255,255,255,0.6);
            font-size: 8px;
        }

        .tide-height-marker {
            fill: rgba(255,255,255,0.4);
            font-size: 7px;
        }

        .tide-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 0.7rem;
            color: rgba(255,255,255,0.6);
        }

        /* Rain Radar */
        .radar-container {
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .radar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .radar-title {
            font-size: 0.9rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .radar-live {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.7rem;
            padding: 3px 8px;
            background: rgba(231,76,60,0.3);
            border-radius: 10px;
        }

        .radar-live .pulse {
            width: 6px;
            height: 6px;
            background: #e74c3c;
            border-radius: 50%;
            animation: pulse-radar 1.5s infinite;
        }

        @keyframes pulse-radar {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        .radar-map {
            height: 200px;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            background: #1a1a2e;
            max-width: 100%;
        }

        .radar-map #radarMap {
            height: 100%;
            width: 100%;
        }

        @media (max-width: 600px) {
            .radar-map {
                height: 180px;
            }
        }

        .radar-controls {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            align-items: center;
        }

        .radar-btn {
            padding: 6px 12px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .radar-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .radar-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
        }

        .radar-timeline {
            flex: 1;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            position: relative;
            cursor: pointer;
        }

        .radar-timeline-progress {
            height: 100%;
            background: var(--accent-blue);
            border-radius: 2px;
            transition: width 0.3s;
        }

        .radar-time-label {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.7);
            min-width: 50px;
            text-align: right;
        }

        .radar-legend {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
            font-size: 0.65rem;
        }

        .radar-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .radar-legend-color {
            width: 12px;
            height: 8px;
            border-radius: 2px;
        }

        /* Sea State */
        .sea-state-bar {
            height: 6px;
            background: linear-gradient(to right, #00b894, #fdcb6e, #e17055, #d63031, #6c5ce7);
            border-radius: 3px;
            position: relative;
            margin: 15px 0 8px;
        }

        .sea-state-marker {
            position: absolute;
            top: -5px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transform: translateX(-50%);
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: left 0.5s;
        }

        .sea-state-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.65rem;
            opacity: 0.6;
        }

        /* Safety Alert */
        .safety-alert {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .safety-alert.safe {
            background: rgba(46,204,113,0.15);
            border: 1px solid rgba(46,204,113,0.3);
        }

        .safety-alert.warning {
            background: rgba(241,196,15,0.15);
            border: 1px solid rgba(241,196,15,0.3);
        }

        .safety-alert.danger {
            background: rgba(231,76,60,0.15);
            border: 1px solid rgba(231,76,60,0.3);
        }

        .safety-icon {
            font-size: 1.3rem;
        }

        .safety-text .title {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .safety-text .desc {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 4px;
            background: rgba(0,0,0,0.3);
            padding: 4px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .tab-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: transparent;
            color: rgba(255,255,255,0.6);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab-btn.active {
            background: rgba(255,255,255,0.1);
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Loading */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 300px;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 12px;
            font-size: 0.9rem;
            opacity: 0.7;
        }

        /* Daily Forecast */
        .daily-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background: rgba(255,255,255,0.03);
            border-radius: 8px;
            margin-bottom: 6px;
        }

        .daily-day {
            width: 50px;
            font-size: 0.8rem;
        }

        .daily-icon {
            font-size: 1.2rem;
            margin-right: 8px;
        }

        .daily-temps {
            flex: 1;
            display: flex;
            gap: 8px;
            font-size: 0.85rem;
        }

        .daily-high {
            font-weight: 600;
        }

        .daily-low {
            opacity: 0.5;
        }

        .daily-wind {
            font-size: 0.75rem;
            color: var(--accent-blue);
            width: 60px;
            text-align: right;
        }

        .daily-gust {
            font-size: 0.7rem;
            color: var(--accent-orange);
            width: 50px;
            text-align: right;
        }

        /* Error message */
        .error-message {
            background: rgba(231,76,60,0.2);
            border: 1px solid rgba(231,76,60,0.4);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }

        .error-message .icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .error-message .text {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .retry-btn {
            margin-top: 10px;
            padding: 8px 20px;
            background: rgba(231,76,60,0.3);
            border: 1px solid rgba(231,76,60,0.5);
            border-radius: 6px;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
        }

        .retry-btn:hover {
            background: rgba(231,76,60,0.5);
        }

        /* Last update */
        .last-update {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.4);
            text-align: right;
            margin-top: 10px;
        }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 16px;
            padding: 25px;
            width: 90%;
            max-width: 500px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            opacity: 0.7;
        }

        .modal-close:hover {
            opacity: 1;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-label {
            display: block;
            font-size: 0.85rem;
            margin-bottom: 6px;
            color: rgba(255,255,255,0.8);
        }

        .form-input {
            width: 100%;
            padding: 12px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 0.9rem;
            outline: none;
        }

        .form-input:focus {
            border-color: var(--accent-blue);
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .form-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }

        .form-checkbox input {
            width: 18px;
            height: 18px;
        }

        .btn-primary {
            width: 100%;
            padding: 12px;
            background: var(--accent-blue);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary:hover {
            background: #0096c7;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .header {
                flex-direction: column;
                align-items: stretch;
            }

            .search-input {
                width: 100%;
            }

            .search-container {
                flex-wrap: wrap;
            }

            .control-bar {
                flex-direction: column;
                align-items: stretch;
                padding: 10px;
            }

            .control-group {
                flex-wrap: wrap;
            }

            .unit-selector {
                flex-wrap: wrap;
            }

            .current-weather {
                flex-direction: column;
                text-align: center;
            }

            .wind-particles-container {
                height: 120px;
            }

            .wind-particles-overlay {
                padding: 8px 10px;
            }

            .wind-data-speed {
                font-size: 1.8rem;
            }

            .marine-grid, .port-grid, .tides-times {
                grid-template-columns: 1fr;
            }

            .details-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="logo">
                <span class="logo-icon" id="logoIcon">🌊</span>
                <span>Jmee Weather Station</span>
            </div>

            <div class="mode-toggle">
                <button class="mode-btn active" data-mode="weather" id="weatherModeBtn">🌍 Terrestre</button>
                <button class="mode-btn" data-mode="marine" id="marineModeBtn">⚓ Marine</button>
            </div>

            <div class="search-container">
                <input type="text" class="search-input" id="searchInput" placeholder="Ville, port, zone...">
                <button class="btn btn-icon" id="searchBtn">🔍</button>
                <button class="btn btn-icon" id="locationBtn" title="Ma position">📍</button>
                <button class="btn btn-icon btn-add" id="addFavoriteBtn" title="Ajouter aux favoris">⭐</button>
            </div>

            <div class="location-badge" id="locationBadge">
                <span class="dot"></span>
                <span id="locationText">Localisation...</span>
            </div>

            <div class="api-status" id="apiStatus">
                <span class="status-dot"></span>
                <span id="apiStatusText">API Live</span>
            </div>
        </header>

        <div class="control-bar">
            <div class="control-group">
                <span class="control-label">Modèle</span>
                <select class="control-select" id="modelSelect">
                    <option value="arome_france_hd">AROME HD (500m) ⭐</option>
                    <option value="arome_france">AROME (1.3km)</option>
                    <option value="arpege_europe">ARPÈGE Europe (10km)</option>
                    <option value="ecmwf_ifs025">ECMWF IFS (25km)</option>
                    <option value="gfs_seamless">GFS (25km)</option>
                    <option value="icon_seamless">ICON (7km)</option>
                </select>
            </div>

            <div class="control-group">
                <span class="control-label">Vent</span>
                <div class="unit-selector" id="windUnitSelector">
                    <button class="unit-btn active" data-unit="kmh">km/h</button>
                    <button class="unit-btn" data-unit="kt">kt</button>
                    <button class="unit-btn" data-unit="ms">m/s</button>
                    <button class="unit-btn" data-unit="bft">Bft</button>
                </div>
            </div>

            <div class="control-group">
                <span class="control-label">Temp</span>
                <div class="unit-selector" id="tempUnitSelector">
                    <button class="unit-btn active" data-unit="celsius">°C</button>
                    <button class="unit-btn" data-unit="fahrenheit">°F</button>
                </div>
            </div>

            <div class="control-group" id="waveUnitGroup" style="display:none">
                <span class="control-label">Vagues</span>
                <div class="unit-selector" id="waveUnitSelector">
                    <button class="unit-btn active" data-unit="m">m</button>
                    <button class="unit-btn" data-unit="ft">ft</button>
                </div>
            </div>

            <div class="control-group">
                <span class="control-label">Pression</span>
                <div class="unit-selector" id="pressureUnitSelector">
                    <button class="unit-btn active" data-unit="hpa">hPa</button>
                    <button class="unit-btn" data-unit="inhg">inHg</button>
                </div>
            </div>
        </div>

        <div class="favorites-section">
            <div class="favorites-header">
                <div class="favorites-title">⭐ Favoris</div>
            </div>
            <div class="favorites-row" id="favoritesRow"></div>
        </div>

        <main id="mainContent">
            <div class="loading">
                <div class="loading-spinner"></div>
                <p class="loading-text">Géolocalisation en cours...</p>
            </div>
        </main>
    </div>

    <!-- Modal Ajouter Favori -->
    <div class="modal-overlay" id="addFavoriteModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">⭐ Ajouter aux favoris</h3>
                <button class="modal-close" id="closeModal">&times;</button>
            </div>
            <form id="addFavoriteForm">
                <div class="form-group">
                    <label class="form-label">Nom du lieu</label>
                    <input type="text" class="form-input" id="favName" placeholder="Ex: Brest, Port de Marseille..." required>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Latitude</label>
                        <input type="number" step="0.0001" class="form-input" id="favLat" placeholder="48.3904" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Longitude</label>
                        <input type="number" step="0.0001" class="form-input" id="favLon" placeholder="-4.4861" required>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Emoji (optionnel)</label>
                    <input type="text" class="form-input" id="favEmoji" placeholder="🌊" maxlength="2">
                </div>
                <div class="form-group">
                    <label class="form-checkbox">
                        <input type="checkbox" id="favIsPort">
                        <span>C'est un port (afficher infos portuaires)</span>
                    </label>
                </div>
                <div class="form-group">
                    <label class="form-checkbox">
                        <input type="checkbox" id="favIsCoastal" checked>
                        <span>Zone côtière (données marines disponibles)</span>
                    </label>
                </div>
                <button type="submit" class="btn-primary">Ajouter aux favoris</button>
            </form>
        </div>
    </div>

    <script>
        // État de l'application
        const state = {
            currentCity: null,
            currentCoords: null,
            mode: 'weather',
            model: 'arome_france_hd',
            units: {
                wind: 'kmh',
                temp: 'celsius',
                wave: 'm',
                pressure: 'hpa'
            },
            weatherData: null,
            marineData: null,
            tidesData: null,
            isLoading: true,
            lastUpdate: null,
            apiError: false,
            favorites: []
        };

        // Favoris par défaut
        const defaultFavorites = [
            { name: 'Paris', lat: 48.8566, lon: 2.3522, emoji: '🗼', isPort: false, isCoastal: false },
            { name: 'Marseille', lat: 43.2965, lon: 5.3698, emoji: '⚓', isPort: true, isCoastal: true },
            { name: 'Brest', lat: 48.3904, lon: -4.4861, emoji: '🌊', isPort: true, isCoastal: true },
            { name: 'Nice', lat: 43.7102, lon: 7.2620, emoji: '☀️', isPort: true, isCoastal: true },
            { name: 'La Rochelle', lat: 46.1603, lon: -1.1511, emoji: '⛵', isPort: true, isCoastal: true },
            { name: 'Saint-Malo', lat: 48.6493, lon: -2.0076, emoji: '🏴‍☠️', isPort: true, isCoastal: true }
        ];

        // Zones marines Météo-France officielles
        const marineZones = {
            // Manche - Mer du Nord
            'pas-de-calais': { name: 'Pas-de-Calais', region: 'Manche - Mer du Nord', coords: { lat: 50.9, lon: 1.8 } },
            'antifer': { name: 'Antifer', region: 'Manche - Mer du Nord', coords: { lat: 49.6, lon: 0.1 } },
            'casquets': { name: 'Casquets', region: 'Manche', coords: { lat: 49.7, lon: -2.2 } },
            'ouessant': { name: 'Ouessant', region: 'Manche', coords: { lat: 48.5, lon: -5.1 } },
            // Atlantique
            'iroise': { name: 'Iroise', region: 'Atlantique', coords: { lat: 48.2, lon: -5.0 } },
            'yeu': { name: 'Yeu', region: 'Atlantique', coords: { lat: 46.7, lon: -2.3 } },
            'rochebonne': { name: 'Rochebonne', region: 'Atlantique', coords: { lat: 46.2, lon: -2.4 } },
            'cantabrico': { name: 'Cantabrico', region: 'Atlantique', coords: { lat: 44.0, lon: -3.0 } },
            'finisterre': { name: 'Finisterre', region: 'Atlantique', coords: { lat: 43.0, lon: -9.5 } },
            // Méditerranée
            'lion': { name: 'Golfe du Lion', region: 'Méditerranée', coords: { lat: 42.5, lon: 4.0 } },
            'provence': { name: 'Provence', region: 'Méditerranée', coords: { lat: 43.0, lon: 6.0 } },
            'ligure': { name: 'Ligure', region: 'Méditerranée', coords: { lat: 43.5, lon: 8.5 } },
            'corse': { name: 'Côtes Corses', region: 'Méditerranée', coords: { lat: 42.0, lon: 9.0 } },
            'sardaigne': { name: 'Sardaigne', region: 'Méditerranée', coords: { lat: 40.5, lon: 8.5 } }
        };

        // Groupes de zones par région
        const marineRegions = {
            'manche': {
                name: 'Manche - Mer du Nord',
                zones: ['pas-de-calais', 'antifer', 'casquets', 'ouessant'],
                icon: '🌊'
            },
            'atlantique': {
                name: 'Atlantique',
                zones: ['iroise', 'yeu', 'rochebonne', 'cantabrico', 'finisterre'],
                icon: '🌊'
            },
            'mediterranee': {
                name: 'Méditerranée',
                zones: ['lion', 'provence', 'ligure', 'corse', 'sardaigne'],
                icon: '☀️'
            }
        };

        // Zone sélectionnée pour le bulletin
        let selectedMarineZone = 'lion';

        // Ports français avec informations
        const portsInfo = {
            'Marseille': { vhf: '12', tidalRange: 'faible', harbor: 'Vieux-Port', facilities: ['Carburant', 'Eau', 'Électricité', 'Sanitaires'] },
            'Brest': { vhf: '16', tidalRange: 'fort', harbor: 'Port de Commerce', facilities: ['Carburant', 'Eau', 'Électricité', 'Grue'] },
            'Nice': { vhf: '09', tidalRange: 'faible', harbor: 'Port Lympia', facilities: ['Carburant', 'Eau', 'Électricité', 'Sanitaires'] },
            'La Rochelle': { vhf: '09', tidalRange: 'fort', harbor: 'Les Minimes', facilities: ['Carburant', 'Eau', 'Électricité', 'Shipchandler'] },
            'Saint-Malo': { vhf: '09', tidalRange: 'très fort', harbor: 'Port des Sablons', facilities: ['Carburant', 'Eau', 'Électricité', 'Grue'] }
        };

        // Configuration des modèles météo
        const models = {
            arome_france_hd: { name: 'AROME HD', resolution: '500m', range: '48h', update: '1h', provider: 'Météo-France', api: 'meteofrance', isHD: true },
            arome_france: { name: 'AROME', resolution: '1.3km', range: '48h', update: '3h', provider: 'Météo-France', api: 'meteofrance', isHD: false },
            arpege_europe: { name: 'ARPÈGE', resolution: '10km', range: '4j', update: '6h', provider: 'Météo-France', api: 'meteofrance', isHD: false },
            ecmwf_ifs025: { name: 'ECMWF IFS', resolution: '25km', range: '10j', update: '6h', provider: 'ECMWF', api: 'ecmwf', isHD: false },
            gfs_seamless: { name: 'GFS', resolution: '25km', range: '16j', update: '6h', provider: 'NOAA', api: 'gfs', isHD: false },
            icon_seamless: { name: 'ICON', resolution: '7km', range: '7j', update: '6h', provider: 'DWD', api: 'icon', isHD: false }
        };

        // Codes météo WMO
        const weatherCodes = {
            0: { icon: '☀️', desc: 'Ciel dégagé' }, 1: { icon: '🌤️', desc: 'Principalement dégagé' },
            2: { icon: '⛅', desc: 'Partiellement nuageux' }, 3: { icon: '☁️', desc: 'Couvert' },
            45: { icon: '🌫️', desc: 'Brouillard' }, 48: { icon: '🌫️', desc: 'Brouillard givrant' },
            51: { icon: '🌦️', desc: 'Bruine légère' }, 53: { icon: '🌦️', desc: 'Bruine modérée' },
            55: { icon: '🌧️', desc: 'Bruine dense' }, 61: { icon: '🌧️', desc: 'Pluie légère' },
            63: { icon: '🌧️', desc: 'Pluie modérée' }, 65: { icon: '🌧️', desc: 'Pluie forte' },
            71: { icon: '🌨️', desc: 'Neige légère' }, 73: { icon: '🌨️', desc: 'Neige modérée' },
            75: { icon: '❄️', desc: 'Neige forte' }, 80: { icon: '🌦️', desc: 'Averses légères' },
            81: { icon: '🌧️', desc: 'Averses modérées' }, 82: { icon: '⛈️', desc: 'Averses violentes' },
            95: { icon: '⛈️', desc: 'Orage' }, 96: { icon: '⛈️', desc: 'Orage avec grêle' }
        };

        // États de la mer (Douglas)
        const seaStates = [
            { name: 'Calme', desc: 'Mer d\'huile', maxHeight: 0 },
            { name: 'Ridée', desc: 'Vaguelettes', maxHeight: 0.1 },
            { name: 'Belle', desc: 'Petites vagues', maxHeight: 0.5 },
            { name: 'Peu agitée', desc: 'Vagues modérées', maxHeight: 1.25 },
            { name: 'Agitée', desc: 'Vagues fortes', maxHeight: 2.5 },
            { name: 'Forte', desc: 'Grosses vagues', maxHeight: 4 },
            { name: 'Très forte', desc: 'Très grosses vagues', maxHeight: 6 },
            { name: 'Grosse', desc: 'Vagues énormes', maxHeight: 9 },
            { name: 'Très grosse', desc: 'Déferlantes', maxHeight: 14 },
            { name: 'Énorme', desc: 'Phénoménale', maxHeight: Infinity }
        ];

        // Charger les favoris depuis localStorage
        function loadFavorites() {
            const saved = localStorage.getItem('meteoAppFavorites');
            if (saved) {
                state.favorites = JSON.parse(saved);
            } else {
                state.favorites = [...defaultFavorites];
                saveFavorites();
            }
            renderFavorites();
        }

        // Sauvegarder les favoris
        function saveFavorites() {
            localStorage.setItem('meteoAppFavorites', JSON.stringify(state.favorites));
        }

        // Rendre les favoris
        function renderFavorites() {
            const container = document.getElementById('favoritesRow');
            container.innerHTML = state.favorites.map((fav, index) => `
                <button class="favorite-chip ${fav.isPort ? 'port' : ''}"
                        data-index="${index}"
                        data-lat="${fav.lat}"
                        data-lon="${fav.lon}"
                        data-name="${fav.name}"
                        data-coastal="${fav.isCoastal}"
                        data-port="${fav.isPort}">
                    ${fav.emoji || '📍'} ${fav.name}
                    <span class="delete-fav" data-delete="${index}">✕</span>
                </button>
            `).join('');
        }

        // API Météo
        async function fetchWeatherData(lat, lon, modelKey) {
            const model = models[modelKey];
            let baseUrl = 'https://api.open-meteo.com/v1/';

            if (model.api === 'meteofrance') baseUrl += 'meteofrance';
            else if (model.api === 'ecmwf') baseUrl += 'ecmwf';
            else if (model.api === 'gfs') baseUrl += 'gfs';
            else if (model.api === 'icon') baseUrl += 'dwd-icon';
            else baseUrl += 'forecast';

            const params = new URLSearchParams({
                latitude: lat,
                longitude: lon,
                hourly: 'temperature_2m,relative_humidity_2m,apparent_temperature,precipitation,weather_code,pressure_msl,cloud_cover,wind_speed_10m,wind_direction_10m,wind_gusts_10m',
                daily: 'weather_code,temperature_2m_max,temperature_2m_min,wind_speed_10m_max,wind_gusts_10m_max,wind_direction_10m_dominant',
                current: 'temperature_2m,relative_humidity_2m,apparent_temperature,is_day,precipitation,weather_code,cloud_cover,pressure_msl,wind_speed_10m,wind_direction_10m,wind_gusts_10m',
                timezone: 'Europe/Paris',
                forecast_days: '7'
            });

            if (model.api === 'meteofrance') params.append('models', modelKey);

            const response = await fetch(`${baseUrl}?${params.toString()}`);
            if (!response.ok) throw new Error(`API Error: ${response.status}`);
            const data = await response.json();

            // Si pressure_msl est null dans current (cas AROME HD), utiliser les données horaires
            if (data.current && (data.current.pressure_msl === null || data.current.pressure_msl === undefined)) {
                // Utiliser la première valeur horaire disponible
                if (data.hourly && data.hourly.pressure_msl) {
                    const validPressure = data.hourly.pressure_msl.find(p => p !== null && p !== undefined);
                    if (validPressure) {
                        data.current.pressure_msl = validPressure;
                    } else {
                        // Fallback: faire une requête standard sans modèle spécifique
                        try {
                            const fallbackResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=pressure_msl&timezone=Europe/Paris`);
                            const fallbackData = await fallbackResponse.json();
                            if (fallbackData.current?.pressure_msl) {
                                data.current.pressure_msl = fallbackData.current.pressure_msl;
                            }
                        } catch(e) {
                            console.warn('Fallback pressure fetch failed', e);
                        }
                    }
                }
            }

            // Même chose pour les données horaires si elles sont null
            if (data.hourly && data.hourly.pressure_msl) {
                const hasNullPressure = data.hourly.pressure_msl.some(p => p === null);
                if (hasNullPressure) {
                    try {
                        const fallbackResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=pressure_msl&timezone=Europe/Paris&forecast_days=2`);
                        const fallbackData = await fallbackResponse.json();
                        if (fallbackData.hourly?.pressure_msl) {
                            data.hourly.pressure_msl = fallbackData.hourly.pressure_msl;
                        }
                    } catch(e) {
                        console.warn('Fallback hourly pressure fetch failed', e);
                    }
                }
            }

            return data;
        }

        // API Marine
        async function fetchMarineData(lat, lon) {
            const params = new URLSearchParams({
                latitude: lat,
                longitude: lon,
                hourly: 'wave_height,wave_direction,wave_period,swell_wave_height,swell_wave_direction,swell_wave_period',
                current: 'wave_height,wave_direction,wave_period,swell_wave_height,swell_wave_direction,swell_wave_period',
                timezone: 'Europe/Paris',
                forecast_days: '7'
            });

            const response = await fetch(`https://marine-api.open-meteo.com/v1/marine?${params.toString()}`);
            if (!response.ok) throw new Error(`Marine API Error: ${response.status}`);
            return await response.json();
        }

        // Générer des données de marées simulées (en attendant une vraie API)
        function generateTidesData(lat, lon) {
            const now = new Date();
            const baseHeight = 3 + Math.random() * 2;
            const amplitude = 1.5 + Math.random() * 3;
            const coefficient = 60 + Math.floor(Math.random() * 60);

            // Calculer les heures de marée basées sur la position lunaire approximative
            const lunarOffset = (lon / 15) * 60; // minutes de décalage
            const baseTime = new Date(now);
            baseTime.setMinutes(baseTime.getMinutes() + lunarOffset);

            const tides = [];
            for (let i = 0; i < 4; i++) {
                const tideTime = new Date(baseTime);
                tideTime.setHours(tideTime.getHours() + i * 6 + Math.floor(Math.random() * 2));
                tides.push({
                    time: tideTime,
                    height: i % 2 === 0 ? baseHeight + amplitude : baseHeight - amplitude,
                    type: i % 2 === 0 ? 'high' : 'low'
                });
            }

            // Calculer le niveau actuel
            const currentPhase = ((now.getHours() * 60 + now.getMinutes()) % (6 * 60)) / (6 * 60);
            const currentHeight = baseHeight + Math.sin(currentPhase * Math.PI * 2) * amplitude;

            return {
                coefficient,
                currentHeight: Math.round(currentHeight * 10) / 10,
                tides: tides.sort((a, b) => a.time - b.time),
                range: amplitude * 2
            };
        }

        // Générer le bulletin côtier
        function generateCoastalBulletin(cityName, weatherData, marineData) {
            const wind = weatherData.current.wind_speed_10m;
            const gust = weatherData.current.wind_gusts_10m;
            const windDir = getWindDirection(weatherData.current.wind_direction_10m);
            const waveHeight = marineData?.current?.wave_height || 0;
            const swellHeight = marineData?.current?.swell_wave_height || 0;
            const swellDir = marineData?.current?.swell_wave_direction || 0;

            const beaufort = kmhToBeaufort(wind);
            const visibility = weatherData.current.cloud_cover > 80 ? 'Réduite' : 'Bonne';

            let seaDesc = 'Belle à peu agitée';
            if (waveHeight > 2.5) seaDesc = 'Agitée à forte';
            else if (waveHeight > 1.25) seaDesc = 'Peu agitée à agitée';
            else if (waveHeight > 0.5) seaDesc = 'Belle à peu agitée';

            const now = new Date();
            const bulletinDate = now.toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long' });
            const bulletinTime = now.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });

            return {
                zone: cityName,
                date: bulletinDate,
                time: bulletinTime,
                sections: [
                    {
                        title: 'Situation générale',
                        text: `Vent de secteur ${windDir} ${beaufort} à ${beaufort + 1} Beaufort, ${Math.round(wind)} à ${Math.round(gust)} km/h en rafales.`
                    },
                    {
                        title: 'État de la mer',
                        text: `${seaDesc}. Vagues de ${waveHeight.toFixed(1)}m. ${swellHeight > 0.3 ? `Houle de ${getWindDirection(swellDir)} de ${swellHeight.toFixed(1)}m.` : 'Pas de houle significative.'}`
                    },
                    {
                        title: 'Visibilité',
                        text: `${visibility}. ${weatherData.current.precipitation > 0 ? 'Passages pluvieux possibles.' : ''}`
                    },
                    {
                        title: 'Évolution',
                        text: `Tendance ${weatherData.hourly.wind_speed_10m[12] > wind ? 'au renforcement' : 'à l\'atténuation'} du vent dans les prochaines heures.`
                    }
                ]
            };
        }

        // Générer le bulletin marine détaillé pour une zone
        async function generateMarineBulletin(zoneKey) {
            const zone = marineZones[zoneKey];
            if (!zone) return null;

            const { lat, lon } = zone.coords;

            try {
                // Récupérer les données météo pour cette zone
                const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,wind_speed_10m,wind_direction_10m,wind_gusts_10m,cloud_cover,precipitation,weather_code&hourly=wind_speed_10m,wind_gusts_10m,wind_direction_10m,precipitation&timezone=Europe/Paris&forecast_days=2`);
                const weatherData = await weatherResponse.json();

                // Récupérer les données marines
                const marineResponse = await fetch(`https://marine-api.open-meteo.com/v1/marine?latitude=${lat}&longitude=${lon}&current=wave_height,wave_direction,wave_period,swell_wave_height,swell_wave_direction,swell_wave_period&hourly=wave_height,swell_wave_height&timezone=Europe/Paris&forecast_days=2`);
                const marineData = await marineResponse.json();

                const current = weatherData.current;
                const marine = marineData.current;
                const hourlyWind = weatherData.hourly.wind_speed_10m;
                const hourlyWave = marineData.hourly.wave_height;

                const wind = current.wind_speed_10m || 0;
                const gust = current.wind_gusts_10m || 0;
                const windDeg = current.wind_direction_10m || 0;
                const waveHeight = marine?.wave_height || 0;
                const wavePeriod = marine?.wave_period || 0;
                const swellHeight = marine?.swell_wave_height || 0;
                const swellDir = marine?.swell_wave_direction || 0;
                const swellPeriod = marine?.swell_wave_period || 0;

                const beaufort = kmhToBeaufort(wind);
                const gustBeaufort = kmhToBeaufort(gust);
                const seaStateIdx = getSeaState(waveHeight);
                const seaState = seaStates[seaStateIdx];

                // Déterminer le niveau d'alerte
                let warningLevel = null;
                let warningText = '';
                if (beaufort >= 8 || waveHeight >= 6) {
                    warningLevel = 'danger';
                    warningText = 'AVIS DE COUP DE VENT - Navigation fortement déconseillée';
                } else if (beaufort >= 6 || waveHeight >= 4) {
                    warningLevel = 'warning';
                    warningText = 'Conditions difficiles - Prudence recommandée';
                }

                // Prévisions par période
                const forecasts = [
                    { period: 'Ce matin', windIdx: 0 },
                    { period: 'Cet après-midi', windIdx: 6 },
                    { period: 'Ce soir', windIdx: 12 },
                    { period: 'Cette nuit', windIdx: 18 },
                    { period: 'Demain matin', windIdx: 24 },
                    { period: 'Demain après-midi', windIdx: 30 }
                ].slice(0, 3).map(f => ({
                    period: f.period,
                    wind: hourlyWind[f.windIdx] || wind,
                    wave: hourlyWave[f.windIdx] || waveHeight
                }));

                const now = new Date();

                return {
                    zone: zone.name,
                    region: zone.region,
                    date: now.toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' }),
                    time: now.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }),
                    warning: warningLevel ? { level: warningLevel, text: warningText } : null,
                    wind: {
                        speed: wind,
                        gust: gust,
                        direction: getWindDirection(windDeg),
                        directionDeg: windDeg,
                        beaufort: beaufort,
                        gustBeaufort: gustBeaufort
                    },
                    sea: {
                        state: seaState.name,
                        stateDesc: seaState.desc,
                        waveHeight: waveHeight,
                        wavePeriod: wavePeriod
                    },
                    swell: {
                        height: swellHeight,
                        direction: getWindDirection(swellDir),
                        directionDeg: swellDir,
                        period: swellPeriod
                    },
                    visibility: current.cloud_cover > 80 ? 'Moyenne à réduite' : current.cloud_cover > 50 ? 'Bonne à moyenne' : 'Bonne',
                    precipitation: current.precipitation > 0,
                    forecasts: forecasts
                };
            } catch (e) {
                console.error('Erreur génération bulletin marine:', e);
                return null;
            }
        }

        // Rendu du bulletin marine détaillé
        function renderMarineBulletin(bulletin) {
            if (!bulletin) return '<div class="panel-card"><p style="opacity:0.6;text-align:center;">Chargement du bulletin...</p></div>';

            return `
                <div class="marine-bulletin">
                    <div class="marine-bulletin-header">
                        <div class="marine-bulletin-title">
                            ⚓ Bulletin Marine - ${bulletin.zone}
                        </div>
                        <div class="zone-selector">
                            <select class="zone-select" id="marineZoneSelect" onchange="changeMarineZone(this.value)">
                                <optgroup label="Manche - Mer du Nord">
                                    ${marineRegions.manche.zones.map(z => `<option value="${z}" ${z === selectedMarineZone ? 'selected' : ''}>${marineZones[z].name}</option>`).join('')}
                                </optgroup>
                                <optgroup label="Atlantique">
                                    ${marineRegions.atlantique.zones.map(z => `<option value="${z}" ${z === selectedMarineZone ? 'selected' : ''}>${marineZones[z].name}</option>`).join('')}
                                </optgroup>
                                <optgroup label="Méditerranée">
                                    ${marineRegions.mediterranee.zones.map(z => `<option value="${z}" ${z === selectedMarineZone ? 'selected' : ''}>${marineZones[z].name}</option>`).join('')}
                                </optgroup>
                            </select>
                        </div>
                    </div>

                    <div class="marine-bulletin-meta">
                        <span>📅 ${bulletin.date}</span>
                        <span>🕐 ${bulletin.time}</span>
                        <span>📍 ${bulletin.region}</span>
                    </div>

                    ${bulletin.warning ? `
                        <div class="bulletin-warning ${bulletin.warning.level}">
                            <span class="bulletin-warning-icon">${bulletin.warning.level === 'danger' ? '🚨' : '⚠️'}</span>
                            <span class="bulletin-warning-text">${bulletin.warning.text}</span>
                        </div>
                    ` : ''}

                    <div class="bulletin-block">
                        <div class="bulletin-block-title">💨 Vent</div>
                        <div class="bulletin-block-content">
                            Secteur <strong>${bulletin.wind.direction}</strong> (${bulletin.wind.directionDeg}°),
                            force <strong>${bulletin.wind.beaufort}</strong> à <strong>${bulletin.wind.gustBeaufort}</strong> Beaufort.
                            <br>Vitesse ${Math.round(bulletin.wind.speed)} km/h, rafales jusqu'à <strong>${Math.round(bulletin.wind.gust)} km/h</strong>.
                        </div>
                    </div>

                    <div class="bulletin-block">
                        <div class="bulletin-block-title">🌊 État de la mer</div>
                        <div class="bulletin-block-content">
                            Mer <strong>${bulletin.sea.state.toLowerCase()}</strong> (${bulletin.sea.stateDesc.toLowerCase()}).
                            <br>Hauteur des vagues: <strong>${bulletin.sea.waveHeight.toFixed(1)} m</strong>, période ${Math.round(bulletin.sea.wavePeriod)} s.
                        </div>
                    </div>

                    ${bulletin.swell.height > 0.3 ? `
                        <div class="bulletin-block">
                            <div class="bulletin-block-title">〰️ Houle</div>
                            <div class="bulletin-block-content">
                                Houle de secteur <strong>${bulletin.swell.direction}</strong>,
                                hauteur <strong>${bulletin.swell.height.toFixed(1)} m</strong>,
                                période ${Math.round(bulletin.swell.period)} s.
                            </div>
                        </div>
                    ` : ''}

                    <div class="bulletin-block">
                        <div class="bulletin-block-title">👁️ Visibilité</div>
                        <div class="bulletin-block-content">
                            ${bulletin.visibility}. ${bulletin.precipitation ? 'Passages pluvieux ou averses.' : 'Temps sec.'}
                        </div>
                    </div>

                    <div class="bulletin-block">
                        <div class="bulletin-block-title">📊 Prévisions</div>
                        <div class="bulletin-forecast-grid">
                            ${bulletin.forecasts.map(f => `
                                <div class="bulletin-forecast-item">
                                    <div class="bulletin-forecast-period">${f.period}</div>
                                    <div class="bulletin-forecast-wind">${kmhToBeaufort(f.wind)} Bft</div>
                                    <div class="bulletin-forecast-sea">${f.wave.toFixed(1)}m</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        // Changer la zone marine et recharger le bulletin
        async function changeMarineZone(zoneKey) {
            selectedMarineZone = zoneKey;
            const bulletinContainer = document.getElementById('marineBulletinContainer');
            if (bulletinContainer) {
                bulletinContainer.innerHTML = '<div class="panel-card"><p style="opacity:0.6;text-align:center;">Chargement...</p></div>';
                const bulletin = await generateMarineBulletin(zoneKey);
                bulletinContainer.innerHTML = renderMarineBulletin(bulletin);
            }
        }

        // Conversions
        function convertWind(valueKmh, toUnit) {
            if (valueKmh === undefined || valueKmh === null) return 0;
            switch (toUnit) {
                case 'kt': return Math.round(valueKmh * 0.539957);
                case 'ms': return Math.round(valueKmh * 10 / 36 * 10) / 10;
                case 'bft': return kmhToBeaufort(valueKmh);
                default: return Math.round(valueKmh);
            }
        }

        function kmhToBeaufort(kmh) {
            const scales = [1, 6, 12, 20, 29, 39, 50, 62, 75, 89, 103, 118];
            for (let i = 0; i < scales.length; i++) {
                if (kmh < scales[i]) return i;
            }
            return 12;
        }

        function getWindUnitLabel() {
            return { kmh: 'km/h', kt: 'kt', ms: 'm/s', bft: 'Bft' }[state.units.wind];
        }

        function convertTemp(celsius) {
            if (celsius === undefined || celsius === null) return 0;
            return state.units.temp === 'fahrenheit' ? Math.round(celsius * 9 / 5 + 32) : Math.round(celsius);
        }

        function getTempUnit() {
            return state.units.temp === 'celsius' ? '°C' : '°F';
        }

        function convertWave(meters) {
            if (meters === undefined || meters === null) return 0;
            return state.units.wave === 'ft' ? Math.round(meters * 3.28084 * 10) / 10 : Math.round(meters * 10) / 10;
        }

        function getWaveUnit() {
            return state.units.wave === 'm' ? 'm' : 'ft';
        }

        function convertPressure(hpa) {
            if (hpa === undefined || hpa === null) return 0;
            return state.units.pressure === 'inhg' ? Math.round(hpa * 0.02953 * 100) / 100 : Math.round(hpa);
        }

        function getPressureUnit() {
            return state.units.pressure === 'hpa' ? 'hPa' : 'inHg';
        }

        function getWindDirection(deg) {
            if (deg === undefined || deg === null) return 'N';
            const dirs = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSO', 'SO', 'OSO', 'O', 'ONO', 'NO', 'NNO'];
            return dirs[Math.round(deg / 22.5) % 16];
        }

        function getSeaState(waveHeight) {
            for (let i = 0; i < seaStates.length; i++) {
                if (waveHeight <= seaStates[i].maxHeight) return i;
            }
            return 9;
        }

        function getWeatherIcon(code, isDay = true) {
            const weather = weatherCodes[code] || weatherCodes[0];
            if (!isDay && code <= 3) return code === 0 ? '🌙' : '☁️';
            return weather.icon;
        }

        function getWeatherDesc(code) {
            return (weatherCodes[code] || weatherCodes[0]).desc;
        }

        // Géocodage
        async function geocodeCity(query) {
            const response = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=5&language=fr&format=json`);
            const data = await response.json();
            if (data.results && data.results.length > 0) {
                const result = data.results[0];
                return {
                    name: result.name + (result.admin1 ? `, ${result.admin1}` : ''),
                    lat: result.latitude,
                    lon: result.longitude
                };
            }
            throw new Error('Ville non trouvée');
        }

        // DOM Elements
        const mainContent = document.getElementById('mainContent');
        const searchInput = document.getElementById('searchInput');
        const searchBtn = document.getElementById('searchBtn');
        const locationBtn = document.getElementById('locationBtn');
        const addFavoriteBtn = document.getElementById('addFavoriteBtn');
        const weatherModeBtn = document.getElementById('weatherModeBtn');
        const marineModeBtn = document.getElementById('marineModeBtn');
        const logoIcon = document.getElementById('logoIcon');
        const locationText = document.getElementById('locationText');
        const modelSelect = document.getElementById('modelSelect');
        const waveUnitGroup = document.getElementById('waveUnitGroup');
        const favoritesRow = document.getElementById('favoritesRow');
        const apiStatus = document.getElementById('apiStatus');
        const apiStatusText = document.getElementById('apiStatusText');
        const addFavoriteModal = document.getElementById('addFavoriteModal');
        const addFavoriteForm = document.getElementById('addFavoriteForm');
        const closeModal = document.getElementById('closeModal');

        // Initialisation
        document.addEventListener('DOMContentLoaded', () => {
            loadFavorites();
            setupEventListeners();
            initGeolocation();
        });

        function setupEventListeners() {
            searchBtn.addEventListener('click', handleSearch);
            searchInput.addEventListener('keypress', e => e.key === 'Enter' && handleSearch());
            locationBtn.addEventListener('click', initGeolocation);

            weatherModeBtn.addEventListener('click', () => setMode('weather'));
            marineModeBtn.addEventListener('click', () => setMode('marine'));

            modelSelect.addEventListener('change', e => {
                state.model = e.target.value;
                if (state.currentCoords) {
                    loadWeatherForCoords(state.currentCoords.lat, state.currentCoords.lon, state.currentCity);
                }
            });

            // Unit selectors
            document.querySelectorAll('.unit-selector').forEach(selector => {
                selector.querySelectorAll('.unit-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        selector.querySelectorAll('.unit-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        const unitType = selector.id.replace('UnitSelector', '');
                        state.units[unitType] = btn.dataset.unit;
                        renderCurrentView();
                    });
                });
            });

            // Favorites
            favoritesRow.addEventListener('click', e => {
                const deleteBtn = e.target.closest('.delete-fav');
                if (deleteBtn) {
                    e.stopPropagation();
                    const index = parseInt(deleteBtn.dataset.delete);
                    state.favorites.splice(index, 1);
                    saveFavorites();
                    renderFavorites();
                    return;
                }

                const chip = e.target.closest('.favorite-chip');
                if (chip) {
                    document.querySelectorAll('.favorite-chip').forEach(c => c.classList.remove('active'));
                    chip.classList.add('active');
                    const lat = parseFloat(chip.dataset.lat);
                    const lon = parseFloat(chip.dataset.lon);
                    const name = chip.dataset.name;
                    const isPort = chip.dataset.port === 'true';
                    state.currentIsPort = isPort;
                    loadWeatherForCoords(lat, lon, name);
                }
            });

            // Modal favoris
            addFavoriteBtn.addEventListener('click', () => {
                if (state.currentCoords) {
                    document.getElementById('favLat').value = state.currentCoords.lat.toFixed(4);
                    document.getElementById('favLon').value = state.currentCoords.lon.toFixed(4);
                    document.getElementById('favName').value = state.currentCity || '';
                }
                addFavoriteModal.classList.add('active');
            });

            closeModal.addEventListener('click', () => {
                addFavoriteModal.classList.remove('active');
            });

            addFavoriteModal.addEventListener('click', e => {
                if (e.target === addFavoriteModal) {
                    addFavoriteModal.classList.remove('active');
                }
            });

            addFavoriteForm.addEventListener('submit', e => {
                e.preventDefault();
                const newFav = {
                    name: document.getElementById('favName').value,
                    lat: parseFloat(document.getElementById('favLat').value),
                    lon: parseFloat(document.getElementById('favLon').value),
                    emoji: document.getElementById('favEmoji').value || '📍',
                    isPort: document.getElementById('favIsPort').checked,
                    isCoastal: document.getElementById('favIsCoastal').checked
                };
                state.favorites.push(newFav);
                saveFavorites();
                renderFavorites();
                addFavoriteModal.classList.remove('active');
                addFavoriteForm.reset();
            });
        }

        function initGeolocation() {
            showLoading('Géolocalisation en cours...');

            // Vérifier si on est en HTTPS ou localhost (requis pour géolocalisation)
            const isSecure = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1' || location.protocol === 'file:';

            if (!isSecure) {
                console.warn('Géolocalisation requiert HTTPS. Utilisation de Paris par défaut.');
                showLoading('Chargement de Paris (géolocalisation requiert HTTPS)...');
                loadWeatherForCoords(48.8566, 2.3522, 'Paris');
                return;
            }

            if (navigator.geolocation) {
                // Timeout de secours si la géolocalisation prend trop de temps
                const fallbackTimeout = setTimeout(() => {
                    console.warn('Géolocalisation timeout - utilisation de Paris');
                    loadWeatherForCoords(48.8566, 2.3522, 'Paris');
                }, 8000);

                navigator.geolocation.getCurrentPosition(
                    position => {
                        clearTimeout(fallbackTimeout);
                        const { latitude, longitude } = position.coords;
                        console.log('Position obtenue:', latitude, longitude);
                        loadWeatherForCoords(latitude, longitude, 'Ma position');
                        document.getElementById('locationBadge').classList.add('live');
                    },
                    error => {
                        clearTimeout(fallbackTimeout);
                        let errorMsg = 'Erreur inconnue';
                        switch(error.code) {
                            case error.PERMISSION_DENIED:
                                errorMsg = 'Permission refusée';
                                break;
                            case error.POSITION_UNAVAILABLE:
                                errorMsg = 'Position indisponible';
                                break;
                            case error.TIMEOUT:
                                errorMsg = 'Timeout';
                                break;
                        }
                        console.warn('Géolocalisation échouée:', errorMsg, error);
                        showLoading(`Géolocalisation échouée (${errorMsg}). Chargement de Paris...`);
                        loadWeatherForCoords(48.8566, 2.3522, 'Paris');
                    },
                    {
                        timeout: 7000,
                        enableHighAccuracy: false,  // Plus rapide avec false
                        maximumAge: 300000  // Accepter une position de moins de 5 minutes
                    }
                );
            } else {
                console.warn('Géolocalisation non supportée');
                loadWeatherForCoords(48.8566, 2.3522, 'Paris');
            }
        }

        async function loadWeatherForCoords(lat, lon, cityName) {
            showLoading(`Chargement des données ${models[state.model].name}...`);

            try {
                state.currentCoords = { lat, lon };
                state.currentCity = cityName;
                locationText.textContent = cityName;

                const weatherData = await fetchWeatherData(lat, lon, state.model);
                state.weatherData = weatherData;
                state.lastUpdate = new Date();

                try {
                    const marineData = await fetchMarineData(lat, lon);
                    state.marineData = marineData;
                } catch (e) {
                    state.marineData = null;
                }

                state.tidesData = generateTidesData(lat, lon);

                apiStatus.classList.remove('error');
                apiStatusText.textContent = `API Live - ${models[state.model].name}`;
                state.apiError = false;

                renderCurrentView();

            } catch (error) {
                console.error('Erreur API:', error);
                state.apiError = true;
                apiStatus.classList.add('error');
                apiStatusText.textContent = 'Erreur API';
                showError('Impossible de charger les données météo.');
            }
        }

        async function handleSearch() {
            const query = searchInput.value.trim();
            if (query) {
                showLoading(`Recherche de "${query}"...`);
                try {
                    const location = await geocodeCity(query);
                    document.querySelectorAll('.favorite-chip').forEach(c => c.classList.remove('active'));
                    document.getElementById('locationBadge').classList.remove('live');
                    loadWeatherForCoords(location.lat, location.lon, location.name);
                    searchInput.value = '';
                } catch (error) {
                    showError(`Ville "${query}" non trouvée`);
                }
            }
        }

        function setMode(mode) {
            state.mode = mode;
            weatherModeBtn.classList.toggle('active', mode === 'weather');
            marineModeBtn.classList.toggle('active', mode === 'marine');
            logoIcon.textContent = mode === 'marine' ? '⚓' : '🌊';
            waveUnitGroup.style.display = mode === 'marine' ? 'block' : 'none';
            renderCurrentView();
        }

        function showLoading(text = 'Chargement...') {
            state.isLoading = true;
            mainContent.innerHTML = `
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <p class="loading-text">${text}</p>
                </div>
            `;
        }

        function showError(message) {
            mainContent.innerHTML = `
                <div class="error-message">
                    <div class="icon">⚠️</div>
                    <div class="text">${message}</div>
                    <button class="retry-btn" onclick="initGeolocation()">Réessayer</button>
                </div>
            `;
        }

        function renderCurrentView() {
            if (!state.weatherData) return;
            state.isLoading = false;

            if (state.mode === 'marine') {
                if (state.marineData) {
                    renderMarine();
                } else {
                    mainContent.innerHTML = `
                        <div class="error-message">
                            <div class="icon">🌊</div>
                            <div class="text">Données marines non disponibles pour cette position.<br>Essayez une ville côtière.</div>
                        </div>
                    `;
                }
            } else {
                renderWeather();
            }
        }

        // Rendu du graphique vent/rafales
        function renderWindChart(hourlyWind, hourlyGust, hours = 24) {
            const windData = hourlyWind.slice(0, hours);
            const gustData = hourlyGust.slice(0, hours);

            const maxValue = Math.max(...gustData, ...windData) + 10;
            const minValue = 0;

            const windPoints = windData.map((v, i) => {
                const x = 5 + (i / (windData.length - 1)) * 90;
                const y = 95 - ((v - minValue) / (maxValue - minValue)) * 85;
                return `${x},${y}`;
            }).join(' ');

            const gustPoints = gustData.map((v, i) => {
                const x = 5 + (i / (gustData.length - 1)) * 90;
                const y = 95 - ((v - minValue) / (maxValue - minValue)) * 85;
                return `${x},${y}`;
            }).join(' ');

            const windAreaPoints = `5,95 ${windPoints} 95,95`;

            const timeLabels = ['Maintenant', '+6h', '+12h', '+18h', '+24h'];
            if (hours > 24) {
                timeLabels[4] = '+48h';
            }

            return `
                <div class="wind-chart-container">
                    <div class="wind-chart-header">
                        <div class="wind-chart-title">📊 Vent & Rafales (${hours}h)</div>
                        <div class="wind-chart-legend">
                            <div class="legend-item">
                                <span class="legend-dot wind"></span>
                                <span>Vent moyen</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-dot gust"></span>
                                <span>Rafales</span>
                            </div>
                        </div>
                    </div>
                    <div class="wind-chart">
                        <svg viewBox="0 0 100 100" preserveAspectRatio="none">
                            <defs>
                                <linearGradient id="windGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" style="stop-color:rgba(0,180,216,0.4)"/>
                                    <stop offset="100%" style="stop-color:rgba(0,180,216,0.05)"/>
                                </linearGradient>
                                <linearGradient id="gustGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" style="stop-color:rgba(255,107,53,0.2)"/>
                                    <stop offset="100%" style="stop-color:rgba(255,107,53,0.02)"/>
                                </linearGradient>
                            </defs>
                            <!-- Grid -->
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="25" x2="95" y2="25"/>
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="50" x2="95" y2="50"/>
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="75" x2="95" y2="75"/>
                            <!-- Wind area -->
                            <polygon class="wind-area" points="${windAreaPoints}"/>
                            <!-- Gust line -->
                            <polyline class="wind-line gust" points="${gustPoints}"/>
                            <!-- Wind line -->
                            <polyline class="wind-line main" points="${windPoints}"/>
                            <!-- Scale labels -->
                            <text x="2" y="12" fill="rgba(255,255,255,0.4)" font-size="6">${Math.round(maxValue)} ${getWindUnitLabel()}</text>
                            <text x="2" y="52" fill="rgba(255,255,255,0.4)" font-size="6">${Math.round(maxValue/2)}</text>
                            <text x="2" y="95" fill="rgba(255,255,255,0.4)" font-size="6">0</text>
                        </svg>
                    </div>
                    <div class="wind-chart-labels">
                        ${timeLabels.map(l => `<span>${l}</span>`).join('')}
                    </div>
                </div>
            `;
        }

        // Rendu du graphique de houle
        function renderWaveChart(hourlyWaveHeight, hours = 24) {
            const waveData = hourlyWaveHeight?.slice(0, hours) || [];
            if (waveData.length === 0) return '';

            const maxValue = Math.max(...waveData) + 0.5;
            const minValue = 0;

            const points = waveData.map((v, i) => {
                const x = 5 + (i / (waveData.length - 1)) * 90;
                const y = 95 - ((v - minValue) / (maxValue - minValue)) * 85;
                return `${x},${y}`;
            }).join(' ');

            const areaPoints = `5,95 ${points} 95,95`;

            return `
                <div class="wave-chart-container">
                    <div class="wind-chart-header">
                        <div class="wind-chart-title">🌊 Hauteur des vagues (${hours}h)</div>
                    </div>
                    <div class="wave-chart">
                        <svg viewBox="0 0 100 100" preserveAspectRatio="none">
                            <defs>
                                <linearGradient id="waveGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" style="stop-color:rgba(155,89,182,0.5)"/>
                                    <stop offset="100%" style="stop-color:rgba(155,89,182,0.05)"/>
                                </linearGradient>
                            </defs>
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="25" x2="95" y2="25"/>
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="50" x2="95" y2="50"/>
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="75" x2="95" y2="75"/>
                            <polygon class="wave-area-fill" points="${areaPoints}"/>
                            <polyline class="wave-line-chart" points="${points}"/>
                            <text x="2" y="12" fill="rgba(255,255,255,0.4)" font-size="6">${maxValue.toFixed(1)}${getWaveUnit()}</text>
                            <text x="2" y="52" fill="rgba(255,255,255,0.4)" font-size="6">${(maxValue/2).toFixed(1)}</text>
                            <text x="2" y="95" fill="rgba(255,255,255,0.4)" font-size="6">0</text>
                        </svg>
                    </div>
                    <div class="wind-chart-labels">
                        <span>Maintenant</span>
                        <span>+6h</span>
                        <span>+12h</span>
                        <span>+18h</span>
                        <span>+24h</span>
                    </div>
                </div>
            `;
        }

        // Rendu de la courbe de marée
        function renderTideCurve(tidesData) {
            if (!tidesData) return '';

            const now = new Date();
            const startOfDay = new Date(now);
            startOfDay.setHours(0, 0, 0, 0);

            // Générer une courbe sinusoïdale pour 24h
            const points = [];
            const baseHeight = tidesData.currentHeight;
            const amplitude = tidesData.range / 2;

            for (let i = 0; i <= 24; i++) {
                const hour = i;
                const phase = (hour / 12.4) * Math.PI * 2; // période de marée ~12.4h
                const height = baseHeight + Math.sin(phase - Math.PI/2) * amplitude;
                const x = 5 + (i / 24) * 90;
                const y = 90 - ((height / (baseHeight + amplitude + 1)) * 80);
                points.push(`${x},${y}`);
            }

            const pathPoints = points.join(' ');
            const areaPoints = `5,95 ${pathPoints} 95,95`;

            // Position actuelle sur la courbe
            const currentHour = now.getHours() + now.getMinutes() / 60;
            const nowX = 5 + (currentHour / 24) * 90;
            const nowPhase = (currentHour / 12.4) * Math.PI * 2;
            const nowHeight = baseHeight + Math.sin(nowPhase - Math.PI/2) * amplitude;
            const nowY = 90 - ((nowHeight / (baseHeight + amplitude + 1)) * 80);

            return `
                <div class="tide-curve-container">
                    <div class="tide-curve-header">
                        <div class="wind-chart-title">📈 Courbe de marée (24h)</div>
                        <div style="font-size:0.75rem;color:rgba(255,255,255,0.6)">Coef. ${tidesData.coefficient}</div>
                    </div>
                    <div class="tide-curve-chart">
                        <svg viewBox="0 0 100 100" preserveAspectRatio="none">
                            <defs>
                                <linearGradient id="tideGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" style="stop-color:rgba(0,119,182,0.5)"/>
                                    <stop offset="100%" style="stop-color:rgba(0,119,182,0.05)"/>
                                </linearGradient>
                            </defs>
                            <!-- Grid -->
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="30" x2="95" y2="30"/>
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="60" x2="95" y2="60"/>
                            <!-- Area fill -->
                            <polygon class="tide-area-fill" points="${areaPoints}"/>
                            <!-- Curve -->
                            <polyline class="tide-curve-path" points="${pathPoints}"/>
                            <!-- Now marker -->
                            <line x1="${nowX}" y1="5" x2="${nowX}" y2="95" stroke="var(--accent-orange)" stroke-width="1" stroke-dasharray="3 2"/>
                            <circle class="tide-now-marker" cx="${nowX}" cy="${nowY}" r="4"/>
                            <!-- Height labels -->
                            <text x="2" y="15" fill="rgba(255,255,255,0.4)" font-size="5">${(baseHeight + amplitude).toFixed(1)}m</text>
                            <text x="2" y="85" fill="rgba(255,255,255,0.4)" font-size="5">${(baseHeight - amplitude).toFixed(1)}m</text>
                        </svg>
                    </div>
                    <div class="tide-labels">
                        <span>00h</span>
                        <span>06h</span>
                        <span>12h</span>
                        <span>18h</span>
                        <span>24h</span>
                    </div>
                    <div style="text-align:center;margin-top:10px;font-size:0.85rem;">
                        <span style="color:var(--accent-orange);font-weight:600;">${tidesData.currentHeight}m</span>
                        <span style="opacity:0.6;"> niveau actuel</span>
                    </div>
                </div>
            `;
        }

        // Rendu du radar de pluie
        function renderRainRadar(lat, lon) {
            return `
                <div class="radar-container">
                    <div class="radar-header">
                        <div class="radar-title">🌧️ Radar de pluie</div>
                        <div class="radar-live">
                            <span class="pulse"></span>
                            <span>Live</span>
                        </div>
                    </div>
                    <div class="radar-map">
                        <div id="radarMap"></div>
                    </div>
                    <div class="radar-controls">
                        <button class="radar-btn" onclick="playRadar()">▶️</button>
                        <div class="radar-timeline">
                            <div class="radar-timeline-progress" id="radarProgress" style="width: 100%"></div>
                        </div>
                        <span class="radar-time-label" id="radarTimeLabel">Maintenant</span>
                    </div>
                    <div class="radar-legend">
                        <div class="radar-legend-item">
                            <span class="radar-legend-color" style="background: #88ddff"></span>
                            <span>Légère</span>
                        </div>
                        <div class="radar-legend-item">
                            <span class="radar-legend-color" style="background: #00bb00"></span>
                            <span>Modérée</span>
                        </div>
                        <div class="radar-legend-item">
                            <span class="radar-legend-color" style="background: #ffff00"></span>
                            <span>Forte</span>
                        </div>
                        <div class="radar-legend-item">
                            <span class="radar-legend-color" style="background: #ff8800"></span>
                            <span>Intense</span>
                        </div>
                        <div class="radar-legend-item">
                            <span class="radar-legend-color" style="background: #ff0000"></span>
                            <span>Très intense</span>
                        </div>
                    </div>
                </div>
            `;
        }

        // État et fonctions du radar
        let radarMap = null;
        let radarLayer = null;
        let radarFrames = [];
        let currentRadarFrame = 0;
        let radarPlaying = false;
        let radarInterval = null;

        async function initRadar(lat, lon) {
            // Charger Leaflet si pas déjà chargé
            if (!window.L) {
                const leafletCSS = document.createElement('link');
                leafletCSS.rel = 'stylesheet';
                leafletCSS.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
                document.head.appendChild(leafletCSS);

                await new Promise((resolve) => {
                    const script = document.createElement('script');
                    script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
                    script.onload = resolve;
                    document.head.appendChild(script);
                });
            }

            // Attendre que le DOM soit prêt
            await new Promise(r => setTimeout(r, 100));

            const mapContainer = document.getElementById('radarMap');
            if (!mapContainer) return;

            // Initialiser la carte
            if (radarMap) {
                radarMap.remove();
            }

            radarMap = L.map('radarMap', {
                zoomControl: false,
                attributionControl: false
            }).setView([lat, lon], 8);

            // Fond de carte sombre
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                maxZoom: 19
            }).addTo(radarMap);

            // Marqueur position
            L.circleMarker([lat, lon], {
                radius: 6,
                fillColor: '#ff6b35',
                color: '#fff',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.8
            }).addTo(radarMap);

            // Charger les données RainViewer
            try {
                const response = await fetch('https://api.rainviewer.com/public/weather-maps.json');
                const data = await response.json();

                radarFrames = data.radar.past.concat(data.radar.nowcast || []);
                currentRadarFrame = radarFrames.length - 1;

                updateRadarFrame();
            } catch (e) {
                console.error('Erreur RainViewer:', e);
            }
        }

        function updateRadarFrame() {
            if (!radarMap || radarFrames.length === 0) return;

            const frame = radarFrames[currentRadarFrame];
            const tileUrl = `https://tilecache.rainviewer.com${frame.path}/256/{z}/{x}/{y}/4/1_1.png`;

            if (radarLayer) {
                radarMap.removeLayer(radarLayer);
            }

            radarLayer = L.tileLayer(tileUrl, {
                opacity: 0.7,
                zIndex: 1000
            }).addTo(radarMap);

            // Mettre à jour le label
            const time = new Date(frame.time * 1000);
            const now = new Date();
            const diffMinutes = Math.round((time - now) / 60000);

            const label = document.getElementById('radarTimeLabel');
            if (label) {
                if (diffMinutes === 0) {
                    label.textContent = 'Maintenant';
                } else if (diffMinutes > 0) {
                    label.textContent = `+${diffMinutes} min`;
                } else {
                    label.textContent = `${diffMinutes} min`;
                }
            }

            // Mettre à jour la barre de progression
            const progress = document.getElementById('radarProgress');
            if (progress) {
                progress.style.width = `${((currentRadarFrame + 1) / radarFrames.length) * 100}%`;
            }
        }

        function playRadar() {
            if (radarPlaying) {
                radarPlaying = false;
                clearInterval(radarInterval);
                return;
            }

            radarPlaying = true;
            currentRadarFrame = 0;

            radarInterval = setInterval(() => {
                currentRadarFrame = (currentRadarFrame + 1) % radarFrames.length;
                updateRadarFrame();

                if (currentRadarFrame === radarFrames.length - 1) {
                    setTimeout(() => {
                        if (radarPlaying) {
                            currentRadarFrame = 0;
                        }
                    }, 2000);
                }
            }, 500);
        }

        // Rendu de la rose des vents SVG
        // Widget vent compact style Windy
        // Wind particles animation state
        let windParticlesAnimation = null;
        let windParticles = [];

        function renderWindWidget(windSpeed, windGust, windDir) {
            const beaufort = kmhToBeaufort(windSpeed);
            const gustBeaufort = kmhToBeaufort(windGust);
            const dirText = getWindDirection(windDir);

            // Générer les segments Beaufort (points)
            let bfDots = '';
            for (let i = 0; i < 12; i++) {
                let cls = 'bf-seg';
                if (i < beaufort) cls += ' active';
                else if (i < gustBeaufort) cls += ' gust';
                bfDots += `<div class="${cls}"></div>`;
            }

            // ID unique pour le canvas
            const canvasId = 'windCanvas' + Date.now();

            // Stocker les données pour l'animation
            window.currentWindData = { speed: windSpeed, gust: windGust, dir: windDir };

            return `
                <div class="wind-particles-container">
                    <canvas id="${canvasId}" class="wind-particles-canvas"></canvas>
                    <div class="wind-particles-overlay">
                        <div class="wind-data-box">
                            <div class="wind-data-speed">
                                ${convertWind(windSpeed, state.units.wind)}<span class="unit">${getWindUnitLabel()}</span>
                            </div>
                            <div class="wind-data-dir">${dirText} (${Math.round(windDir)}°)</div>
                            <div class="wind-data-beaufort">${bfDots}</div>
                        </div>
                        <div class="wind-gust-box">
                            <div class="wind-gust-val">${convertWind(windGust, state.units.wind)}</div>
                            <div class="wind-gust-lbl">Rafales</div>
                        </div>
                    </div>
                    <div class="wind-compass-overlay">
                        <svg viewBox="0 0 55 55">
                            <circle cx="27.5" cy="27.5" r="25" fill="rgba(0,0,0,0.5)" stroke="rgba(255,255,255,0.2)" stroke-width="1"/>
                            <text x="27.5" y="9" fill="rgba(255,255,255,0.7)" font-size="7" text-anchor="middle" font-weight="bold">N</text>
                            <text x="27.5" y="51" fill="rgba(255,255,255,0.4)" font-size="6" text-anchor="middle">S</text>
                            <text x="49" y="30" fill="rgba(255,255,255,0.4)" font-size="6" text-anchor="middle">E</text>
                            <text x="6" y="30" fill="rgba(255,255,255,0.4)" font-size="6" text-anchor="middle">O</text>
                            <g transform="rotate(${windDir}, 27.5, 27.5)">
                                <path d="M27.5,8 L24,20 L27.5,17 L31,20 Z" fill="#4fc3f7"/>
                                <line x1="27.5" y1="17" x2="27.5" y2="40" stroke="#4fc3f7" stroke-width="2"/>
                            </g>
                            <circle cx="27.5" cy="27.5" r="3" fill="white"/>
                        </svg>
                    </div>
                </div>
            `;
        }

        // Initialiser l'animation des particules de vent
        function initWindParticles(canvasId) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * 2;
            canvas.height = rect.height * 2;
            ctx.scale(2, 2);

            const width = rect.width;
            const height = rect.height;

            // Récupérer les données de vent
            const windData = window.currentWindData || { speed: 0, gust: 0, dir: 270 };
            const windSpeed = windData.speed || 0;
            const gustSpeed = windData.gust || 0;

            // Si pas de vent (< 2 km/h), afficher un canvas calme sans animation
            if (windSpeed < 2) {
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.font = '14px -apple-system, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Vent calme', width / 2, height / 2);
                return;
            }

            const windRad = (windData.dir - 90) * Math.PI / 180;
            const normalizedSpeed = Math.min(windSpeed / 10, 4); // Vitesse plus douce

            // Créer les particules réparties sur toute la surface
            const particleCount = Math.min(60 + Math.floor(windSpeed), 150);
            windParticles = [];

            for (let i = 0; i < particleCount; i++) {
                const isGust = gustSpeed > windSpeed * 1.2 && Math.random() < 0.2;
                windParticles.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    length: 15 + Math.random() * 25,
                    speed: 0.3 + Math.random() * normalizedSpeed,
                    opacity: 0.4 + Math.random() * 0.4,
                    isGust: isGust,
                    // Décalage de phase pour que les particules ne soient pas synchronisées
                    phase: Math.random() * Math.PI * 2
                });
            }

            if (windParticlesAnimation) {
                cancelAnimationFrame(windParticlesAnimation);
            }

            function animate() {
                if (!document.getElementById(canvasId)) {
                    cancelAnimationFrame(windParticlesAnimation);
                    return;
                }

                ctx.clearRect(0, 0, width, height);

                windParticles.forEach(p => {
                    const endX = p.x + Math.cos(windRad) * p.length;
                    const endY = p.y + Math.sin(windRad) * p.length;

                    // Dessiner le vecteur/particule
                    if (p.isGust) {
                        ctx.strokeStyle = `rgba(255, 112, 67, ${p.opacity})`;
                        ctx.lineWidth = 2;
                    } else {
                        ctx.strokeStyle = `rgba(79, 195, 247, ${p.opacity})`;
                        ctx.lineWidth = 1.5;
                    }

                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(endX, endY);
                    ctx.lineCap = 'round';
                    ctx.stroke();

                    // Petite pointe de flèche
                    const arrowSize = 4;
                    const arrowAngle = Math.PI / 6;
                    ctx.beginPath();
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(
                        endX - arrowSize * Math.cos(windRad - arrowAngle),
                        endY - arrowSize * Math.sin(windRad - arrowAngle)
                    );
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(
                        endX - arrowSize * Math.cos(windRad + arrowAngle),
                        endY - arrowSize * Math.sin(windRad + arrowAngle)
                    );
                    ctx.stroke();

                    // Déplacer la particule
                    p.x += Math.cos(windRad) * p.speed;
                    p.y += Math.sin(windRad) * p.speed;

                    // Wrap around - réapparaître de l'autre côté avec position Y aléatoire
                    const margin = 50;
                    if (p.x > width + margin) {
                        p.x = -margin;
                        p.y = Math.random() * height;
                    } else if (p.x < -margin) {
                        p.x = width + margin;
                        p.y = Math.random() * height;
                    }
                    if (p.y > height + margin) {
                        p.y = -margin;
                        p.x = Math.random() * width;
                    } else if (p.y < -margin) {
                        p.y = height + margin;
                        p.x = Math.random() * width;
                    }
                });

                windParticlesAnimation = requestAnimationFrame(animate);
            }

            animate();
        }

        // Observer pour initialiser le canvas quand il apparaît
        function setupWindParticlesObserver() {
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1) {
                            const canvas = node.querySelector?.('.wind-particles-canvas') ||
                                          (node.classList?.contains('wind-particles-canvas') ? node : null);
                            if (canvas && canvas.id) {
                                setTimeout(() => initWindParticles(canvas.id), 100);
                            }
                        }
                    });
                });
            });

            observer.observe(document.body, { childList: true, subtree: true });
        }

        // Initialiser l'observer au chargement
        document.addEventListener('DOMContentLoaded', setupWindParticlesObserver);

        // Prédiction de pluie par tranches
        function renderRainForecast(hourlyPrecip, hourlyWeatherCode) {
            // Tranches: 10min, 30min, 1h, 2h, 5h
            const slots = [
                { label: '10\'', index: 0 },
                { label: '30\'', index: 0 },
                { label: '1h', index: 1 },
                { label: '2h', index: 2 },
                { label: '5h', index: 5 }
            ];

            // Calculer les précipitations pour chaque tranche
            const rainData = slots.map((slot, i) => {
                const precip = hourlyPrecip[slot.index] || 0;
                const code = hourlyWeatherCode[slot.index] || 0;

                // Pour 10min et 30min, interpoler depuis l'heure actuelle
                let amount = precip;
                if (i === 0) amount = precip * 0.17; // ~10min
                if (i === 1) amount = precip * 0.5;  // ~30min

                let level = 'none';
                let icon = '☀️';

                if (amount > 0 && amount < 0.5) { level = 'light'; icon = '🌦️'; }
                else if (amount >= 0.5 && amount < 2) { level = 'moderate'; icon = '🌧️'; }
                else if (amount >= 2) { level = 'heavy'; icon = '⛈️'; }
                else if (code >= 51 && code <= 67) { level = 'light'; icon = '🌧️'; }
                else if (code >= 80 && code <= 82) { level = 'moderate'; icon = '🌧️'; }
                else if (code >= 95) { level = 'heavy'; icon = '⛈️'; }

                return { ...slot, amount, level, icon };
            });

            // Déterminer le statut global
            const maxLevel = rainData.reduce((max, r) => {
                if (r.level === 'heavy') return 'heavy';
                if (r.level === 'moderate' && max !== 'heavy') return 'moderate';
                if (r.level === 'light' && max === 'none') return 'light';
                return max;
            }, 'none');

            const statusText = {
                none: 'Pas de pluie',
                light: 'Pluie légère',
                moderate: 'Pluie modérée',
                heavy: 'Fortes pluies'
            };

            // Mini bar pour les 60 prochaines minutes (6 segments de 10min)
            const miniBar = [];
            for (let i = 0; i < 6; i++) {
                const p = (hourlyPrecip[0] || 0) * (1 - i * 0.1);
                let lvl = 0;
                if (p > 0 && p < 0.3) lvl = 1;
                else if (p >= 0.3 && p < 1) lvl = 2;
                else if (p >= 1 && p < 2) lvl = 3;
                else if (p >= 2 && p < 5) lvl = 4;
                else if (p >= 5) lvl = 5;
                miniBar.push(lvl);
            }

            return `
                <div class="rain-forecast">
                    <div class="rain-forecast-header">
                        <div class="rain-forecast-title">🌧️ Prévision pluie</div>
                        <div class="rain-status ${maxLevel === 'none' ? 'dry' : maxLevel}">${statusText[maxLevel]}</div>
                    </div>
                    <div class="rain-timeline">
                        ${rainData.map(r => `
                            <div class="rain-slot ${r.level !== 'none' ? (r.level === 'heavy' ? 'heavy-rain' : 'has-rain') : ''}">
                                <div class="rain-slot-time">${r.label}</div>
                                <div class="rain-slot-icon">${r.icon}</div>
                                <div class="rain-slot-amount ${r.level}">${r.amount > 0 ? r.amount.toFixed(1) + 'mm' : '-'}</div>
                            </div>
                        `).join('')}
                    </div>
                    <div class="rain-mini-bar">
                        ${miniBar.map(lvl => `<div class="rain-mini-segment ${lvl > 0 ? 'level-' + lvl : ''}"></div>`).join('')}
                    </div>
                </div>
            `;
        }

        // Rendu de l'indicateur de houle compact
        function renderSwellIndicator(swellHeight, swellDir, swellPeriod) {
            return `
                <div class="swell-indicator">
                    <div class="swell-compass" style="width:60px;height:60px;">
                        <svg viewBox="0 0 60 60">
                            <circle cx="30" cy="30" r="26" fill="rgba(0,0,0,0.3)" stroke="rgba(155,89,182,0.3)" stroke-width="1"/>
                            <text x="30" y="9" fill="rgba(255,255,255,0.5)" font-size="6" text-anchor="middle">N</text>
                            <text x="30" y="56" fill="rgba(255,255,255,0.4)" font-size="5" text-anchor="middle">S</text>
                            <text x="54" y="32" fill="rgba(255,255,255,0.4)" font-size="5" text-anchor="middle">E</text>
                            <text x="6" y="32" fill="rgba(255,255,255,0.4)" font-size="5" text-anchor="middle">O</text>
                            <g transform="rotate(${swellDir}, 30, 30)">
                                <path d="M30,10 L27,22 L30,19 L33,22 Z" fill="var(--accent-purple)"/>
                                <line x1="30" y1="19" x2="30" y2="42" stroke="var(--accent-purple)" stroke-width="2"/>
                            </g>
                        </svg>
                    </div>
                    <div class="swell-info" style="flex:1;">
                        <div class="swell-title" style="font-size:0.8rem;margin-bottom:6px;">🌊 Houle</div>
                        <div class="swell-details" style="gap:15px;">
                            <div class="swell-detail">
                                <div class="value" style="font-size:1.1rem;">${getWindDirection(swellDir)}</div>
                                <div class="label">Dir.</div>
                            </div>
                            <div class="swell-detail">
                                <div class="value" style="font-size:1.1rem;">${convertWave(swellHeight)}${getWaveUnit()}</div>
                                <div class="label">Haut.</div>
                            </div>
                            <div class="swell-detail">
                                <div class="value" style="font-size:1.1rem;">${Math.round(swellPeriod || 0)}s</div>
                                <div class="label">Période</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Rendu des marées
        function renderTides(tidesData) {
            if (!tidesData) return '';

            const now = new Date();
            const nextTides = tidesData.tides.filter(t => t.time > now).slice(0, 2);

            return `
                <div class="tides-container">
                    <div class="tides-header">
                        <div class="tides-title">🌊 Marées</div>
                        <div class="tides-coefficient">Coef. ${tidesData.coefficient}</div>
                    </div>
                    <div style="text-align:center;margin-bottom:15px;">
                        <span style="font-size:1.5rem;font-weight:600;">${tidesData.currentHeight}m</span>
                        <span style="font-size:0.8rem;opacity:0.7;"> niveau actuel</span>
                    </div>
                    <div class="tides-times">
                        ${nextTides.map(tide => `
                            <div class="tide-time">
                                <div class="tide-icon">${tide.type === 'high' ? '⬆️' : '⬇️'}</div>
                                <div class="tide-info">
                                    <div class="time">${tide.time.toLocaleTimeString('fr-FR', {hour: '2-digit', minute: '2-digit'})}</div>
                                    <div class="height">${tide.height.toFixed(1)}m</div>
                                    <div class="label">${tide.type === 'high' ? 'Pleine mer' : 'Basse mer'}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    <div style="margin-top:10px;font-size:0.75rem;opacity:0.6;text-align:center;">
                        Marnage: ${tidesData.range.toFixed(1)}m
                    </div>
                </div>
            `;
        }

        // Rendu des infos port
        function renderPortInfo(cityName) {
            const port = portsInfo[cityName];
            if (!port) return '';

            return `
                <div class="port-info">
                    <div class="port-header">
                        <div class="port-title">⚓ ${port.harbor}</div>
                    </div>
                    <div class="port-grid">
                        <div class="port-item">
                            <div class="value">VHF ${port.vhf}</div>
                            <div class="label">Canal radio</div>
                        </div>
                        <div class="port-item">
                            <div class="value">${port.tidalRange}</div>
                            <div class="label">Marnage</div>
                        </div>
                    </div>
                    <div style="margin-top:12px;font-size:0.75rem;">
                        <strong>Services:</strong> ${port.facilities.join(' • ')}
                    </div>
                </div>
            `;
        }

        // Rendu du bulletin côtier
        function renderBulletin(bulletin) {
            if (!bulletin) return '';

            return `
                <div class="bulletin-container">
                    <div class="bulletin-header">
                        <div class="bulletin-title">📋 Bulletin Côtier</div>
                        <div class="bulletin-zone">${bulletin.zone}</div>
                    </div>
                    <div class="bulletin-date">${bulletin.date} - ${bulletin.time}</div>
                    <div class="bulletin-content">
                        ${bulletin.sections.map(section => `
                            <div class="bulletin-section">
                                <div class="bulletin-section-title">${section.title}</div>
                                <div class="bulletin-section-text">${section.text}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function renderWeather() {
            const data = state.weatherData;
            const current = data.current;
            const model = models[state.model];
            const date = new Date().toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long' });

            // Générer le bulletin côtier si données marines disponibles
            const bulletin = state.marineData ? generateCoastalBulletin(state.currentCity, data, state.marineData) : null;

            const hourlyData = data.hourly.time.slice(0, 48).map((t, i) => ({
                time: new Date(t).getHours().toString().padStart(2, '0') + ':00',
                temp: data.hourly.temperature_2m[i],
                wind: data.hourly.wind_speed_10m[i],
                windGust: data.hourly.wind_gusts_10m[i],
                weatherCode: data.hourly.weather_code[i],
                isDay: new Date(t).getHours() >= 6 && new Date(t).getHours() < 20
            }));

            const dailyData = data.daily.time.map((t, i) => ({
                day: ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'][new Date(t).getDay()],
                high: data.daily.temperature_2m_max[i],
                low: data.daily.temperature_2m_min[i],
                weatherCode: data.daily.weather_code[i],
                wind: data.daily.wind_speed_10m_max[i],
                windGust: data.daily.wind_gusts_10m_max[i]
            }));

            mainContent.innerHTML = `
                <div class="main-grid">
                    <div class="left-panel">
                        <div class="weather-card">
                            <div class="current-weather">
                                <span class="weather-icon-large">${getWeatherIcon(current.weather_code, current.is_day === 1)}</span>
                                <div class="weather-info">
                                    <h1 class="city-name">${state.currentCity}</h1>
                                    <p class="weather-date">${date}</p>
                                    <div class="temp-display">
                                        <span class="temp-main">${convertTemp(current.temperature_2m)}${getTempUnit()}</span>
                                        <span class="temp-feels">Ressenti ${convertTemp(current.apparent_temperature)}${getTempUnit()}</span>
                                    </div>
                                    <p class="weather-desc">${getWeatherDesc(current.weather_code)}</p>
                                </div>
                            </div>

                            <!-- Widget Vent Compact -->
                            ${renderWindWidget(current.wind_speed_10m, current.wind_gusts_10m, current.wind_direction_10m)}

                            <!-- Prévision Pluie -->
                            ${renderRainForecast(data.hourly.precipitation, data.hourly.weather_code)}

                            <div class="details-grid">
                                <div class="detail-item">
                                    <div class="detail-icon">💧</div>
                                    <div class="detail-value">${current.relative_humidity_2m}%</div>
                                    <div class="detail-label">Humidité</div>
                                </div>
                                <div class="detail-item">
                                    <div class="detail-icon">📊</div>
                                    <div class="detail-value">${convertPressure(current.pressure_msl)}${getPressureUnit()}</div>
                                    <div class="detail-label">Pression</div>
                                </div>
                                <div class="detail-item">
                                    <div class="detail-icon">☁️</div>
                                    <div class="detail-value">${current.cloud_cover}%</div>
                                    <div class="detail-label">Couverture</div>
                                </div>
                                <div class="detail-item">
                                    <div class="detail-icon">🌧️</div>
                                    <div class="detail-value">${current.precipitation}mm</div>
                                    <div class="detail-label">Précipitations</div>
                                </div>
                            </div>

                            <div class="last-update">
                                Mise à jour: ${state.lastUpdate?.toLocaleTimeString('fr-FR')} - Source: Open-Meteo / ${model.provider}
                            </div>
                        </div>

                        <!-- Graphique Vent/Rafales -->
                        ${renderWindChart(data.hourly.wind_speed_10m, data.hourly.wind_gusts_10m, 24)}

                        <!-- Radar de pluie -->
                        ${renderRainRadar(state.currentCoords.lat, state.currentCoords.lon)}

                        <div class="tabs">
                            <button class="tab-btn active" data-tab="hourly">⏱️ Horaire</button>
                            <button class="tab-btn" data-tab="daily">📅 7 jours</button>
                        </div>

                        <div class="tab-content active" id="tab-hourly">
                            <div class="weather-card">
                                <div class="panel-title">Prévisions horaires (48h)</div>
                                <div class="hourly-scroll">
                                    ${hourlyData.map((h, i) => `
                                        <div class="hour-item ${i === 0 ? 'active' : ''}">
                                            <div class="hour-time">${h.time}</div>
                                            <div class="hour-icon">${getWeatherIcon(h.weatherCode, h.isDay)}</div>
                                            <div class="hour-temp">${convertTemp(h.temp)}°</div>
                                            <div class="hour-wind">${convertWind(h.wind, state.units.wind)}</div>
                                            <div class="hour-gust">↑${convertWind(h.windGust, state.units.wind)}</div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        </div>

                        <div class="tab-content" id="tab-daily">
                            <div class="weather-card">
                                <div class="panel-title">Prévisions 7 jours</div>
                                ${dailyData.map((d, i) => `
                                    <div class="daily-item">
                                        <div class="daily-day">${i === 0 ? 'Auj.' : d.day}</div>
                                        <span class="daily-icon">${getWeatherIcon(d.weatherCode, true)}</span>
                                        <div class="daily-temps">
                                            <span class="daily-high">${convertTemp(d.high)}°</span>
                                            <span class="daily-low">${convertTemp(d.low)}°</span>
                                        </div>
                                        <div class="daily-wind">${convertWind(d.wind, state.units.wind)} ${getWindUnitLabel()}</div>
                                        <div class="daily-gust">↑${convertWind(d.windGust, state.units.wind)}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>

                    <div class="side-panel">
                        <!-- Pression atmosphérique -->
                        <div class="panel-card">
                            <div class="panel-title">📊 Pression atmosphérique</div>
                            <div style="text-align:center;margin-bottom:10px;">
                                <span style="font-size:2rem;font-weight:700;">${convertPressure(current.pressure_msl)}</span>
                                <span style="font-size:0.9rem;opacity:0.7;">${getPressureUnit()}</span>
                            </div>
                            ${renderPressureChart(data.hourly.pressure_msl.slice(0, 40))}
                        </div>

                        <!-- Bulletin côtier si disponible -->
                        ${bulletin ? renderBulletin(bulletin) : ''}

                        <!-- Infos modèle -->
                        <div class="panel-card">
                            <div class="panel-title">ℹ️ Modèle ${model.name}</div>
                            <div class="marine-grid" style="gap:8px">
                                <div class="marine-item">
                                    <div class="marine-info">
                                        <div class="value">${model.resolution}</div>
                                        <div class="label">Résolution</div>
                                    </div>
                                </div>
                                <div class="marine-item">
                                    <div class="marine-info">
                                        <div class="value">${model.range}</div>
                                        <div class="label">Portée</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            setupTabs();
            // Initialiser le radar après le rendu
            setTimeout(() => initRadar(state.currentCoords.lat, state.currentCoords.lon), 200);
        }

        function renderMarine() {
            const weather = state.weatherData;
            const marine = state.marineData;
            const model = models[state.model];
            const current = weather.current;
            const marineCurrent = marine.current;

            const waveHeight = marineCurrent.wave_height || 0;
            const seaStateIndex = getSeaState(waveHeight);
            const seaState = seaStates[seaStateIndex];

            const safetyLevel = seaStateIndex <= 3 ? 'safe' : seaStateIndex <= 5 ? 'warning' : 'danger';
            const safetyIcon = safetyLevel === 'safe' ? '✅' : safetyLevel === 'warning' ? '⚠️' : '🚨';
            const safetyTitle = safetyLevel === 'safe' ? 'Conditions favorables' :
                               safetyLevel === 'warning' ? 'Prudence recommandée' : 'Navigation déconseillée';

            const bulletin = generateCoastalBulletin(state.currentCity, weather, marine);

            const marineHourly = marine.hourly.time.slice(0, 48).map((t, i) => ({
                time: new Date(t).getHours().toString().padStart(2, '0') + ':00',
                waveHeight: marine.hourly.wave_height[i],
                wind: weather.hourly.wind_speed_10m[i],
                windGust: weather.hourly.wind_gusts_10m[i]
            }));

            mainContent.innerHTML = `
                <div class="safety-alert ${safetyLevel}">
                    <span class="safety-icon">${safetyIcon}</span>
                    <div class="safety-text">
                        <div class="title">${safetyTitle}</div>
                        <div class="desc">Mer ${seaState.name.toLowerCase()} - ${seaState.desc}</div>
                    </div>
                    <span class="model-tag ${model.isHD ? 'hd' : ''}">${model.name}</span>
                </div>

                <div class="main-grid">
                    <div class="left-panel">
                        <div class="weather-card">
                            <div class="panel-title">🌊 État de la mer <span class="model-tag ${model.isHD ? 'hd' : ''}">${model.name} ${model.resolution}</span></div>

                            <div class="wave-visual">
                                <div class="wave-line"></div>
                                <div class="wave-stats">
                                    <div class="wave-height-value">${convertWave(waveHeight)}${getWaveUnit()}</div>
                                    <div class="wave-height-label">Hauteur des vagues</div>
                                </div>
                            </div>

                            <div class="sea-state-bar">
                                <div class="sea-state-marker" style="left: ${(seaStateIndex / 9) * 100}%"></div>
                            </div>
                            <div class="sea-state-labels">
                                <span>Calme</span>
                                <span>Agitée</span>
                                <span>Forte</span>
                                <span>Grosse</span>
                                <span>Énorme</span>
                            </div>

                            <!-- Widget Vent Compact Marine -->
                            ${renderWindWidget(current.wind_speed_10m, current.wind_gusts_10m, current.wind_direction_10m)}

                            <!-- Prévision Pluie -->
                            ${renderRainForecast(weather.hourly.precipitation, weather.hourly.weather_code)}

                            <!-- Indicateur de houle -->
                            ${renderSwellIndicator(
                                marineCurrent.swell_wave_height || 0,
                                marineCurrent.swell_wave_direction || 0,
                                marineCurrent.swell_wave_period || 0
                            )}

                            <!-- Graphique hauteur des vagues -->
                            ${renderWaveChart(marine.hourly.wave_height, 24)}

                            <!-- Graphique Vent/Rafales Marine -->
                            ${renderWindChart(weather.hourly.wind_speed_10m, weather.hourly.wind_gusts_10m, 24)}

                            <div class="marine-grid" style="margin-top:15px">
                                <div class="marine-item">
                                    <span class="marine-icon">🌊</span>
                                    <div class="marine-info">
                                        <div class="value">${Math.round(marineCurrent.wave_period || 0)}s</div>
                                        <div class="label">Période vagues</div>
                                    </div>
                                </div>
                                <div class="marine-item">
                                    <span class="marine-icon">🧭</span>
                                    <div class="marine-info">
                                        <div class="value">${getWindDirection(marineCurrent.wave_direction || 0)}</div>
                                        <div class="label">Dir. vagues</div>
                                    </div>
                                </div>
                            </div>

                            <div class="last-update">
                                Mise à jour: ${state.lastUpdate?.toLocaleTimeString('fr-FR')} - Source: Open-Meteo Marine
                            </div>
                        </div>

                        <div class="weather-card">
                            <div class="panel-title">⏱️ Prévisions horaires</div>
                            <div class="hourly-scroll">
                                ${marineHourly.map((h, i) => `
                                    <div class="hour-item ${i === 0 ? 'active' : ''}">
                                        <div class="hour-time">${h.time}</div>
                                        <div class="hour-icon">🌊</div>
                                        <div class="hour-temp">${convertWave(h.waveHeight)}${getWaveUnit()}</div>
                                        <div class="hour-wind">${convertWind(h.wind, state.units.wind)}</div>
                                        <div class="hour-gust">↑${convertWind(h.windGust, state.units.wind)}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>

                    <div class="side-panel">
                        <!-- Bulletin Marine Détaillé Météo-France -->
                        <div id="marineBulletinContainer">
                            <div class="panel-card"><p style="opacity:0.6;text-align:center;">Chargement du bulletin marine...</p></div>
                        </div>

                        <!-- Marées avec courbe -->
                        ${renderTides(state.tidesData)}
                        ${renderTideCurve(state.tidesData)}

                        <!-- Radar de pluie -->
                        ${renderRainRadar(state.currentCoords.lat, state.currentCoords.lon)}

                        <!-- Info Port -->
                        ${renderPortInfo(state.currentCity)}

                        <div class="panel-card">
                            <div class="panel-title">📈 Pression (40h)</div>
                            ${renderPressureChart(weather.hourly.pressure_msl.slice(0, 40))}
                        </div>
                    </div>
                </div>
            `;

            // Initialiser le radar après le rendu
            setTimeout(() => initRadar(state.currentCoords.lat, state.currentCoords.lon), 200);

            // Charger le bulletin marine détaillé
            setTimeout(async () => {
                const bulletin = await generateMarineBulletin(selectedMarineZone);
                const container = document.getElementById('marineBulletinContainer');
                if (container) {
                    container.innerHTML = renderMarineBulletin(bulletin);
                }
            }, 100);
        }

        function renderPressureChart(pressureData) {
            if (!pressureData?.length) return '<p>Données non disponibles</p>';

            const minP = Math.min(...pressureData) - 3;
            const maxP = Math.max(...pressureData) + 3;

            const points = pressureData.map((p, i) => {
                const x = 5 + (i / (pressureData.length - 1)) * 90;
                const y = 95 - ((p - minP) / (maxP - minP)) * 90;
                return `${x},${y}`;
            }).join(' ');

            const trendDiff = pressureData.length >= 8 ?
                (pressureData.slice(-4).reduce((a, b) => a + b, 0) / 4) -
                (pressureData.slice(0, 4).reduce((a, b) => a + b, 0) / 4) : 0;

            return `
                <div class="pressure-chart">
                    <svg class="chart-svg" viewBox="0 0 100 100" preserveAspectRatio="none">
                        <defs>
                            <linearGradient id="pressureGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" style="stop-color:rgba(0,180,216,0.3)"/>
                                <stop offset="100%" style="stop-color:rgba(0,180,216,0.02)"/>
                            </linearGradient>
                        </defs>
                        <line class="chart-grid" x1="5" y1="25" x2="95" y2="25"/>
                        <line class="chart-grid" x1="5" y1="50" x2="95" y2="50"/>
                        <line class="chart-grid" x1="5" y1="75" x2="95" y2="75"/>
                        <polygon class="chart-area" points="5,95 ${points} 95,95"/>
                        <polyline class="chart-line" points="${points}"/>
                    </svg>
                </div>
                <div class="pressure-stats">
                    <div class="pressure-stat">
                        <div class="value">${convertPressure(pressureData[0])}${getPressureUnit()}</div>
                        <div class="label">Actuelle</div>
                    </div>
                    <div class="pressure-stat">
                        <div class="value ${trendDiff > 1 ? 'trend-up' : trendDiff < -1 ? 'trend-down' : 'trend-stable'}">
                            ${trendDiff > 1 ? '↗️ Hausse' : trendDiff < -1 ? '↘️ Baisse' : '➡️ Stable'}
                        </div>
                        <div class="label">Tendance</div>
                    </div>
                </div>
            `;
        }

        function setupTabs() {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    btn.classList.add('active');
                    document.getElementById(`tab-${btn.dataset.tab}`)?.classList.add('active');
                });
            });
        }
    </script>
</body>
</html>
