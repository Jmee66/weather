<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1a1a2e">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Jmee Weather Station</title>
    <link rel="manifest" href="manifest.json">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --sunny-gradient: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            --rainy-gradient: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            --cloudy-gradient: linear-gradient(135deg, #1a1a2e 0%, #2c3e50 100%);
            --night-gradient: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            --marine-gradient: linear-gradient(135deg, #0a1628 0%, #0d2137 50%, #0a1a2e 100%);
            --glass-bg: rgba(255,255,255,0.08);
            --glass-border: rgba(255,255,255,0.12);
            --accent-blue: #00b4d8;
            --accent-orange: #ff6b35;
            --accent-green: #2ecc71;
            --accent-purple: #9b59b6;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            background: var(--sunny-gradient);
            color: white;
            overflow-x: hidden;
        }

        .app-container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 10px 15px;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        /* Header Windy Style */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            flex-wrap: wrap;
            gap: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 15px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.3rem;
            font-weight: 700;
        }

        .logo-icon {
            font-size: 1.6rem;
        }

        /* Mode Toggle */
        .mode-toggle {
            display: flex;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 3px;
        }

        .mode-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background: transparent;
            color: rgba(255,255,255,0.6);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }

        .mode-btn.active {
            background: var(--accent-blue);
            color: white;
        }

        /* Sélecteur de jours (prévision 7 jours) */
        .day-selector {
            display: flex;
            gap: 4px;
            padding: 8px 12px;
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            margin-bottom: 15px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
        }

        .day-selector::-webkit-scrollbar {
            display: none;
        }

        .day-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 12px;
            min-width: 70px;
            border: none;
            border-radius: 10px;
            background: transparent;
            color: rgba(255,255,255,0.6);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .day-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .day-btn.active {
            background: var(--accent-blue);
            color: white;
        }

        .day-btn.today {
            border: 1px solid var(--accent-blue);
        }

        .day-btn-name {
            font-weight: 600;
            font-size: 0.8rem;
            margin-bottom: 2px;
        }

        .day-btn-date {
            font-size: 0.7rem;
            opacity: 0.7;
        }

        .day-btn-icon {
            font-size: 1.2rem;
            margin: 4px 0;
        }

        .day-btn-temp {
            font-size: 0.7rem;
            font-weight: 500;
        }

        .day-btn-temp-max {
            color: #e74c3c;
        }

        .day-btn-temp-min {
            color: #3498db;
        }

        .day-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: rgba(0,180,216,0.2);
            border-radius: 8px;
            margin-bottom: 10px;
            font-size: 0.85rem;
        }

        .day-indicator-badge {
            background: var(--accent-blue);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .search-container {
            display: flex;
            gap: 6px;
        }

        .search-input {
            padding: 10px 16px;
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            font-size: 0.9rem;
            width: 220px;
            min-width: 120px;
            max-width: 100%;
            background: rgba(0,0,0,0.3);
            color: white;
            outline: none;
            transition: all 0.2s;
            flex-shrink: 1;
        }

        .search-input::placeholder {
            color: rgba(255,255,255,0.5);
        }

        .search-input:focus {
            border-color: var(--accent-blue);
            background: rgba(0,0,0,0.4);
        }

        .btn {
            padding: 10px 14px;
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .btn-icon {
            width: 40px;
            padding: 10px;
        }

        .btn-add {
            background: rgba(46,204,113,0.2);
            border-color: rgba(46,204,113,0.3);
        }

        .btn-add:hover {
            background: rgba(46,204,113,0.3);
        }

        /* Control Bar - Windy Style */
        .control-bar {
            display: flex;
            gap: 15px;
            padding: 12px 15px;
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-label {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-select {
            padding: 6px 10px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            background: rgba(0,0,0,0.4);
            color: white;
            font-size: 0.85rem;
            cursor: pointer;
            outline: none;
        }

        .control-select option {
            background: #1a1a2e;
        }

        /* Unit Selector */
        .unit-selector {
            display: flex;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            padding: 2px;
        }

        .unit-btn {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            background: transparent;
            color: rgba(255,255,255,0.6);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .unit-btn.active {
            background: var(--accent-blue);
            color: white;
        }

        /* Location Badge */
        .location-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(0,180,216,0.2);
            border: 1px solid rgba(0,180,216,0.3);
            border-radius: 20px;
            font-size: 0.85rem;
        }

        .location-badge .dot {
            width: 8px;
            height: 8px;
            background: var(--accent-green);
            border-radius: 50%;
            animation: pulse-dot 2s infinite;
        }

        .location-badge.live .dot {
            background: #ff4444;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* API Status Badge */
        .api-status {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: rgba(46,204,113,0.2);
            border: 1px solid rgba(46,204,113,0.3);
            border-radius: 15px;
            font-size: 0.75rem;
        }

        .api-status.error {
            background: rgba(231,76,60,0.2);
            border-color: rgba(231,76,60,0.3);
        }

        .api-status .status-dot {
            width: 6px;
            height: 6px;
            background: var(--accent-green);
            border-radius: 50%;
        }

        .api-status.error .status-dot {
            background: #e74c3c;
        }

        .api-status.offline {
            background: rgba(241,196,15,0.2);
            border-color: rgba(241,196,15,0.3);
        }

        .api-status.offline .status-dot {
            background: #f1c40f;
        }

        /* Offline Banner */
        .offline-banner {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(90deg, #f39c12, #e67e22);
            color: white;
            padding: 8px 15px;
            text-align: center;
            font-size: 0.8rem;
            z-index: 10000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .offline-banner.show {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .offline-banner .offline-icon {
            font-size: 1rem;
        }

        .offline-banner .offline-time {
            font-size: 0.7rem;
            opacity: 0.8;
        }

        body.offline-mode {
            padding-top: 40px;
        }

        /* Cache indicator */
        .cache-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 0.65rem;
            color: rgba(255,255,255,0.5);
            margin-left: 8px;
        }

        .cache-indicator.fresh {
            color: #2ecc71;
        }

        .cache-indicator.stale {
            color: #f1c40f;
        }

        .cache-indicator.old {
            color: #e74c3c;
        }

        /* Favorites Section */
        .favorites-section {
            margin-bottom: 15px;
        }

        .favorites-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .favorites-title {
            font-size: 0.85rem;
            color: rgba(255,255,255,0.7);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .favorites-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .favorite-chip {
            padding: 6px 14px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            color: rgba(255,255,255,0.8);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .favorite-chip:hover {
            background: rgba(255,255,255,0.1);
            border-color: var(--accent-blue);
        }

        .favorite-chip.active {
            background: rgba(0,180,216,0.2);
            border-color: var(--accent-blue);
            color: white;
        }

        .favorite-chip.port {
            border-color: rgba(155,89,182,0.4);
        }

        .favorite-chip.port.active {
            background: rgba(155,89,182,0.2);
            border-color: var(--accent-purple);
        }

        .favorite-chip .delete-fav {
            margin-left: 4px;
            opacity: 0;
            font-size: 0.7rem;
            transition: opacity 0.2s;
        }

        .favorite-chip:hover .delete-fav {
            opacity: 0.7;
        }

        .favorite-chip .delete-fav:hover {
            opacity: 1;
            color: #e74c3c;
        }

        /* Main Grid */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr minmax(300px, 380px);
            gap: 15px;
            max-width: 100%;
            overflow: hidden;
        }

        @media (max-width: 1000px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 600px) {
            .app-container {
                padding: 8px 10px;
            }
        }

        /* Weather Card - Windy Style */
        .weather-card {
            background: rgba(0,0,0,0.4);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.08);
            margin-bottom: 15px;
        }

        .current-weather {
            display: flex;
            align-items: center;
            gap: 25px;
            margin-bottom: 20px;
        }

        .weather-icon-large {
            font-size: 5rem;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
        }

        .weather-info {
            flex: 1;
        }

        .city-name {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .weather-date {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.6);
            margin-bottom: 10px;
        }

        .temp-display {
            display: flex;
            align-items: baseline;
            gap: 8px;
        }

        .temp-main {
            font-size: 3.5rem;
            font-weight: 300;
        }

        .temp-feels {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.6);
        }

        .weather-desc {
            font-size: 1.1rem;
            color: rgba(255,255,255,0.8);
            margin-top: 5px;
        }

        /* Wind Particles Visualization - Windy Style */
        .wind-particles-container {
            background: linear-gradient(135deg, rgba(0,30,60,0.9) 0%, rgba(0,50,100,0.7) 100%);
            border-radius: 12px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
            height: 140px;
        }

        .wind-particles-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .wind-particles-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 12px 15px;
            pointer-events: none;
            z-index: 10;
        }

        .wind-data-box {
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            border-radius: 10px;
            padding: 10px 14px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .wind-data-speed {
            font-size: 2.2rem;
            font-weight: 700;
            color: #4fc3f7;
            line-height: 1;
            text-shadow: 0 2px 10px rgba(79,195,247,0.5);
        }

        .wind-data-speed .unit {
            font-size: 0.9rem;
            font-weight: 400;
            opacity: 0.8;
        }

        .wind-data-dir {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.8);
            margin-top: 4px;
        }

        .wind-data-beaufort {
            display: flex;
            gap: 2px;
            margin-top: 6px;
        }

        .bf-seg {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(255,255,255,0.15);
        }

        .bf-seg.active { background: #4fc3f7; box-shadow: 0 0 6px #4fc3f7; }
        .bf-seg.gust { background: #ff7043; box-shadow: 0 0 6px #ff7043; }

        .wind-gust-box {
            background: rgba(255,107,53,0.25);
            backdrop-filter: blur(8px);
            border-radius: 10px;
            padding: 10px 14px;
            border: 1px solid rgba(255,107,53,0.4);
            text-align: center;
        }

        .wind-gust-val {
            font-size: 1.6rem;
            font-weight: 700;
            color: #ff7043;
            text-shadow: 0 2px 10px rgba(255,112,67,0.5);
        }

        .wind-gust-lbl {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.7);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .wind-compass-overlay {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 55px;
            height: 55px;
            z-index: 10;
        }

        .wind-compass-overlay svg {
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        /* Rain Forecast Widget */
        .rain-forecast {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 12px 15px;
            margin: 10px 0;
        }

        .rain-forecast-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .rain-forecast-title {
            font-size: 0.85rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .rain-status {
            font-size: 0.75rem;
            padding: 3px 8px;
            border-radius: 10px;
        }

        .rain-status.dry {
            background: rgba(46,204,113,0.2);
            color: #2ecc71;
        }

        .rain-status.light {
            background: rgba(0,180,216,0.2);
            color: var(--accent-blue);
        }

        .rain-status.moderate {
            background: rgba(241,196,15,0.2);
            color: #f1c40f;
        }

        .rain-status.heavy {
            background: rgba(231,76,60,0.2);
            color: #e74c3c;
        }

        .rain-timeline {
            display: flex;
            gap: 6px;
        }

        .rain-slot {
            flex: 1;
            text-align: center;
            padding: 8px 4px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            transition: all 0.3s;
        }

        .rain-slot.has-rain {
            background: rgba(0,180,216,0.15);
            border: 1px solid rgba(0,180,216,0.3);
        }

        .rain-slot.heavy-rain {
            background: rgba(231,76,60,0.15);
            border: 1px solid rgba(231,76,60,0.3);
        }

        .rain-slot-time {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            margin-bottom: 4px;
        }

        .rain-slot-icon {
            font-size: 1.2rem;
            margin-bottom: 2px;
        }

        .rain-slot-amount {
            font-size: 0.75rem;
            font-weight: 600;
        }

        .rain-slot-amount.none {
            color: rgba(255,255,255,0.4);
        }

        .rain-slot-amount.light {
            color: var(--accent-blue);
        }

        .rain-slot-amount.moderate {
            color: #f1c40f;
        }

        .rain-slot-amount.heavy {
            color: #e74c3c;
        }

        .rain-slot-hour {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.5);
            margin-top: 3px;
            font-family: 'SF Mono', 'Monaco', monospace;
        }

        /* Mini Rain Bar */
        .rain-mini-bar {
            display: flex;
            gap: 1px;
            height: 20px;
            margin-top: 8px;
            border-radius: 4px;
            overflow: hidden;
        }

        .rain-mini-segment {
            flex: 1;
            background: rgba(255,255,255,0.05);
            transition: background 0.3s;
        }

        .rain-mini-segment.level-1 { background: rgba(0,180,216,0.4); }
        .rain-mini-segment.level-2 { background: rgba(0,180,216,0.7); }
        .rain-mini-segment.level-3 { background: rgba(241,196,15,0.7); }
        .rain-mini-segment.level-4 { background: rgba(255,107,53,0.8); }
        .rain-mini-segment.level-5 { background: rgba(231,76,60,0.9); }

        .model-tag {
            font-size: 0.7rem;
            padding: 3px 8px;
            background: rgba(0,180,216,0.3);
            border-radius: 10px;
            font-weight: 500;
        }

        .model-tag.hd {
            background: linear-gradient(135deg, rgba(255,107,53,0.4), rgba(255,165,0,0.4));
            border: 1px solid rgba(255,165,0,0.5);
        }

        /* Swell Direction */
        .swell-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(155,89,182,0.15);
            border: 1px solid rgba(155,89,182,0.3);
            border-radius: 10px;
            margin: 15px 0;
        }

        .swell-compass {
            width: 80px;
            height: 80px;
            position: relative;
        }

        .swell-compass svg {
            width: 100%;
            height: 100%;
        }

        .swell-arrow {
            fill: var(--accent-purple);
            transition: transform 0.5s ease;
        }

        .swell-info {
            flex: 1;
        }

        .swell-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .swell-details {
            display: flex;
            gap: 20px;
        }

        .swell-detail {
            text-align: center;
        }

        .swell-detail .value {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--accent-purple);
        }

        .swell-detail .label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
        }

        /* Details Grid */
        .details-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        @media (max-width: 600px) {
            .details-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .detail-item {
            background: rgba(0,0,0,0.25);
            border-radius: 10px;
            padding: 12px;
            text-align: center;
        }

        .detail-icon {
            font-size: 1.4rem;
            margin-bottom: 6px;
        }

        .detail-value {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .detail-label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            margin-top: 3px;
        }

        /* Side Panel */
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 0;
            overflow: hidden;
        }

        .panel-card {
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255,255,255,0.08);
            overflow: hidden;
        }

        .left-panel {
            min-width: 0;
            overflow: hidden;
        }

        .panel-title {
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Tides Section */
        .tides-container {
            padding: 15px;
            background: rgba(0,119,182,0.15);
            border: 1px solid rgba(0,119,182,0.3);
            border-radius: 12px;
        }

        .tides-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .tides-title {
            font-size: 0.9rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tides-coefficient {
            padding: 4px 10px;
            background: rgba(0,180,216,0.3);
            border-radius: 15px;
            font-size: 0.75rem;
        }

        .tides-chart {
            height: 80px;
            position: relative;
            margin: 15px 0;
        }

        .tides-chart svg {
            width: 100%;
            height: 100%;
        }

        .tide-curve {
            fill: none;
            stroke: var(--accent-blue);
            stroke-width: 2;
        }

        .tide-area {
            fill: url(#tideGrad);
        }

        .tide-now-line {
            stroke: var(--accent-orange);
            stroke-width: 2;
            stroke-dasharray: 4 2;
        }

        .tide-now-dot {
            fill: var(--accent-orange);
        }

        .tides-times {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .tide-time {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .tide-icon {
            font-size: 1.5rem;
        }

        .tide-info .time {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .tide-info .height {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.6);
        }

        .tide-info .label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
        }

        /* Port Info */
        .port-info {
            background: rgba(155,89,182,0.15);
            border: 1px solid rgba(155,89,182,0.3);
            border-radius: 12px;
            padding: 15px;
        }

        .port-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .port-title {
            font-size: 0.9rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .port-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .port-item {
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            text-align: center;
        }

        .port-item .value {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent-purple);
        }

        .port-item .label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            margin-top: 4px;
        }

        /* Bulletin Côtier */
        .bulletin-container {
            background: rgba(46,204,113,0.1);
            border: 1px solid rgba(46,204,113,0.3);
            border-radius: 12px;
            padding: 15px;
        }

        .bulletin-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .bulletin-title {
            font-size: 0.9rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .bulletin-date {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
        }

        .bulletin-zone {
            padding: 4px 10px;
            background: rgba(46,204,113,0.3);
            border-radius: 15px;
            font-size: 0.75rem;
        }

        /* Bulletin Marine Détaillé */
        .marine-bulletin {
            background: linear-gradient(135deg, rgba(0,119,182,0.2) 0%, rgba(0,80,120,0.15) 100%);
            border: 1px solid rgba(0,119,182,0.3);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .marine-bulletin-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .marine-bulletin-title {
            font-size: 1rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .marine-bulletin-title img {
            height: 24px;
        }

        .zone-selector {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .zone-select {
            padding: 6px 12px;
            border: 1px solid rgba(0,119,182,0.4);
            border-radius: 8px;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 0.85rem;
            cursor: pointer;
            outline: none;
        }

        .zone-select option {
            background: #1a1a2e;
        }

        .zone-select:focus {
            border-color: var(--accent-blue);
        }

        .marine-bulletin-meta {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            font-size: 0.75rem;
            color: rgba(255,255,255,0.6);
            flex-wrap: wrap;
        }

        .marine-bulletin-meta span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .bulletin-block {
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .bulletin-block:last-child {
            margin-bottom: 0;
        }

        .bulletin-block-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--accent-blue);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .bulletin-block-content {
            font-size: 0.85rem;
            line-height: 1.6;
            color: rgba(255,255,255,0.9);
        }

        .bulletin-warning {
            background: rgba(241,196,15,0.15);
            border: 1px solid rgba(241,196,15,0.3);
            border-radius: 8px;
            padding: 10px 12px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bulletin-warning.danger {
            background: rgba(231,76,60,0.15);
            border-color: rgba(231,76,60,0.3);
        }

        .bulletin-warning-icon {
            font-size: 1.2rem;
        }

        .bulletin-warning-text {
            font-size: 0.8rem;
            font-weight: 500;
        }

        .bulletin-forecast-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        @media (max-width: 600px) {
            .bulletin-forecast-grid {
                grid-template-columns: 1fr;
            }
        }

        .bulletin-forecast-item {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }

        .bulletin-forecast-period {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            margin-bottom: 5px;
        }

        .bulletin-forecast-wind {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent-blue);
        }

        .bulletin-forecast-sea {
            font-size: 0.75rem;
            color: var(--accent-purple);
            margin-top: 4px;
        }

        .bulletin-content {
            font-size: 0.85rem;
            line-height: 1.6;
            color: rgba(255,255,255,0.9);
        }

        .bulletin-section {
            margin-bottom: 12px;
        }

        .bulletin-section-title {
            font-weight: 600;
            color: var(--accent-green);
            margin-bottom: 4px;
            font-size: 0.8rem;
        }

        .bulletin-section-text {
            font-size: 0.8rem;
            opacity: 0.9;
        }

        /* Hourly Scroll */
        .hourly-scroll {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding-bottom: 8px;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.2) transparent;
        }

        .hourly-scroll::-webkit-scrollbar {
            height: 4px;
        }

        .hourly-scroll::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }

        .hour-item {
            min-width: 65px;
            padding: 10px 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            text-align: center;
            flex-shrink: 0;
            transition: all 0.2s;
            cursor: pointer;
        }

        .hour-item:hover {
            background: rgba(255,255,255,0.1);
        }

        .hour-item.active {
            background: rgba(0,180,216,0.2);
            border: 1px solid rgba(0,180,216,0.3);
        }

        .hour-time {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.6);
            margin-bottom: 6px;
        }

        .hour-icon {
            font-size: 1.3rem;
            margin-bottom: 6px;
        }

        .hour-temp {
            font-size: 0.9rem;
            font-weight: 600;
        }

        .hour-wind {
            font-size: 0.7rem;
            color: var(--accent-blue);
            margin-top: 4px;
        }

        .hour-gust {
            font-size: 0.65rem;
            color: var(--accent-orange);
        }

        .hour-wave {
            font-size: 0.65rem;
            color: var(--accent-purple);
            margin-top: 2px;
        }

        /* Pressure Chart */
        .pressure-chart {
            height: 100px;
            position: relative;
            margin: 10px 0;
        }

        .chart-svg {
            width: 100%;
            height: 100%;
        }

        .chart-line {
            fill: none;
            stroke: var(--accent-blue);
            stroke-width: 2;
            stroke-linecap: round;
        }

        .chart-area {
            fill: url(#pressureGrad);
        }

        .chart-grid {
            stroke: rgba(255,255,255,0.1);
            stroke-width: 1;
        }

        .pressure-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 0.75rem;
        }

        .pressure-stat {
            text-align: center;
        }

        .pressure-stat .value {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .pressure-stat .label {
            color: rgba(255,255,255,0.5);
            font-size: 0.65rem;
        }

        .trend-up { color: var(--accent-green); }
        .trend-down { color: var(--accent-orange); }
        .trend-stable { color: var(--accent-blue); }

        /* Marine Specific */
        .marine-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .marine-item {
            background: rgba(0,0,0,0.25);
            border-radius: 10px;
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .marine-icon {
            font-size: 1.5rem;
        }

        .marine-info .value {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .marine-info .label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
        }

        /* Wave Display */
        .wave-visual {
            height: 80px;
            background: linear-gradient(180deg, transparent, rgba(0,119,182,0.3));
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            margin: 10px 0;
        }

        .wave-line {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 200%;
            height: 100%;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1200 120'%3E%3Cpath fill='rgba(0,180,216,0.4)' d='M0,60 C150,120 350,0 600,60 C850,120 1050,0 1200,60 L1200,120 L0,120 Z'/%3E%3C/svg%3E") repeat-x;
            animation: wave-move 4s linear infinite;
        }

        @keyframes wave-move {
            from { transform: translateX(0); }
            to { transform: translateX(-50%); }
        }

        .wave-stats {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .wave-height-value {
            font-size: 2rem;
            font-weight: 700;
        }

        .wave-height-label {
            font-size: 0.75rem;
            opacity: 0.7;
        }

        /* Wind/Gust Chart */
        .wind-chart-container {
            background: rgba(0,0,0,0.25);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
        }

        .wind-chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .wind-chart-title {
            font-size: 0.9rem;
            font-weight: 600;
        }

        .wind-chart-legend {
            display: flex;
            gap: 15px;
            font-size: 0.75rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .legend-dot.wind {
            background: var(--accent-blue);
        }

        .legend-dot.gust {
            background: var(--accent-orange);
        }

        .wind-chart {
            height: 120px;
            position: relative;
        }

        .wind-chart svg {
            width: 100%;
            height: 100%;
        }

        .wind-line {
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .wind-line.main {
            stroke: var(--accent-blue);
        }

        .wind-line.gust {
            stroke: var(--accent-orange);
            stroke-dasharray: 4 2;
        }

        .wind-area {
            fill: url(#windGrad);
        }

        .gust-area {
            fill: url(#gustGrad);
        }

        .wind-chart-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.65rem;
            color: rgba(255,255,255,0.5);
            margin-top: 5px;
        }

        /* Wave Chart */
        .wave-chart-container {
            background: linear-gradient(135deg, rgba(155,89,182,0.15), rgba(155,89,182,0.05));
            border: 1px solid rgba(155,89,182,0.2);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
        }

        .wave-chart {
            height: 100px;
            position: relative;
        }

        .wave-chart svg {
            width: 100%;
            height: 100%;
        }

        .wave-line-chart {
            fill: none;
            stroke: var(--accent-purple);
            stroke-width: 2.5;
            stroke-linecap: round;
        }

        .wave-area-fill {
            fill: url(#waveGrad);
        }

        /* Tide Curve */
        .tide-curve-container {
            background: linear-gradient(135deg, rgba(0,119,182,0.15), rgba(0,119,182,0.05));
            border: 1px solid rgba(0,119,182,0.2);
            border-radius: 12px;
            padding: 15px;
            margin-top: 15px;
        }

        .tide-curve-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .tide-curve-chart {
            height: 100px;
            position: relative;
        }

        .tide-curve-chart svg {
            width: 100%;
            height: 100%;
        }

        .tide-curve-path {
            fill: none;
            stroke: var(--accent-blue);
            stroke-width: 2.5;
        }

        .tide-area-fill {
            fill: url(#tideGradient);
        }

        .tide-now-marker {
            fill: var(--accent-orange);
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }

        .tide-time-marker {
            fill: rgba(255,255,255,0.6);
            font-size: 8px;
        }

        .tide-height-marker {
            fill: rgba(255,255,255,0.4);
            font-size: 7px;
        }

        .tide-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 0.7rem;
            color: rgba(255,255,255,0.6);
        }

        /* Rain Radar */
        .radar-container {
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .radar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .radar-title {
            font-size: 0.9rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .radar-live {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.7rem;
            padding: 3px 8px;
            background: rgba(231,76,60,0.3);
            border-radius: 10px;
        }

        .radar-live .pulse {
            width: 6px;
            height: 6px;
            background: #e74c3c;
            border-radius: 50%;
            animation: pulse-radar 1.5s infinite;
        }

        @keyframes pulse-radar {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        .radar-map {
            height: 200px;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            background: #1a1a2e;
            max-width: 100%;
        }

        .radar-map #radarMap {
            height: 100%;
            width: 100%;
        }

        @media (max-width: 600px) {
            .radar-map {
                height: 180px;
            }
        }

        .radar-controls {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            align-items: center;
        }

        .radar-btn {
            padding: 6px 12px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .radar-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .radar-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
        }

        .radar-timeline {
            flex: 1;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            position: relative;
            cursor: pointer;
        }

        .radar-timeline-progress {
            height: 100%;
            background: var(--accent-blue);
            border-radius: 2px;
            transition: width 0.3s;
        }

        .radar-time-label {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.7);
            min-width: 50px;
            text-align: right;
        }

        .radar-legend {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
            font-size: 0.65rem;
        }

        .radar-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .radar-legend-color {
            width: 12px;
            height: 8px;
            border-radius: 2px;
        }

        .radar-time-display {
            display: flex;
            align-items: baseline;
            gap: 10px;
            margin-top: 10px;
            padding: 8px 12px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }

        .radar-time-main {
            font-size: 1.4rem;
            font-weight: 700;
            color: white;
            font-family: 'SF Mono', 'Monaco', monospace;
        }

        .radar-time-delta {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.6);
        }

        .radar-time-delta.future {
            color: #2ecc71;
        }

        .radar-time-delta.past {
            color: #f39c12;
        }

        .radar-timeline-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .radar-timeline-ticks {
            display: flex;
            justify-content: space-between;
            font-size: 0.6rem;
            color: rgba(255,255,255,0.4);
            padding: 0 2px;
        }

        .radar-frames-list {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 10px;
            max-height: 60px;
            overflow-y: auto;
        }

        .radar-frame-btn {
            padding: 3px 6px;
            font-size: 0.65rem;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 4px;
            color: rgba(255,255,255,0.7);
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'SF Mono', 'Monaco', monospace;
        }

        .radar-frame-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .radar-frame-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        .radar-frame-btn.future {
            border-color: rgba(46,204,113,0.4);
            color: #2ecc71;
        }

        .radar-frame-btn.nowcast {
            background: rgba(46,204,113,0.2);
        }

        /* Carte Marine OpenSeaMap */
        .marine-chart-container {
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            border: 1px solid rgba(255,255,255,0.1);
            position: relative;
            transition: all 0.3s ease;
        }

        .marine-chart-container.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            margin: 0;
            border-radius: 0;
            z-index: 9999;
            padding: 0;
            background: #1a1a2e;
        }

        .marine-chart-container.fullscreen .marine-chart-header {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            z-index: 1001;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 10px;
            margin-bottom: 0;
        }

        .marine-chart-container.fullscreen .marine-chart-map {
            height: 100vh;
            border-radius: 0;
        }

        .marine-chart-container.fullscreen .marine-chart-legend {
            position: absolute;
            bottom: 15px;
            left: 15px;
            right: 15px;
            z-index: 1001;
            background: rgba(0,0,0,0.8);
            padding: 12px 15px;
            border-radius: 10px;
            margin-top: 0;
        }

        .marine-chart-container.fullscreen .marine-chart-controls {
            top: 80px;
            right: 20px;
        }

        .marine-chart-container.fullscreen .layer-controls {
            display: flex;
        }

        .marine-chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .marine-chart-title {
            font-size: 0.9rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .fullscreen-hint {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.4);
            font-weight: normal;
        }

        .marine-chart-container.fullscreen .fullscreen-hint {
            display: none;
        }

        .marine-chart-source {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            background: rgba(0,0,0,0.3);
            padding: 2px 8px;
            border-radius: 10px;
        }

        .marine-chart-map {
            height: 280px;
            border-radius: 10px;
            overflow: hidden;
            background: #1a1a2e;
            cursor: pointer;
        }

        .marine-chart-legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 8px 15px;
            margin-top: 10px;
            font-size: 0.7rem;
            color: rgba(255,255,255,0.7);
        }

        .marine-legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-marker {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .legend-marker.buoy {
            background: #f1c40f;
        }

        .legend-marker.light {
            background: #e74c3c;
        }

        .legend-marker.port {
            background: #3498db;
        }

        .legend-marker.depth {
            background: linear-gradient(180deg, #a8e6cf, #1abc9c, #0a5c4a);
        }

        .legend-marker.anchor {
            background: #9b59b6;
        }

        .legend-marker.restricted {
            background: #e74c3c;
            border: 2px dashed #fff;
        }

        .legend-marker.lane {
            background: transparent;
            border: 2px solid #f39c12;
        }

        .legend-marker.wreck {
            background: #34495e;
        }

        .marine-chart-controls {
            position: absolute;
            top: 55px;
            right: 25px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 1000;
        }

        .marine-zoom-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 6px;
            background: rgba(0,0,0,0.7);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .marine-zoom-btn:hover {
            background: rgba(0,0,0,0.9);
        }

        .marine-zoom-btn.close-btn {
            background: rgba(231,76,60,0.8);
            display: none;
        }

        .marine-zoom-btn.expand-btn {
            background: rgba(46,204,113,0.7);
        }

        .marine-chart-container.fullscreen .marine-zoom-btn.close-btn {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .marine-chart-container.fullscreen .marine-zoom-btn.expand-btn {
            display: none;
        }

        .marine-zoom-btn.gps-btn {
            background: rgba(52,152,219,0.7);
        }

        .marine-zoom-btn.gps-btn.active {
            background: rgba(46,204,113,0.9);
            animation: pulse-gps 1.5s infinite;
        }

        .marine-zoom-btn.fishing-btn {
            background: rgba(230,126,34,0.7);
        }

        .marine-zoom-btn.fishing-btn.active {
            background: rgba(46,204,113,0.9);
        }

        @keyframes pulse-gps {
            0%, 100% { box-shadow: 0 0 0 0 rgba(46,204,113,0.7); }
            50% { box-shadow: 0 0 0 8px rgba(46,204,113,0); }
        }

        /* Marqueur GPS */
        .gps-marker {
            background: transparent;
        }

        .gps-marker-inner {
            width: 30px;
            height: 30px;
            background: rgba(52,152,219,0.3);
            border: 3px solid #3498db;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse-gps-marker 2s infinite;
        }

        .gps-arrow {
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 12px solid #3498db;
        }

        @keyframes pulse-gps-marker {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        /* GPS Status */
        .gps-status {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.5);
            margin-top: 8px;
            padding: 5px 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            text-align: center;
        }

        .gps-status.active {
            color: #2ecc71;
            background: rgba(46,204,113,0.2);
        }

        .gps-status.error {
            color: #e74c3c;
            background: rgba(231,76,60,0.2);
        }

        .gps-center-btn {
            width: 100%;
            padding: 6px 10px;
            margin-top: 5px;
            border: none;
            border-radius: 5px;
            background: rgba(52,152,219,0.3);
            color: white;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .gps-center-btn:hover {
            background: rgba(52,152,219,0.5);
        }

        /* Mode Pêche */
        .fishing-info {
            background: rgba(230,126,34,0.2);
            border-radius: 5px;
            padding: 8px;
            margin-top: 5px;
        }

        .fishing-data {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.8);
            margin: 3px 0;
        }

        .fishing-data span:first-child {
            color: rgba(255,255,255,0.5);
        }

        .fishing-good { color: #2ecc71 !important; }
        .fishing-medium { color: #f1c40f !important; }
        .fishing-poor { color: #e74c3c !important; }

        /* Légende bathymétrie visible */
        .bathy-legend {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 8px 15px;
            border-radius: 8px;
            z-index: 1000;
            display: none;
        }

        .marine-chart-container .bathy-legend {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bathy-gradient {
            width: 150px;
            height: 12px;
            background: linear-gradient(90deg,
                #b8e6ff 0%,
                #7fcdff 15%,
                #4db8ff 25%,
                #1a9fff 35%,
                #0077cc 50%,
                #005599 65%,
                #003366 80%,
                #001a33 100%
            );
            border-radius: 3px;
        }

        .bathy-labels {
            display: flex;
            justify-content: space-between;
            width: 150px;
            font-size: 0.55rem;
            color: rgba(255,255,255,0.6);
            margin-top: 2px;
        }

        .sst-legend {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(0,0,0,0.8);
            padding: 8px 12px;
            border-radius: 8px;
            z-index: 1000;
            display: none;
        }

        .sst-gradient {
            width: 120px;
            height: 12px;
            background: linear-gradient(90deg,
                #313695 0%,
                #4575b4 15%,
                #74add1 30%,
                #abd9e9 45%,
                #fee090 60%,
                #fdae61 75%,
                #f46d43 90%,
                #a50026 100%
            );
            border-radius: 3px;
        }

        .sst-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.55rem;
            color: rgba(255,255,255,0.6);
            margin-top: 2px;
        }

        /* Légende isobathes */
        .contours-legend {
            position: absolute;
            top: 80px;
            right: 70px;
            background: rgba(0,0,0,0.85);
            padding: 10px 12px;
            border-radius: 8px;
            z-index: 1000;
            display: none;
        }

        .contour-items {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .contour-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.65rem;
            color: rgba(255,255,255,0.8);
        }

        .contour-line {
            width: 20px;
            height: 3px;
            border-radius: 1px;
        }

        /* Contrôles de couches */
        .layer-controls {
            position: absolute;
            top: 55px;
            left: 15px;
            z-index: 1001;
            display: none;
            flex-direction: column;
            gap: 5px;
            background: rgba(0,0,0,0.85);
            padding: 12px;
            border-radius: 10px;
            max-width: 220px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .layer-control-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 5px;
        }

        .layer-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 0;
            cursor: pointer;
            font-size: 0.7rem;
            color: rgba(255,255,255,0.8);
            transition: all 0.2s;
        }

        .layer-toggle:hover {
            color: white;
        }

        .layer-toggle input {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .layer-toggle.disabled {
            opacity: 0.4;
            pointer-events: none;
        }

        /* Info bulle sur la carte */
        .map-info-box {
            position: absolute;
            bottom: 60px;
            left: 15px;
            background: rgba(0,0,0,0.85);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.75rem;
            z-index: 1001;
            display: none;
            max-width: 250px;
        }

        .marine-chart-container.fullscreen .map-info-box {
            display: block;
        }

        .map-info-box .coords {
            font-family: 'SF Mono', monospace;
            color: var(--accent-blue);
        }

        .map-info-box .depth-scale {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-top: 8px;
        }

        .depth-gradient {
            width: 100px;
            height: 12px;
            background: linear-gradient(90deg, #a8e6cf 0%, #56ab91 25%, #1abc9c 50%, #0a5c4a 75%, #023020 100%);
            border-radius: 3px;
        }

        .depth-labels {
            display: flex;
            justify-content: space-between;
            width: 100px;
            font-size: 0.6rem;
            color: rgba(255,255,255,0.5);
            margin-top: 2px;
        }

        .map-info-box .info-coords {
            margin-bottom: 5px;
        }

        .map-info-box .info-zoom {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.6);
        }

        .map-info-box .info-sources {
            font-size: 0.6rem;
            color: rgba(255,255,255,0.4);
            margin-top: 5px;
            border-top: 1px solid rgba(255,255,255,0.1);
            padding-top: 5px;
        }

        /* Légende détaillée (fullscreen) */
        .map-legend-detailed {
            position: absolute;
            bottom: 70px;
            right: 15px;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 10px;
            font-size: 0.7rem;
            z-index: 1001;
            display: none;
            max-width: 280px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .marine-chart-container.fullscreen .map-legend-detailed {
            display: block;
        }

        .marine-chart-container.fullscreen .map-legend-detailed.hidden {
            display: none;
        }

        .marine-chart-container.fullscreen .layer-controls.hidden {
            display: none;
        }

        .panel-toggle-btn {
            font-size: 0.8rem !important;
        }

        /* Boutons toggle positionnés différemment */
        #toggleLeftPanel {
            position: absolute;
            left: 240px;
            top: 55px;
        }

        #toggleRightPanel {
            position: absolute;
            right: 300px;
            top: 55px;
        }

        .marine-chart-container:not(.fullscreen) #toggleLeftPanel,
        .marine-chart-container:not(.fullscreen) #toggleRightPanel {
            display: none;
        }

        .marine-chart-container.fullscreen #toggleLeftPanel,
        .marine-chart-container.fullscreen #toggleRightPanel {
            display: flex;
        }

        .marine-chart-container.fullscreen .layer-controls.hidden ~ #toggleLeftPanel {
            left: 15px;
        }

        .marine-chart-container.fullscreen .map-legend-detailed.hidden ~ #toggleRightPanel {
            right: 15px;
        }

        .legend-section {
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .legend-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .legend-section-title {
            font-weight: 600;
            color: white;
            margin-bottom: 6px;
            font-size: 0.75rem;
        }

        .legend-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 3px 0;
            color: rgba(255,255,255,0.8);
        }

        .legend-icon {
            width: 20px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .legend-icon.cardinal-n { background: linear-gradient(180deg, #f1c40f 50%, #000 50%); color: #000; }
        .legend-icon.cardinal-s { background: linear-gradient(180deg, #000 50%, #f1c40f 50%); color: #f1c40f; }
        .legend-icon.cardinal-e { background: linear-gradient(180deg, #000 33%, #f1c40f 33%, #f1c40f 66%, #000 66%); color: #f1c40f; }
        .legend-icon.cardinal-w { background: linear-gradient(180deg, #f1c40f 33%, #000 33%, #000 66%, #f1c40f 66%); color: #000; }

        .legend-icon.light-white { color: #fff; text-shadow: 0 0 5px #fff; background: rgba(255,255,255,0.2); }
        .legend-icon.light-red { color: #e74c3c; text-shadow: 0 0 5px #e74c3c; background: rgba(231,76,60,0.2); }
        .legend-icon.light-green { color: #27ae60; text-shadow: 0 0 5px #27ae60; background: rgba(39,174,96,0.2); }
        .legend-icon.light-yellow { color: #f1c40f; text-shadow: 0 0 5px #f1c40f; background: rgba(241,196,15,0.2); }

        .legend-icon.port-icon { background: #3498db; color: white; }
        .legend-icon.anchor-icon { background: #9b59b6; color: white; }
        .legend-icon.fuel-icon { background: #e67e22; color: white; }
        .legend-icon.repair-icon { background: #7f8c8d; color: white; }

        .legend-icon.danger-icon { background: #c0392b; color: white; }
        .legend-icon.rock-icon { background: #34495e; color: #e74c3c; }
        .legend-icon.restricted-icon { background: rgba(231,76,60,0.3); border: 1px dashed #e74c3c; color: #e74c3c; }
        .legend-icon.cable-icon { background: #f39c12; color: #000; }

        .legend-icon.lane-icon { background: rgba(52,152,219,0.3); border: 1px solid #3498db; color: #3498db; }
        .legend-icon.separation-icon { background: rgba(155,89,182,0.3); color: #9b59b6; }

        .depth-gradient-large {
            width: 100%;
            height: 16px;
            background: linear-gradient(90deg,
                #b8e6ff 0%,      /* 0m - très clair */
                #7fcdff 10%,     /* 2m */
                #4db8ff 20%,     /* 5m */
                #1a9fff 30%,     /* 10m */
                #0077cc 45%,     /* 20m */
                #005599 60%,     /* 50m */
                #003366 80%,     /* 100m */
                #001a33 100%     /* 200m+ */
            );
            border-radius: 4px;
            margin: 8px 0 4px;
        }

        .depth-labels-large {
            display: flex;
            justify-content: space-between;
            font-size: 0.6rem;
            color: rgba(255,255,255,0.5);
        }

        /* Sea State */
        .sea-state-bar {
            height: 6px;
            background: linear-gradient(to right, #00b894, #fdcb6e, #e17055, #d63031, #6c5ce7);
            border-radius: 3px;
            position: relative;
            margin: 15px 0 8px;
        }

        .sea-state-marker {
            position: absolute;
            top: -5px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transform: translateX(-50%);
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: left 0.5s;
        }

        .sea-state-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.65rem;
            opacity: 0.6;
        }

        /* Safety Alert */
        .safety-alert {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .safety-alert.safe {
            background: rgba(46,204,113,0.15);
            border: 1px solid rgba(46,204,113,0.3);
        }

        .safety-alert.warning {
            background: rgba(241,196,15,0.15);
            border: 1px solid rgba(241,196,15,0.3);
        }

        .safety-alert.danger {
            background: rgba(231,76,60,0.15);
            border: 1px solid rgba(231,76,60,0.3);
        }

        .safety-icon {
            font-size: 1.3rem;
        }

        .safety-text .title {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .safety-text .desc {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 4px;
            background: rgba(0,0,0,0.3);
            padding: 4px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .tab-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: transparent;
            color: rgba(255,255,255,0.6);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab-btn.active {
            background: rgba(255,255,255,0.1);
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Loading */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 300px;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 12px;
            font-size: 0.9rem;
            opacity: 0.7;
        }

        /* Daily Forecast */
        .daily-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background: rgba(255,255,255,0.03);
            border-radius: 8px;
            margin-bottom: 6px;
        }

        .daily-day {
            width: 50px;
            font-size: 0.8rem;
        }

        .daily-icon {
            font-size: 1.2rem;
            margin-right: 8px;
        }

        .daily-temps {
            flex: 1;
            display: flex;
            gap: 8px;
            font-size: 0.85rem;
        }

        .daily-high {
            font-weight: 600;
        }

        .daily-low {
            opacity: 0.5;
        }

        .daily-wind {
            font-size: 0.75rem;
            color: var(--accent-blue);
            width: 60px;
            text-align: right;
        }

        .daily-gust {
            font-size: 0.7rem;
            color: var(--accent-orange);
            width: 50px;
            text-align: right;
        }

        /* Error message */
        .error-message {
            background: rgba(231,76,60,0.2);
            border: 1px solid rgba(231,76,60,0.4);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }

        .error-message .icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .error-message .text {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .retry-btn {
            margin-top: 10px;
            padding: 8px 20px;
            background: rgba(231,76,60,0.3);
            border: 1px solid rgba(231,76,60,0.5);
            border-radius: 6px;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
        }

        .retry-btn:hover {
            background: rgba(231,76,60,0.5);
        }

        /* Last update */
        .last-update {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.4);
            text-align: right;
            margin-top: 10px;
        }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 16px;
            padding: 25px;
            width: 90%;
            max-width: 500px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            opacity: 0.7;
        }

        .modal-close:hover {
            opacity: 1;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-label {
            display: block;
            font-size: 0.85rem;
            margin-bottom: 6px;
            color: rgba(255,255,255,0.8);
        }

        .form-input {
            width: 100%;
            padding: 12px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 0.9rem;
            outline: none;
        }

        .form-input:focus {
            border-color: var(--accent-blue);
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .form-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }

        .form-checkbox input {
            width: 18px;
            height: 18px;
        }

        .btn-primary {
            width: 100%;
            padding: 12px;
            background: var(--accent-blue);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary:hover {
            background: #0096c7;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .header {
                flex-direction: column;
                align-items: stretch;
            }

            .search-input {
                width: 100%;
            }

            .search-container {
                flex-wrap: wrap;
            }

            .control-bar {
                flex-direction: column;
                align-items: stretch;
                padding: 10px;
            }

            .control-group {
                flex-wrap: wrap;
            }

            .unit-selector {
                flex-wrap: wrap;
            }

            .current-weather {
                flex-direction: column;
                text-align: center;
            }

            .wind-particles-container {
                height: 120px;
            }

            .wind-particles-overlay {
                padding: 8px 10px;
            }

            .wind-data-speed {
                font-size: 1.8rem;
            }

            .marine-grid, .port-grid, .tides-times {
                grid-template-columns: 1fr;
            }

            .details-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* ============== COMPAS WIDGET ============== */
        .compass-widget {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            background: rgba(0,0,0,0.7);
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.2);
            z-index: 100;
            cursor: pointer;
            transition: all 0.3s;
        }

        .compass-widget:hover {
            transform: scale(1.1);
            border-color: var(--accent-blue);
        }

        .compass-widget svg {
            width: 100%;
            height: 100%;
        }

        .compass-widget .compass-needle {
            transition: transform 0.5s ease-out;
        }

        /* ============== MODE EPHEMERIDE ============== */
        .ephemeride-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }

        .ephemeride-card {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 20px;
        }

        .ephemeride-card-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sun-arc {
            width: 100%;
            height: 120px;
            position: relative;
            margin: 15px 0;
        }

        .sun-arc-path {
            fill: none;
            stroke: rgba(241,196,15,0.3);
            stroke-width: 3;
        }

        .sun-arc-progress {
            fill: none;
            stroke: #f1c40f;
            stroke-width: 4;
            stroke-linecap: round;
        }

        .sun-position {
            fill: #f1c40f;
            filter: drop-shadow(0 0 8px rgba(241,196,15,0.8));
        }

        .moon-phase {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            margin: 0 auto 15px;
            position: relative;
            background: #1a1a2e;
            overflow: hidden;
        }

        .moon-illumination {
            position: absolute;
            top: 0;
            height: 100%;
            background: linear-gradient(90deg, #f5f5f5 0%, #e0e0e0 100%);
            border-radius: 50%;
        }

        .ephemeride-times {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .ephemeride-time-item {
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .ephemeride-time-label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            margin-bottom: 4px;
        }

        .ephemeride-time-value {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .countdown-item {
            background: linear-gradient(135deg, rgba(241,196,15,0.2), rgba(230,126,34,0.2));
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin: 10px 0;
        }

        .countdown-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #f1c40f;
        }

        .countdown-label {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.6);
        }

        /* Conditions pêche */
        .fishing-conditions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .fishing-condition-item {
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-radius: 10px;
            text-align: center;
        }

        .fishing-condition-icon {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }

        .fishing-condition-label {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.5);
            margin-bottom: 3px;
        }

        .fishing-condition-value {
            font-size: 0.85rem;
            font-weight: 600;
        }

        .fishing-score {
            text-align: center;
            padding: 20px;
            margin: 15px 0;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
        }

        .fishing-score-value {
            font-size: 3rem;
            font-weight: 700;
        }

        .fishing-score-label {
            font-size: 0.85rem;
            color: rgba(255,255,255,0.6);
        }

        .fishing-score.excellent .fishing-score-value { color: #2ecc71; }
        .fishing-score.good .fishing-score-value { color: #27ae60; }
        .fishing-score.moderate .fishing-score-value { color: #f1c40f; }
        .fishing-score.poor .fishing-score-value { color: #e67e22; }
        .fishing-score.bad .fishing-score-value { color: #e74c3c; }

        /* ============== MODE PECHE (Carte) ============== */
        .fishing-map-container {
            position: relative;
            width: 100%;
            height: 500px;
            border-radius: 12px;
            overflow: hidden;
            background: #1a1a2e;
        }

        .fishing-map-container.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            border-radius: 0;
            z-index: 9999;
        }

        .water-level-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            margin: 5px 0;
        }

        .water-level-bar {
            flex: 1;
            height: 20px;
            background: linear-gradient(90deg,
                #2ecc71 0%,
                #f1c40f 50%,
                #e67e22 75%,
                #e74c3c 100%
            );
            border-radius: 4px;
            position: relative;
        }

        .water-level-marker {
            position: absolute;
            top: -5px;
            width: 4px;
            height: 30px;
            background: white;
            border-radius: 2px;
            transform: translateX(-50%);
        }

        .water-level-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.6rem;
            color: rgba(255,255,255,0.5);
            margin-top: 3px;
        }

        /* Alertes crues */
        .flood-alert {
            padding: 12px 15px;
            border-radius: 10px;
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .flood-alert.green { background: rgba(46,204,113,0.2); border-left: 4px solid #2ecc71; }
        .flood-alert.yellow { background: rgba(241,196,15,0.2); border-left: 4px solid #f1c40f; }
        .flood-alert.orange { background: rgba(230,126,34,0.2); border-left: 4px solid #e67e22; }
        .flood-alert.red { background: rgba(231,76,60,0.2); border-left: 4px solid #e74c3c; }

        .flood-alert-icon {
            font-size: 1.5rem;
        }

        .flood-alert-text {
            flex: 1;
        }

        .flood-alert-title {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .flood-alert-desc {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.7);
        }

        /* Débit rivière */
        .river-flow-chart {
            width: 100%;
            height: 100px;
            margin: 10px 0;
        }

        .station-info {
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-radius: 10px;
            margin: 8px 0;
        }

        .station-name {
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 8px;
        }

        .station-data {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .station-data-item {
            text-align: center;
        }

        .station-data-value {
            font-size: 1.2rem;
            font-weight: 700;
        }

        .station-data-label {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.5);
        }

        /* Solunar */
        .solunar-chart {
            display: flex;
            align-items: flex-end;
            height: 60px;
            gap: 2px;
            margin: 15px 0;
        }

        .solunar-bar {
            flex: 1;
            background: rgba(52,152,219,0.3);
            border-radius: 2px 2px 0 0;
            position: relative;
        }

        .solunar-bar.major {
            background: linear-gradient(to top, rgba(46,204,113,0.5), rgba(46,204,113,0.8));
        }

        .solunar-bar.minor {
            background: linear-gradient(to top, rgba(241,196,15,0.3), rgba(241,196,15,0.6));
        }

        .solunar-bar.current {
            border: 2px solid #fff;
        }
    </style>
</head>
<body>
    <!-- Offline Banner -->
    <div class="offline-banner" id="offlineBanner">
        <span class="offline-icon">📡</span>
        <span>Mode hors-ligne - Données en cache</span>
        <span class="offline-time" id="offlineTime"></span>
    </div>

    <div class="app-container">
        <header class="header">
            <div class="logo">
                <span class="logo-icon" id="logoIcon">🌊</span>
                <span>Jmee Weather Station</span>
            </div>

            <div class="mode-toggle">
                <button class="mode-btn active" data-mode="weather" id="weatherModeBtn">🌍 Terrestre</button>
                <button class="mode-btn" data-mode="marine" id="marineModeBtn">⚓ Marine</button>
                <button class="mode-btn" data-mode="ephemeride" id="ephemerideModeBtn">🌙 Éphéméride</button>
                <button class="mode-btn" data-mode="fishing" id="fishingModeBtn">🎣 Pêche</button>
            </div>

            <div class="search-container">
                <input type="text" class="search-input" id="searchInput" placeholder="Ville, port, zone...">
                <button class="btn btn-icon" id="searchBtn">🔍</button>
                <button class="btn btn-icon" id="locationBtn" title="Ma position">📍</button>
                <button class="btn btn-icon btn-add" id="addFavoriteBtn" title="Ajouter aux favoris">⭐</button>
            </div>

            <div class="location-badge" id="locationBadge">
                <span class="dot"></span>
                <span id="locationText">Localisation...</span>
            </div>

            <div class="api-status" id="apiStatus">
                <span class="status-dot"></span>
                <span id="apiStatusText">API Live</span>
            </div>
        </header>

        <div class="control-bar">
            <div class="control-group">
                <span class="control-label">Modèle</span>
                <select class="control-select" id="modelSelect">
                    <option value="arome_france_hd">AROME HD (500m) ⭐</option>
                    <option value="arome_france">AROME (1.3km)</option>
                    <option value="arpege_europe">ARPÈGE Europe (10km)</option>
                    <option value="ecmwf_ifs025">ECMWF IFS (25km)</option>
                    <option value="gfs_seamless">GFS (25km)</option>
                    <option value="icon_seamless">ICON (7km)</option>
                </select>
            </div>

            <div class="control-group">
                <span class="control-label">Vent</span>
                <div class="unit-selector" id="windUnitSelector">
                    <button class="unit-btn active" data-unit="kmh">km/h</button>
                    <button class="unit-btn" data-unit="kt">kt</button>
                    <button class="unit-btn" data-unit="ms">m/s</button>
                    <button class="unit-btn" data-unit="bft">Bft</button>
                </div>
            </div>

            <div class="control-group">
                <span class="control-label">Temp</span>
                <div class="unit-selector" id="tempUnitSelector">
                    <button class="unit-btn active" data-unit="celsius">°C</button>
                    <button class="unit-btn" data-unit="fahrenheit">°F</button>
                </div>
            </div>

            <div class="control-group" id="waveUnitGroup" style="display:none">
                <span class="control-label">Vagues</span>
                <div class="unit-selector" id="waveUnitSelector">
                    <button class="unit-btn active" data-unit="m">m</button>
                    <button class="unit-btn" data-unit="ft">ft</button>
                </div>
            </div>

            <div class="control-group">
                <span class="control-label">Pression</span>
                <div class="unit-selector" id="pressureUnitSelector">
                    <button class="unit-btn active" data-unit="hpa">hPa</button>
                    <button class="unit-btn" data-unit="inhg">inHg</button>
                </div>
            </div>
        </div>

        <div class="favorites-section">
            <div class="favorites-header">
                <div class="favorites-title">⭐ Favoris</div>
            </div>
            <div class="favorites-row" id="favoritesRow"></div>
        </div>

        <main id="mainContent">
            <div class="loading">
                <div class="loading-spinner"></div>
                <p class="loading-text">Géolocalisation en cours...</p>
            </div>
        </main>
    </div>

    <!-- Modal Ajouter Favori -->
    <div class="modal-overlay" id="addFavoriteModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">⭐ Ajouter aux favoris</h3>
                <button class="modal-close" id="closeModal">&times;</button>
            </div>
            <form id="addFavoriteForm">
                <div class="form-group">
                    <label class="form-label">Nom du lieu</label>
                    <input type="text" class="form-input" id="favName" placeholder="Ex: Brest, Port de Marseille..." required>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Latitude</label>
                        <input type="number" step="0.0001" class="form-input" id="favLat" placeholder="48.3904" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Longitude</label>
                        <input type="number" step="0.0001" class="form-input" id="favLon" placeholder="-4.4861" required>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Emoji (optionnel)</label>
                    <input type="text" class="form-input" id="favEmoji" placeholder="🌊" maxlength="2">
                </div>
                <div class="form-group">
                    <label class="form-checkbox">
                        <input type="checkbox" id="favIsPort">
                        <span>C'est un port (afficher infos portuaires)</span>
                    </label>
                </div>
                <div class="form-group">
                    <label class="form-checkbox">
                        <input type="checkbox" id="favIsCoastal" checked>
                        <span>Zone côtière (données marines disponibles)</span>
                    </label>
                </div>
                <button type="submit" class="btn-primary">Ajouter aux favoris</button>
            </form>
        </div>
    </div>

    <script>
        // État de l'application
        const state = {
            currentCity: null,
            currentCoords: null,
            mode: 'weather',
            model: 'arome_france_hd',
            actualModel: null, // Modèle réellement utilisé (peut différer si hors zone)
            units: {
                wind: 'kmh',
                temp: 'celsius',
                wave: 'm',
                pressure: 'hpa'
            },
            weatherData: null,
            marineData: null,
            tidesData: null,
            isLoading: true,
            lastUpdate: null,
            apiError: false,
            favorites: [],
            selectedDay: 0 // 0 = aujourd'hui, 1 = demain, etc. (0-6)
        };

        // Favoris par défaut
        const defaultFavorites = [
            { name: 'Paris', lat: 48.8566, lon: 2.3522, emoji: '🗼', isPort: false, isCoastal: false },
            { name: 'Marseille', lat: 43.2965, lon: 5.3698, emoji: '⚓', isPort: true, isCoastal: true },
            { name: 'Brest', lat: 48.3904, lon: -4.4861, emoji: '🌊', isPort: true, isCoastal: true },
            { name: 'Nice', lat: 43.7102, lon: 7.2620, emoji: '☀️', isPort: true, isCoastal: true },
            { name: 'La Rochelle', lat: 46.1603, lon: -1.1511, emoji: '⛵', isPort: true, isCoastal: true },
            { name: 'Saint-Malo', lat: 48.6493, lon: -2.0076, emoji: '🏴‍☠️', isPort: true, isCoastal: true }
        ];

        // Zones marines Météo-France officielles
        const marineZones = {
            // Manche - Mer du Nord
            'pas-de-calais': { name: 'Pas-de-Calais', region: 'Manche - Mer du Nord', coords: { lat: 50.9, lon: 1.8 } },
            'antifer': { name: 'Antifer', region: 'Manche - Mer du Nord', coords: { lat: 49.6, lon: 0.1 } },
            'casquets': { name: 'Casquets', region: 'Manche', coords: { lat: 49.7, lon: -2.2 } },
            'ouessant': { name: 'Ouessant', region: 'Manche', coords: { lat: 48.5, lon: -5.1 } },
            // Atlantique
            'iroise': { name: 'Iroise', region: 'Atlantique', coords: { lat: 48.2, lon: -5.0 } },
            'yeu': { name: 'Yeu', region: 'Atlantique', coords: { lat: 46.7, lon: -2.3 } },
            'rochebonne': { name: 'Rochebonne', region: 'Atlantique', coords: { lat: 46.2, lon: -2.4 } },
            'cantabrico': { name: 'Cantabrico', region: 'Atlantique', coords: { lat: 44.0, lon: -3.0 } },
            'finisterre': { name: 'Finisterre', region: 'Atlantique', coords: { lat: 43.0, lon: -9.5 } },
            // Méditerranée
            'lion': { name: 'Golfe du Lion', region: 'Méditerranée', coords: { lat: 42.5, lon: 4.0 } },
            'provence': { name: 'Provence', region: 'Méditerranée', coords: { lat: 43.0, lon: 6.0 } },
            'ligure': { name: 'Ligure', region: 'Méditerranée', coords: { lat: 43.5, lon: 8.5 } },
            'corse': { name: 'Côtes Corses', region: 'Méditerranée', coords: { lat: 42.0, lon: 9.0 } },
            'sardaigne': { name: 'Sardaigne', region: 'Méditerranée', coords: { lat: 40.5, lon: 8.5 } }
        };

        // Groupes de zones par région
        const marineRegions = {
            'manche': {
                name: 'Manche - Mer du Nord',
                zones: ['pas-de-calais', 'antifer', 'casquets', 'ouessant'],
                icon: '🌊'
            },
            'atlantique': {
                name: 'Atlantique',
                zones: ['iroise', 'yeu', 'rochebonne', 'cantabrico', 'finisterre'],
                icon: '🌊'
            },
            'mediterranee': {
                name: 'Méditerranée',
                zones: ['lion', 'provence', 'ligure', 'corse', 'sardaigne'],
                icon: '☀️'
            }
        };

        // Zone sélectionnée pour le bulletin
        let selectedMarineZone = 'lion';

        // Ports français avec informations
        const portsInfo = {
            'Marseille': { vhf: '12', tidalRange: 'faible', harbor: 'Vieux-Port', facilities: ['Carburant', 'Eau', 'Électricité', 'Sanitaires'] },
            'Brest': { vhf: '16', tidalRange: 'fort', harbor: 'Port de Commerce', facilities: ['Carburant', 'Eau', 'Électricité', 'Grue'] },
            'Nice': { vhf: '09', tidalRange: 'faible', harbor: 'Port Lympia', facilities: ['Carburant', 'Eau', 'Électricité', 'Sanitaires'] },
            'La Rochelle': { vhf: '09', tidalRange: 'fort', harbor: 'Les Minimes', facilities: ['Carburant', 'Eau', 'Électricité', 'Shipchandler'] },
            'Saint-Malo': { vhf: '09', tidalRange: 'très fort', harbor: 'Port des Sablons', facilities: ['Carburant', 'Eau', 'Électricité', 'Grue'] }
        };

        // Configuration des modèles météo
        const models = {
            arome_france_hd: { name: 'AROME HD', resolution: '500m', range: '48h', update: '1h', provider: 'Météo-France', api: 'meteofrance', isHD: true },
            arome_france: { name: 'AROME', resolution: '1.3km', range: '48h', update: '3h', provider: 'Météo-France', api: 'meteofrance', isHD: false },
            arpege_europe: { name: 'ARPÈGE', resolution: '10km', range: '4j', update: '6h', provider: 'Météo-France', api: 'meteofrance', isHD: false },
            ecmwf_ifs025: { name: 'ECMWF IFS', resolution: '25km', range: '10j', update: '6h', provider: 'ECMWF', api: 'ecmwf', isHD: false },
            gfs_seamless: { name: 'GFS', resolution: '25km', range: '16j', update: '6h', provider: 'NOAA', api: 'gfs', isHD: false },
            icon_seamless: { name: 'ICON', resolution: '7km', range: '7j', update: '6h', provider: 'DWD', api: 'icon', isHD: false }
        };

        // Codes météo WMO
        const weatherCodes = {
            0: { icon: '☀️', desc: 'Ciel dégagé' }, 1: { icon: '🌤️', desc: 'Principalement dégagé' },
            2: { icon: '⛅', desc: 'Partiellement nuageux' }, 3: { icon: '☁️', desc: 'Couvert' },
            45: { icon: '🌫️', desc: 'Brouillard' }, 48: { icon: '🌫️', desc: 'Brouillard givrant' },
            51: { icon: '🌦️', desc: 'Bruine légère' }, 53: { icon: '🌦️', desc: 'Bruine modérée' },
            55: { icon: '🌧️', desc: 'Bruine dense' }, 61: { icon: '🌧️', desc: 'Pluie légère' },
            63: { icon: '🌧️', desc: 'Pluie modérée' }, 65: { icon: '🌧️', desc: 'Pluie forte' },
            71: { icon: '🌨️', desc: 'Neige légère' }, 73: { icon: '🌨️', desc: 'Neige modérée' },
            75: { icon: '❄️', desc: 'Neige forte' }, 80: { icon: '🌦️', desc: 'Averses légères' },
            81: { icon: '🌧️', desc: 'Averses modérées' }, 82: { icon: '⛈️', desc: 'Averses violentes' },
            95: { icon: '⛈️', desc: 'Orage' }, 96: { icon: '⛈️', desc: 'Orage avec grêle' }
        };

        // États de la mer (Douglas)
        const seaStates = [
            { name: 'Calme', desc: 'Mer d\'huile', maxHeight: 0 },
            { name: 'Ridée', desc: 'Vaguelettes', maxHeight: 0.1 },
            { name: 'Belle', desc: 'Petites vagues', maxHeight: 0.5 },
            { name: 'Peu agitée', desc: 'Vagues modérées', maxHeight: 1.25 },
            { name: 'Agitée', desc: 'Vagues fortes', maxHeight: 2.5 },
            { name: 'Forte', desc: 'Grosses vagues', maxHeight: 4 },
            { name: 'Très forte', desc: 'Très grosses vagues', maxHeight: 6 },
            { name: 'Grosse', desc: 'Vagues énormes', maxHeight: 9 },
            { name: 'Très grosse', desc: 'Déferlantes', maxHeight: 14 },
            { name: 'Énorme', desc: 'Phénoménale', maxHeight: Infinity }
        ];

        // Charger les favoris depuis localStorage
        function loadFavorites() {
            const saved = localStorage.getItem('meteoAppFavorites');
            if (saved) {
                state.favorites = JSON.parse(saved);
            } else {
                state.favorites = [...defaultFavorites];
                saveFavorites();
            }
            renderFavorites();
        }

        // Sauvegarder les favoris
        function saveFavorites() {
            localStorage.setItem('meteoAppFavorites', JSON.stringify(state.favorites));
        }

        // Sauvegarder les préférences utilisateur
        function savePreferences() {
            const prefs = {
                units: state.units,
                mode: state.mode,
                model: state.model,
                lastLocation: state.currentCoords ? {
                    lat: state.currentCoords.lat,
                    lon: state.currentCoords.lon,
                    name: state.currentCity,
                    isPort: state.currentIsPort || false
                } : null
            };
            localStorage.setItem('meteoAppPreferences', JSON.stringify(prefs));
        }

        // ========== MODE OFFLINE ==========
        let isOnline = navigator.onLine;
        let lastDataTimestamp = null;

        function initOfflineMode() {
            // Écouter les changements de connexion
            window.addEventListener('online', handleOnline);
            window.addEventListener('offline', handleOffline);

            // Vérifier l'état initial
            if (!navigator.onLine) {
                handleOffline();
            }

            // Enregistrer le Service Worker si supporté
            if ('serviceWorker' in navigator) {
                registerServiceWorker();
            }
        }

        async function registerServiceWorker() {
            try {
                // Créer le Service Worker dynamiquement (inline)
                const swCode = `
                    const CACHE_NAME = 'jmee-weather-v1';
                    const STATIC_ASSETS = [
                        './',
                        './jmeeweather.html',
                        'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css',
                        'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js'
                    ];

                    // Installation - mise en cache des assets statiques
                    self.addEventListener('install', event => {
                        event.waitUntil(
                            caches.open(CACHE_NAME).then(cache => {
                                return cache.addAll(STATIC_ASSETS);
                            })
                        );
                        self.skipWaiting();
                    });

                    // Activation - nettoyage des anciens caches
                    self.addEventListener('activate', event => {
                        event.waitUntil(
                            caches.keys().then(keys => {
                                return Promise.all(
                                    keys.filter(key => key !== CACHE_NAME)
                                        .map(key => caches.delete(key))
                                );
                            })
                        );
                        self.clients.claim();
                    });

                    // Fetch - stratégie Network First avec fallback cache
                    self.addEventListener('fetch', event => {
                        // Ignorer les requêtes non-GET
                        if (event.request.method !== 'GET') return;

                        event.respondWith(
                            fetch(event.request)
                                .then(response => {
                                    // Mettre en cache la réponse
                                    const responseClone = response.clone();
                                    caches.open(CACHE_NAME).then(cache => {
                                        cache.put(event.request, responseClone);
                                    });
                                    return response;
                                })
                                .catch(() => {
                                    // Fallback sur le cache
                                    return caches.match(event.request);
                                })
                        );
                    });
                `;

                const blob = new Blob([swCode], { type: 'application/javascript' });
                const swUrl = URL.createObjectURL(blob);

                // Note: Pour un vrai déploiement, le SW doit être dans un fichier séparé
                // Pour l'instant, on utilise uniquement le cache localStorage
                console.log('Service Worker: Mode localStorage activé');
            } catch (e) {
                console.warn('Service Worker non disponible:', e);
            }
        }

        function handleOnline() {
            isOnline = true;
            document.body.classList.remove('offline-mode');
            document.getElementById('offlineBanner').classList.remove('show');

            // Mettre à jour le statut API
            const apiStatus = document.getElementById('apiStatus');
            if (apiStatus) {
                apiStatus.classList.remove('offline');
            }

            // Rafraîchir les données automatiquement
            if (state.currentCoords) {
                console.log('Connexion rétablie - Actualisation des données...');
                loadWeatherForCoords(state.currentCoords.lat, state.currentCoords.lon, state.currentCity);
            }
        }

        function handleOffline() {
            isOnline = false;
            document.body.classList.add('offline-mode');

            const banner = document.getElementById('offlineBanner');
            banner.classList.add('show');

            // Afficher l'heure des dernières données
            updateOfflineTime();

            // Mettre à jour le statut API
            const apiStatus = document.getElementById('apiStatus');
            const apiStatusText = document.getElementById('apiStatusText');
            if (apiStatus) {
                apiStatus.classList.add('offline');
            }
            if (apiStatusText) {
                apiStatusText.textContent = 'Mode hors-ligne';
            }

            // Charger les données en cache
            loadCachedData();
        }

        function updateOfflineTime() {
            const timeEl = document.getElementById('offlineTime');
            if (timeEl && lastDataTimestamp) {
                const diff = Date.now() - lastDataTimestamp;
                const minutes = Math.floor(diff / 60000);
                const hours = Math.floor(minutes / 60);

                if (hours > 0) {
                    timeEl.textContent = `(données de ${hours}h${minutes % 60}min)`;
                } else if (minutes > 0) {
                    timeEl.textContent = `(données de ${minutes}min)`;
                } else {
                    timeEl.textContent = '(données récentes)';
                }
            }
        }

        // Sauvegarder les données météo en cache
        function cacheWeatherData() {
            if (!state.weatherData || !state.currentCoords) return;

            const cacheData = {
                timestamp: Date.now(),
                coords: state.currentCoords,
                city: state.currentCity,
                isPort: state.currentIsPort,
                weatherData: state.weatherData,
                marineData: state.marineData,
                tidesData: state.tidesData,
                model: state.model,
                actualModel: state.actualModel
            };

            try {
                localStorage.setItem('meteoAppWeatherCache', JSON.stringify(cacheData));
                lastDataTimestamp = cacheData.timestamp;
                console.log('Données météo mises en cache');
            } catch (e) {
                console.warn('Erreur cache localStorage:', e);
                // Essayer de libérer de l'espace
                try {
                    localStorage.removeItem('meteoAppWeatherCache');
                    localStorage.setItem('meteoAppWeatherCache', JSON.stringify(cacheData));
                } catch (e2) {
                    console.error('Impossible de mettre en cache:', e2);
                }
            }
        }

        // Charger les données depuis le cache
        function loadCachedData() {
            try {
                const cached = localStorage.getItem('meteoAppWeatherCache');
                if (!cached) {
                    showError('Aucune donnée en cache disponible. Connectez-vous à Internet.');
                    return false;
                }

                const cacheData = JSON.parse(cached);
                lastDataTimestamp = cacheData.timestamp;

                // Restaurer l'état
                state.currentCoords = cacheData.coords;
                state.currentCity = cacheData.city;
                state.currentIsPort = cacheData.isPort;
                state.weatherData = cacheData.weatherData;
                state.marineData = cacheData.marineData;
                state.tidesData = cacheData.tidesData;
                state.actualModel = cacheData.actualModel;
                state.lastUpdate = new Date(cacheData.timestamp);

                // Mettre à jour l'interface
                const locationText = document.getElementById('locationText');
                if (locationText) {
                    locationText.textContent = cacheData.city || 'Position';
                }

                // Afficher les données
                renderCurrentView();

                // Afficher l'indicateur de cache
                showCacheIndicator();

                console.log('Données chargées depuis le cache');
                return true;
            } catch (e) {
                console.error('Erreur chargement cache:', e);
                return false;
            }
        }

        function showCacheIndicator() {
            if (!lastDataTimestamp) return;

            const diff = Date.now() - lastDataTimestamp;
            const minutes = Math.floor(diff / 60000);

            let className = 'cache-indicator';
            let text = '';

            if (minutes < 30) {
                className += ' fresh';
                text = '✓ Données récentes';
            } else if (minutes < 120) {
                className += ' stale';
                text = `⚠ Données de ${minutes}min`;
            } else {
                className += ' old';
                const hours = Math.floor(minutes / 60);
                text = `⚠ Données de ${hours}h`;
            }

            // Ajouter l'indicateur près du statut API
            const apiStatus = document.getElementById('apiStatus');
            if (apiStatus) {
                let indicator = document.getElementById('cacheIndicator');
                if (!indicator) {
                    indicator = document.createElement('span');
                    indicator.id = 'cacheIndicator';
                    apiStatus.parentNode.insertBefore(indicator, apiStatus.nextSibling);
                }
                indicator.className = className;
                indicator.textContent = text;
            }
        }

        // Vérifier si on peut utiliser le réseau
        function canUseNetwork() {
            return navigator.onLine;
        }

        // Charger les préférences utilisateur
        function loadPreferences() {
            const saved = localStorage.getItem('meteoAppPreferences');
            if (saved) {
                try {
                    const prefs = JSON.parse(saved);
                    // Restaurer les unités
                    if (prefs.units) {
                        state.units = { ...state.units, ...prefs.units };
                        // Mettre à jour l'UI des sélecteurs d'unités
                        updateUnitSelectorsUI();
                    }
                    // Restaurer le mode
                    if (prefs.mode) {
                        state.mode = prefs.mode;
                        updateModeUI();
                    }
                    // Restaurer le modèle
                    if (prefs.model) {
                        state.model = prefs.model;
                        updateModelSelectUI();
                    }
                    // Retourner la dernière localisation
                    return prefs.lastLocation;
                } catch (e) {
                    console.warn('Erreur chargement préférences:', e);
                }
            }
            return null;
        }

        // Mettre à jour l'UI des sélecteurs d'unités
        function updateUnitSelectorsUI() {
            Object.keys(state.units).forEach(unitType => {
                const selector = document.getElementById(unitType + 'UnitSelector');
                if (selector) {
                    selector.querySelectorAll('.unit-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.unit === state.units[unitType]);
                    });
                }
            });
        }

        // Mettre à jour l'UI du mode
        function updateModeUI() {
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === state.mode);
            });
            // Mettre à jour l'affichage des unités de vagues selon le mode
            const waveUnitGroup = document.getElementById('waveUnitGroup');
            if (waveUnitGroup) {
                waveUnitGroup.style.display = state.mode === 'marine' ? 'block' : 'none';
            }
            // Mettre à jour le logo
            const logoIcon = document.getElementById('logoIcon');
            if (logoIcon) {
                logoIcon.textContent = state.mode === 'marine' ? '⚓' : '🌊';
            }
        }

        // Mettre à jour l'UI du modèle
        function updateModelSelectUI() {
            const modelSelect = document.getElementById('modelSelect');
            if (modelSelect && state.model) {
                modelSelect.value = state.model;
            }
        }

        // Rendre les favoris
        function renderFavorites() {
            const container = document.getElementById('favoritesRow');
            container.innerHTML = state.favorites.map((fav, index) => `
                <button class="favorite-chip ${fav.isPort ? 'port' : ''}"
                        data-index="${index}"
                        data-lat="${fav.lat}"
                        data-lon="${fav.lon}"
                        data-name="${fav.name}"
                        data-coastal="${fav.isCoastal}"
                        data-port="${fav.isPort}">
                    ${fav.emoji || '📍'} ${fav.name}
                    <span class="delete-fav" data-delete="${index}">✕</span>
                </button>
            `).join('');
        }

        // Détecter le fuseau horaire approximatif selon les coordonnées
        function getTimezoneForCoords(lat, lon) {
            // Amérique du Nord
            if (lon >= -130 && lon <= -60) {
                if (lon >= -130 && lon <= -115) return 'America/Los_Angeles';
                if (lon >= -115 && lon <= -100) return 'America/Denver';
                if (lon >= -100 && lon <= -85) return 'America/Chicago';
                if (lon >= -85 && lon <= -60) return 'America/New_York';
            }
            // Mexique / Amérique Centrale
            if (lat >= 14 && lat <= 33 && lon >= -118 && lon <= -86) {
                return 'America/Mexico_City';
            }
            // Canada Est
            if (lat >= 45 && lon >= -80 && lon <= -50) {
                return 'America/Toronto';
            }
            // Europe
            if (lon >= -10 && lon <= 40 && lat >= 35 && lat <= 72) {
                if (lon <= 0) return 'Europe/London';
                if (lon <= 15) return 'Europe/Paris';
                return 'Europe/Moscow';
            }
            // Asie
            if (lon >= 100 && lon <= 145) return 'Asia/Tokyo';
            if (lon >= 70 && lon < 100) return 'Asia/Kolkata';
            // Océanie
            if (lon >= 110 && lon <= 180 && lat <= 0) return 'Australia/Sydney';
            // Défaut
            return 'auto';
        }

        // Vérifier si les coordonnées sont dans la zone de couverture d'un modèle
        function isInModelCoverage(lat, lon, modelKey) {
            // AROME HD et AROME: France métropolitaine étendue
            if (modelKey === 'arome_france_hd' || modelKey === 'arome_france') {
                return lat >= 41 && lat <= 52 && lon >= -6 && lon <= 10;
            }
            // ARPÈGE: Europe
            if (modelKey === 'arpege_europe') {
                return lat >= 20 && lat <= 72 && lon >= -32 && lon <= 42;
            }
            // ICON: principalement Europe mais plus large
            if (modelKey === 'icon_seamless') {
                return lat >= -90 && lat <= 90; // Global
            }
            // GFS et ECMWF: Global
            return true;
        }

        // Obtenir le meilleur modèle pour une localisation
        function getBestModelForLocation(lat, lon, preferredModel) {
            if (isInModelCoverage(lat, lon, preferredModel)) {
                return preferredModel;
            }
            // Fallback vers GFS (couverture mondiale)
            return 'gfs_seamless';
        }

        // API Météo
        async function fetchWeatherData(lat, lon, modelKey) {
            // Vérifier la couverture et basculer si nécessaire
            const actualModel = getBestModelForLocation(lat, lon, modelKey);
            const model = models[actualModel];

            // Stocker le modèle réellement utilisé pour l'affichage
            state.actualModel = actualModel;

            let baseUrl = 'https://api.open-meteo.com/v1/';

            if (model.api === 'meteofrance') baseUrl += 'meteofrance';
            else if (model.api === 'ecmwf') baseUrl += 'ecmwf';
            else if (model.api === 'gfs') baseUrl += 'gfs';
            else if (model.api === 'icon') baseUrl += 'dwd-icon';
            else baseUrl += 'forecast';

            // Détecter le fuseau horaire approprié
            const timezone = getTimezoneForCoords(lat, lon);

            const params = new URLSearchParams({
                latitude: lat,
                longitude: lon,
                hourly: 'temperature_2m,relative_humidity_2m,apparent_temperature,precipitation,precipitation_probability,rain,showers,snowfall,weather_code,pressure_msl,cloud_cover,visibility,wind_speed_10m,wind_direction_10m,wind_gusts_10m,uv_index,sunshine_duration',
                daily: 'weather_code,temperature_2m_max,temperature_2m_min,sunrise,sunset,sunshine_duration,precipitation_sum,precipitation_probability_max,rain_sum,wind_speed_10m_max,wind_gusts_10m_max,wind_direction_10m_dominant,uv_index_max',
                current: 'temperature_2m,relative_humidity_2m,apparent_temperature,is_day,precipitation,rain,showers,weather_code,cloud_cover,pressure_msl,wind_speed_10m,wind_direction_10m,wind_gusts_10m',
                timezone: timezone,
                forecast_days: '7'
            });

            if (model.api === 'meteofrance') params.append('models', actualModel);

            const response = await fetch(`${baseUrl}?${params.toString()}`);
            if (!response.ok) throw new Error(`API Error: ${response.status}`);
            const data = await response.json();

            // Si pressure_msl est null dans current (cas AROME HD), utiliser les données horaires
            if (data.current && (data.current.pressure_msl === null || data.current.pressure_msl === undefined)) {
                // Utiliser la première valeur horaire disponible
                if (data.hourly && data.hourly.pressure_msl) {
                    const validPressure = data.hourly.pressure_msl.find(p => p !== null && p !== undefined);
                    if (validPressure) {
                        data.current.pressure_msl = validPressure;
                    } else {
                        // Fallback: faire une requête standard sans modèle spécifique
                        try {
                            const fallbackResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=pressure_msl&timezone=Europe/Paris`);
                            const fallbackData = await fallbackResponse.json();
                            if (fallbackData.current?.pressure_msl) {
                                data.current.pressure_msl = fallbackData.current.pressure_msl;
                            }
                        } catch(e) {
                            console.warn('Fallback pressure fetch failed', e);
                        }
                    }
                }
            }

            // Même chose pour les données horaires si elles sont null
            if (data.hourly && data.hourly.pressure_msl) {
                const hasNullPressure = data.hourly.pressure_msl.some(p => p === null);
                if (hasNullPressure) {
                    try {
                        const fallbackResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=pressure_msl&timezone=Europe/Paris&forecast_days=2`);
                        const fallbackData = await fallbackResponse.json();
                        if (fallbackData.hourly?.pressure_msl) {
                            data.hourly.pressure_msl = fallbackData.hourly.pressure_msl;
                        }
                    } catch(e) {
                        console.warn('Fallback hourly pressure fetch failed', e);
                    }
                }
            }

            // IMPORTANT: Si weather_code est null (cas AROME HD), récupérer depuis l'API standard
            if (data.current && (data.current.weather_code === null || data.current.weather_code === undefined)) {
                try {
                    const fallbackResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=weather_code&hourly=weather_code,precipitation_probability&timezone=${timezone}&forecast_days=2`);
                    const fallbackData = await fallbackResponse.json();
                    if (fallbackData.current?.weather_code !== null && fallbackData.current?.weather_code !== undefined) {
                        data.current.weather_code = fallbackData.current.weather_code;
                        console.log('Weather code récupéré depuis API standard:', data.current.weather_code);
                    }
                    // Aussi récupérer les weather_code horaires si manquants
                    if (fallbackData.hourly?.weather_code) {
                        if (!data.hourly.weather_code || data.hourly.weather_code.every(c => c === null)) {
                            data.hourly.weather_code = fallbackData.hourly.weather_code;
                        }
                    }
                    if (fallbackData.hourly?.precipitation_probability) {
                        if (!data.hourly.precipitation_probability || data.hourly.precipitation_probability.every(p => p === null)) {
                            data.hourly.precipitation_probability = fallbackData.hourly.precipitation_probability;
                        }
                    }
                } catch(e) {
                    console.warn('Fallback weather_code fetch failed', e);
                }
            }

            // Vérifier aussi les weather_code horaires
            if (data.hourly && (!data.hourly.weather_code || data.hourly.weather_code.some(c => c === null))) {
                try {
                    const fallbackResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=weather_code,precipitation_probability&timezone=${timezone}&forecast_days=7`);
                    const fallbackData = await fallbackResponse.json();
                    if (fallbackData.hourly?.weather_code) {
                        data.hourly.weather_code = fallbackData.hourly.weather_code;
                    }
                    if (fallbackData.hourly?.precipitation_probability && !data.hourly.precipitation_probability) {
                        data.hourly.precipitation_probability = fallbackData.hourly.precipitation_probability;
                    }
                } catch(e) {
                    console.warn('Fallback hourly weather_code fetch failed', e);
                }
            }

            return data;
        }

        // API Marine
        async function fetchMarineData(lat, lon) {
            const params = new URLSearchParams({
                latitude: lat,
                longitude: lon,
                hourly: 'wave_height,wave_direction,wave_period,swell_wave_height,swell_wave_direction,swell_wave_period',
                current: 'wave_height,wave_direction,wave_period,swell_wave_height,swell_wave_direction,swell_wave_period',
                timezone: 'Europe/Paris',
                forecast_days: '7'
            });

            const response = await fetch(`https://marine-api.open-meteo.com/v1/marine?${params.toString()}`);
            if (!response.ok) throw new Error(`Marine API Error: ${response.status}`);
            return await response.json();
        }

        // Générer des données de marées simulées (en attendant une vraie API)
        function generateTidesData(lat, lon) {
            const now = new Date();
            const baseHeight = 3 + Math.random() * 2;
            const amplitude = 1.5 + Math.random() * 3;
            const coefficient = 60 + Math.floor(Math.random() * 60);

            // Calculer les heures de marée basées sur la position lunaire approximative
            const lunarOffset = (lon / 15) * 60; // minutes de décalage
            const baseTime = new Date(now);
            baseTime.setMinutes(baseTime.getMinutes() + lunarOffset);

            const tides = [];
            for (let i = 0; i < 4; i++) {
                const tideTime = new Date(baseTime);
                tideTime.setHours(tideTime.getHours() + i * 6 + Math.floor(Math.random() * 2));
                tides.push({
                    time: tideTime,
                    height: i % 2 === 0 ? baseHeight + amplitude : baseHeight - amplitude,
                    type: i % 2 === 0 ? 'high' : 'low'
                });
            }

            // Calculer le niveau actuel
            const currentPhase = ((now.getHours() * 60 + now.getMinutes()) % (6 * 60)) / (6 * 60);
            const currentHeight = baseHeight + Math.sin(currentPhase * Math.PI * 2) * amplitude;

            return {
                coefficient,
                currentHeight: Math.round(currentHeight * 10) / 10,
                tides: tides.sort((a, b) => a.time - b.time),
                range: amplitude * 2
            };
        }

        // Générer le bulletin côtier
        function generateCoastalBulletin(cityName, weatherData, marineData) {
            const wind = weatherData.current.wind_speed_10m;
            const gust = weatherData.current.wind_gusts_10m;
            const windDir = getWindDirection(weatherData.current.wind_direction_10m);
            const waveHeight = marineData?.current?.wave_height || 0;
            const swellHeight = marineData?.current?.swell_wave_height || 0;
            const swellDir = marineData?.current?.swell_wave_direction || 0;

            const beaufort = kmhToBeaufort(wind);
            const visibility = weatherData.current.cloud_cover > 80 ? 'Réduite' : 'Bonne';

            let seaDesc = 'Belle à peu agitée';
            if (waveHeight > 2.5) seaDesc = 'Agitée à forte';
            else if (waveHeight > 1.25) seaDesc = 'Peu agitée à agitée';
            else if (waveHeight > 0.5) seaDesc = 'Belle à peu agitée';

            const now = new Date();
            const bulletinDate = now.toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long' });
            const bulletinTime = now.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });

            return {
                zone: cityName,
                date: bulletinDate,
                time: bulletinTime,
                sections: [
                    {
                        title: 'Situation générale',
                        text: `Vent de secteur ${windDir} ${beaufort} à ${beaufort + 1} Beaufort, ${Math.round(wind)} à ${Math.round(gust)} km/h en rafales.`
                    },
                    {
                        title: 'État de la mer',
                        text: `${seaDesc}. Vagues de ${waveHeight.toFixed(1)}m. ${swellHeight > 0.3 ? `Houle de ${getWindDirection(swellDir)} de ${swellHeight.toFixed(1)}m.` : 'Pas de houle significative.'}`
                    },
                    {
                        title: 'Visibilité',
                        text: `${visibility}. ${weatherData.current.precipitation > 0 ? 'Passages pluvieux possibles.' : ''}`
                    },
                    {
                        title: 'Évolution',
                        text: `Tendance ${weatherData.hourly.wind_speed_10m[12] > wind ? 'au renforcement' : 'à l\'atténuation'} du vent dans les prochaines heures.`
                    }
                ]
            };
        }

        // Générer le bulletin marine détaillé pour une zone
        async function generateMarineBulletin(zoneKey) {
            const zone = marineZones[zoneKey];
            if (!zone) return null;

            const { lat, lon } = zone.coords;

            try {
                // Récupérer les données météo pour cette zone
                const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,wind_speed_10m,wind_direction_10m,wind_gusts_10m,cloud_cover,precipitation,weather_code&hourly=wind_speed_10m,wind_gusts_10m,wind_direction_10m,precipitation&timezone=Europe/Paris&forecast_days=2`);
                const weatherData = await weatherResponse.json();

                // Récupérer les données marines
                const marineResponse = await fetch(`https://marine-api.open-meteo.com/v1/marine?latitude=${lat}&longitude=${lon}&current=wave_height,wave_direction,wave_period,swell_wave_height,swell_wave_direction,swell_wave_period&hourly=wave_height,swell_wave_height&timezone=Europe/Paris&forecast_days=2`);
                const marineData = await marineResponse.json();

                const current = weatherData.current;
                const marine = marineData.current;
                const hourlyWind = weatherData.hourly.wind_speed_10m;
                const hourlyWave = marineData.hourly.wave_height;

                const wind = current.wind_speed_10m || 0;
                const gust = current.wind_gusts_10m || 0;
                const windDeg = current.wind_direction_10m || 0;
                const waveHeight = marine?.wave_height || 0;
                const wavePeriod = marine?.wave_period || 0;
                const swellHeight = marine?.swell_wave_height || 0;
                const swellDir = marine?.swell_wave_direction || 0;
                const swellPeriod = marine?.swell_wave_period || 0;

                const beaufort = kmhToBeaufort(wind);
                const gustBeaufort = kmhToBeaufort(gust);
                const seaStateIdx = getSeaState(waveHeight);
                const seaState = seaStates[seaStateIdx];

                // Déterminer le niveau d'alerte
                let warningLevel = null;
                let warningText = '';
                if (beaufort >= 8 || waveHeight >= 6) {
                    warningLevel = 'danger';
                    warningText = 'AVIS DE COUP DE VENT - Navigation fortement déconseillée';
                } else if (beaufort >= 6 || waveHeight >= 4) {
                    warningLevel = 'warning';
                    warningText = 'Conditions difficiles - Prudence recommandée';
                }

                // Prévisions par période
                const forecasts = [
                    { period: 'Ce matin', windIdx: 0 },
                    { period: 'Cet après-midi', windIdx: 6 },
                    { period: 'Ce soir', windIdx: 12 },
                    { period: 'Cette nuit', windIdx: 18 },
                    { period: 'Demain matin', windIdx: 24 },
                    { period: 'Demain après-midi', windIdx: 30 }
                ].slice(0, 3).map(f => ({
                    period: f.period,
                    wind: hourlyWind[f.windIdx] || wind,
                    wave: hourlyWave[f.windIdx] || waveHeight
                }));

                const now = new Date();

                return {
                    zone: zone.name,
                    region: zone.region,
                    date: now.toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' }),
                    time: now.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }),
                    warning: warningLevel ? { level: warningLevel, text: warningText } : null,
                    wind: {
                        speed: wind,
                        gust: gust,
                        direction: getWindDirection(windDeg),
                        directionDeg: windDeg,
                        beaufort: beaufort,
                        gustBeaufort: gustBeaufort
                    },
                    sea: {
                        state: seaState.name,
                        stateDesc: seaState.desc,
                        waveHeight: waveHeight,
                        wavePeriod: wavePeriod
                    },
                    swell: {
                        height: swellHeight,
                        direction: getWindDirection(swellDir),
                        directionDeg: swellDir,
                        period: swellPeriod
                    },
                    visibility: current.cloud_cover > 80 ? 'Moyenne à réduite' : current.cloud_cover > 50 ? 'Bonne à moyenne' : 'Bonne',
                    precipitation: current.precipitation > 0,
                    forecasts: forecasts
                };
            } catch (e) {
                console.error('Erreur génération bulletin marine:', e);
                return null;
            }
        }

        // Rendu du bulletin marine détaillé
        function renderMarineBulletin(bulletin) {
            if (!bulletin) return '<div class="panel-card"><p style="opacity:0.6;text-align:center;">Chargement du bulletin...</p></div>';

            return `
                <div class="marine-bulletin">
                    <div class="marine-bulletin-header">
                        <div class="marine-bulletin-title">
                            ⚓ Bulletin Marine - ${bulletin.zone}
                        </div>
                        <div class="zone-selector">
                            <select class="zone-select" id="marineZoneSelect" onchange="changeMarineZone(this.value)">
                                <optgroup label="Manche - Mer du Nord">
                                    ${marineRegions.manche.zones.map(z => `<option value="${z}" ${z === selectedMarineZone ? 'selected' : ''}>${marineZones[z].name}</option>`).join('')}
                                </optgroup>
                                <optgroup label="Atlantique">
                                    ${marineRegions.atlantique.zones.map(z => `<option value="${z}" ${z === selectedMarineZone ? 'selected' : ''}>${marineZones[z].name}</option>`).join('')}
                                </optgroup>
                                <optgroup label="Méditerranée">
                                    ${marineRegions.mediterranee.zones.map(z => `<option value="${z}" ${z === selectedMarineZone ? 'selected' : ''}>${marineZones[z].name}</option>`).join('')}
                                </optgroup>
                            </select>
                        </div>
                    </div>

                    <div class="marine-bulletin-meta">
                        <span>📅 ${bulletin.date}</span>
                        <span>🕐 ${bulletin.time}</span>
                        <span>📍 ${bulletin.region}</span>
                    </div>

                    ${bulletin.warning ? `
                        <div class="bulletin-warning ${bulletin.warning.level}">
                            <span class="bulletin-warning-icon">${bulletin.warning.level === 'danger' ? '🚨' : '⚠️'}</span>
                            <span class="bulletin-warning-text">${bulletin.warning.text}</span>
                        </div>
                    ` : ''}

                    <div class="bulletin-block">
                        <div class="bulletin-block-title">💨 Vent</div>
                        <div class="bulletin-block-content">
                            Secteur <strong>${bulletin.wind.direction}</strong> (${bulletin.wind.directionDeg}°),
                            force <strong>${bulletin.wind.beaufort}</strong> à <strong>${bulletin.wind.gustBeaufort}</strong> Beaufort.
                            <br>Vitesse ${Math.round(bulletin.wind.speed)} km/h, rafales jusqu'à <strong>${Math.round(bulletin.wind.gust)} km/h</strong>.
                        </div>
                    </div>

                    <div class="bulletin-block">
                        <div class="bulletin-block-title">🌊 État de la mer</div>
                        <div class="bulletin-block-content">
                            Mer <strong>${bulletin.sea.state.toLowerCase()}</strong> (${bulletin.sea.stateDesc.toLowerCase()}).
                            <br>Hauteur des vagues: <strong>${bulletin.sea.waveHeight.toFixed(1)} m</strong>, période ${Math.round(bulletin.sea.wavePeriod)} s.
                        </div>
                    </div>

                    ${bulletin.swell.height > 0.3 ? `
                        <div class="bulletin-block">
                            <div class="bulletin-block-title">〰️ Houle</div>
                            <div class="bulletin-block-content">
                                Houle de secteur <strong>${bulletin.swell.direction}</strong>,
                                hauteur <strong>${bulletin.swell.height.toFixed(1)} m</strong>,
                                période ${Math.round(bulletin.swell.period)} s.
                            </div>
                        </div>
                    ` : ''}

                    <div class="bulletin-block">
                        <div class="bulletin-block-title">👁️ Visibilité</div>
                        <div class="bulletin-block-content">
                            ${bulletin.visibility}. ${bulletin.precipitation ? 'Passages pluvieux ou averses.' : 'Temps sec.'}
                        </div>
                    </div>

                    <div class="bulletin-block">
                        <div class="bulletin-block-title">📊 Prévisions</div>
                        <div class="bulletin-forecast-grid">
                            ${bulletin.forecasts.map(f => `
                                <div class="bulletin-forecast-item">
                                    <div class="bulletin-forecast-period">${f.period}</div>
                                    <div class="bulletin-forecast-wind">${kmhToBeaufort(f.wind)} Bft</div>
                                    <div class="bulletin-forecast-sea">${f.wave.toFixed(1)}m</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        // Changer la zone marine et recharger le bulletin
        async function changeMarineZone(zoneKey) {
            selectedMarineZone = zoneKey;
            const bulletinContainer = document.getElementById('marineBulletinContainer');
            if (bulletinContainer) {
                bulletinContainer.innerHTML = '<div class="panel-card"><p style="opacity:0.6;text-align:center;">Chargement...</p></div>';
                const bulletin = await generateMarineBulletin(zoneKey);
                bulletinContainer.innerHTML = renderMarineBulletin(bulletin);
            }
        }

        // Conversions
        function convertWind(valueKmh, toUnit) {
            if (valueKmh === undefined || valueKmh === null) return 0;
            switch (toUnit) {
                case 'kt': return Math.round(valueKmh * 0.539957);
                case 'ms': return Math.round(valueKmh * 10 / 36 * 10) / 10;
                case 'bft': return kmhToBeaufort(valueKmh);
                default: return Math.round(valueKmh);
            }
        }

        function kmhToBeaufort(kmh) {
            const scales = [1, 6, 12, 20, 29, 39, 50, 62, 75, 89, 103, 118];
            for (let i = 0; i < scales.length; i++) {
                if (kmh < scales[i]) return i;
            }
            return 12;
        }

        function getWindUnitLabel() {
            return { kmh: 'km/h', kt: 'kt', ms: 'm/s', bft: 'Bft' }[state.units.wind];
        }

        function convertTemp(celsius) {
            if (celsius === undefined || celsius === null) return 0;
            return state.units.temp === 'fahrenheit' ? Math.round(celsius * 9 / 5 + 32) : Math.round(celsius);
        }

        function getTempUnit() {
            return state.units.temp === 'celsius' ? '°C' : '°F';
        }

        function convertWave(meters) {
            if (meters === undefined || meters === null) return 0;
            return state.units.wave === 'ft' ? Math.round(meters * 3.28084 * 10) / 10 : Math.round(meters * 10) / 10;
        }

        function getWaveUnit() {
            return state.units.wave === 'm' ? 'm' : 'ft';
        }

        function convertPressure(hpa) {
            if (hpa === undefined || hpa === null) return 0;
            return state.units.pressure === 'inhg' ? Math.round(hpa * 0.02953 * 100) / 100 : Math.round(hpa);
        }

        function getPressureUnit() {
            return state.units.pressure === 'hpa' ? 'hPa' : 'inHg';
        }

        function getWindDirection(deg) {
            if (deg === undefined || deg === null) return 'N';
            const dirs = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSO', 'SO', 'OSO', 'O', 'ONO', 'NO', 'NNO'];
            return dirs[Math.round(deg / 22.5) % 16];
        }

        function getSeaState(waveHeight) {
            for (let i = 0; i < seaStates.length; i++) {
                if (waveHeight <= seaStates[i].maxHeight) return i;
            }
            return 9;
        }

        function getWeatherIcon(code, isDay = true) {
            // Si code est null ou undefined, afficher un indicateur neutre
            if (code === null || code === undefined) {
                return isDay ? '🌤️' : '🌙';
            }
            const weather = weatherCodes[code];
            if (!weather) {
                console.warn('Code météo inconnu:', code);
                return isDay ? '🌤️' : '🌙';
            }
            if (!isDay && code <= 3) return code === 0 ? '🌙' : '☁️';
            return weather.icon;
        }

        function getWeatherDesc(code) {
            return (weatherCodes[code] || weatherCodes[0]).desc;
        }

        // ============== SÉLECTEUR DE JOURS (7 jours) ==============

        // Noms des jours en français
        const joursSemaine = ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'];
        const joursComplets = ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];

        // Générer le sélecteur de jours
        function renderDaySelector() {
            const data = state.weatherData;
            if (!data || !data.daily) return '';

            const today = new Date();
            const days = [];

            for (let i = 0; i < 7; i++) {
                const date = new Date(today);
                date.setDate(today.getDate() + i);

                const dayName = i === 0 ? "Auj." : (i === 1 ? "Dem." : joursSemaine[date.getDay()]);
                const dateStr = `${date.getDate()}/${date.getMonth() + 1}`;

                // Récupérer les données météo du jour
                let weatherCode = data.daily.weather_code ? data.daily.weather_code[i] : null;

                // Si weather_code est null (AROME HD), essayer de déduire depuis les données horaires
                if (weatherCode === null || weatherCode === undefined) {
                    const hourlyStart = i * 24 + 12; // Midi du jour
                    if (data.hourly && data.hourly.weather_code && data.hourly.weather_code[hourlyStart] !== null) {
                        weatherCode = data.hourly.weather_code[hourlyStart];
                    }
                }

                const tempMax = data.daily.temperature_2m_max ? Math.round(data.daily.temperature_2m_max[i]) : '--';
                const tempMin = data.daily.temperature_2m_min ? Math.round(data.daily.temperature_2m_min[i]) : '--';

                // Déterminer l'icône basée sur le code météo ou les précipitations
                let icon;
                if (weatherCode !== null && weatherCode !== undefined) {
                    icon = getWeatherIcon(weatherCode, true);
                } else {
                    // Fallback: utiliser la probabilité de précipitation pour deviner
                    const precipProb = data.daily.precipitation_probability_max ? data.daily.precipitation_probability_max[i] : 0;
                    const precipSum = data.daily.precipitation_sum ? data.daily.precipitation_sum[i] : 0;
                    if (precipProb > 60 || precipSum > 5) {
                        icon = '🌧️';
                    } else if (precipProb > 30 || precipSum > 1) {
                        icon = '🌦️';
                    } else {
                        icon = '🌤️';
                    }
                }

                days.push(`
                    <button class="day-btn ${i === state.selectedDay ? 'active' : ''} ${i === 0 ? 'today' : ''}"
                            onclick="selectDay(${i})" title="${joursComplets[date.getDay()]} ${dateStr}">
                        <span class="day-btn-name">${dayName}</span>
                        <span class="day-btn-date">${dateStr}</span>
                        <span class="day-btn-icon">${icon}</span>
                        <span class="day-btn-temp">
                            <span class="day-btn-temp-max">${tempMax}°</span>
                            <span class="day-btn-temp-min">${tempMin}°</span>
                        </span>
                    </button>
                `);
            }

            return `<div class="day-selector">${days.join('')}</div>`;
        }

        // Changer le jour sélectionné
        function selectDay(dayIndex) {
            state.selectedDay = dayIndex;
            renderCurrentView();
        }

        // Obtenir la date du jour sélectionné
        function getSelectedDate() {
            const today = new Date();
            const selectedDate = new Date(today);
            selectedDate.setDate(today.getDate() + state.selectedDay);
            return selectedDate;
        }

        // Obtenir le label du jour sélectionné
        function getSelectedDayLabel() {
            if (state.selectedDay === 0) return "Aujourd'hui";
            if (state.selectedDay === 1) return "Demain";
            const date = getSelectedDate();
            return `${joursComplets[date.getDay()]} ${date.getDate()}/${date.getMonth() + 1}`;
        }

        // Indicateur de prévision (si pas aujourd'hui)
        function renderDayIndicator() {
            if (state.selectedDay === 0) return '';
            return `
                <div class="day-indicator">
                    <span class="day-indicator-badge">📅 Prévision</span>
                    <span>${getSelectedDayLabel()}</span>
                    <button onclick="selectDay(0)" style="margin-left:auto;background:none;border:none;color:var(--accent-blue);cursor:pointer;font-size:0.8rem;">
                        ↩️ Retour à aujourd'hui
                    </button>
                </div>
            `;
        }

        // Obtenir l'index horaire pour le jour sélectionné (début de la journée)
        function getHourlyIndexForSelectedDay() {
            // Les données horaires commencent à minuit du jour 0
            // Donc pour le jour N, l'index de début est N * 24
            return state.selectedDay * 24;
        }

        // Géocodage
        async function geocodeCity(query) {
            const response = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=5&language=fr&format=json`);
            const data = await response.json();
            if (data.results && data.results.length > 0) {
                const result = data.results[0];
                return {
                    name: result.name + (result.admin1 ? `, ${result.admin1}` : ''),
                    lat: result.latitude,
                    lon: result.longitude
                };
            }
            throw new Error('Ville non trouvée');
        }

        // DOM Elements
        const mainContent = document.getElementById('mainContent');
        const searchInput = document.getElementById('searchInput');
        const searchBtn = document.getElementById('searchBtn');
        const locationBtn = document.getElementById('locationBtn');
        const addFavoriteBtn = document.getElementById('addFavoriteBtn');
        const weatherModeBtn = document.getElementById('weatherModeBtn');
        const marineModeBtn = document.getElementById('marineModeBtn');
        const ephemerideModeBtn = document.getElementById('ephemerideModeBtn');
        const fishingModeBtn = document.getElementById('fishingModeBtn');
        const logoIcon = document.getElementById('logoIcon');
        const locationText = document.getElementById('locationText');
        const modelSelect = document.getElementById('modelSelect');
        const waveUnitGroup = document.getElementById('waveUnitGroup');
        const favoritesRow = document.getElementById('favoritesRow');
        const apiStatus = document.getElementById('apiStatus');
        const apiStatusText = document.getElementById('apiStatusText');
        const addFavoriteModal = document.getElementById('addFavoriteModal');
        const addFavoriteForm = document.getElementById('addFavoriteForm');
        const closeModal = document.getElementById('closeModal');

        // Initialisation
        document.addEventListener('DOMContentLoaded', () => {
            // Initialiser le mode offline
            initOfflineMode();

            loadFavorites();
            const lastLocation = loadPreferences();
            setupEventListeners();

            // Restaurer la dernière localisation ou géolocaliser
            if (lastLocation && lastLocation.lat && lastLocation.lon) {
                state.currentIsPort = lastLocation.isPort || false;
                loadWeatherForCoords(lastLocation.lat, lastLocation.lon, lastLocation.name || 'Position sauvegardée');
            } else {
                initGeolocation();
            }
        });

        function setupEventListeners() {
            searchBtn.addEventListener('click', handleSearch);
            searchInput.addEventListener('keypress', e => e.key === 'Enter' && handleSearch());
            locationBtn.addEventListener('click', initGeolocation);

            weatherModeBtn.addEventListener('click', () => setMode('weather'));
            marineModeBtn.addEventListener('click', () => setMode('marine'));
            ephemerideModeBtn.addEventListener('click', () => setMode('ephemeride'));
            fishingModeBtn.addEventListener('click', () => setMode('fishing'));

            modelSelect.addEventListener('change', e => {
                state.model = e.target.value;
                savePreferences(); // Sauvegarder le modèle choisi
                if (state.currentCoords) {
                    loadWeatherForCoords(state.currentCoords.lat, state.currentCoords.lon, state.currentCity);
                }
            });

            // Unit selectors
            document.querySelectorAll('.unit-selector').forEach(selector => {
                selector.querySelectorAll('.unit-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        selector.querySelectorAll('.unit-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        const unitType = selector.id.replace('UnitSelector', '');
                        state.units[unitType] = btn.dataset.unit;
                        savePreferences(); // Sauvegarder les préférences
                        renderCurrentView();
                    });
                });
            });

            // Favorites
            favoritesRow.addEventListener('click', e => {
                const deleteBtn = e.target.closest('.delete-fav');
                if (deleteBtn) {
                    e.stopPropagation();
                    const index = parseInt(deleteBtn.dataset.delete);
                    state.favorites.splice(index, 1);
                    saveFavorites();
                    renderFavorites();
                    return;
                }

                const chip = e.target.closest('.favorite-chip');
                if (chip) {
                    document.querySelectorAll('.favorite-chip').forEach(c => c.classList.remove('active'));
                    chip.classList.add('active');
                    const lat = parseFloat(chip.dataset.lat);
                    const lon = parseFloat(chip.dataset.lon);
                    const name = chip.dataset.name;
                    const isPort = chip.dataset.port === 'true';
                    state.currentIsPort = isPort;
                    loadWeatherForCoords(lat, lon, name);
                }
            });

            // Modal favoris
            addFavoriteBtn.addEventListener('click', () => {
                if (state.currentCoords) {
                    document.getElementById('favLat').value = state.currentCoords.lat.toFixed(4);
                    document.getElementById('favLon').value = state.currentCoords.lon.toFixed(4);
                    document.getElementById('favName').value = state.currentCity || '';
                }
                addFavoriteModal.classList.add('active');
            });

            closeModal.addEventListener('click', () => {
                addFavoriteModal.classList.remove('active');
            });

            addFavoriteModal.addEventListener('click', e => {
                if (e.target === addFavoriteModal) {
                    addFavoriteModal.classList.remove('active');
                }
            });

            addFavoriteForm.addEventListener('submit', e => {
                e.preventDefault();
                const newFav = {
                    name: document.getElementById('favName').value,
                    lat: parseFloat(document.getElementById('favLat').value),
                    lon: parseFloat(document.getElementById('favLon').value),
                    emoji: document.getElementById('favEmoji').value || '📍',
                    isPort: document.getElementById('favIsPort').checked,
                    isCoastal: document.getElementById('favIsCoastal').checked
                };
                state.favorites.push(newFav);
                saveFavorites();
                renderFavorites();
                addFavoriteModal.classList.remove('active');
                addFavoriteForm.reset();
            });
        }

        function initGeolocation() {
            showLoading('Géolocalisation en cours...');

            // Vérifier si on est en HTTPS ou localhost (requis pour géolocalisation)
            const isSecure = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1' || location.protocol === 'file:';

            if (!isSecure) {
                console.warn('Géolocalisation requiert HTTPS. Utilisation de Paris par défaut.');
                showLoading('Chargement de Paris (géolocalisation requiert HTTPS)...');
                loadWeatherForCoords(48.8566, 2.3522, 'Paris');
                return;
            }

            if (navigator.geolocation) {
                // Timeout de secours si la géolocalisation prend trop de temps
                const fallbackTimeout = setTimeout(() => {
                    console.warn('Géolocalisation timeout - utilisation de Paris');
                    loadWeatherForCoords(48.8566, 2.3522, 'Paris');
                }, 8000);

                navigator.geolocation.getCurrentPosition(
                    position => {
                        clearTimeout(fallbackTimeout);
                        const { latitude, longitude } = position.coords;
                        console.log('Position obtenue:', latitude, longitude);
                        loadWeatherForCoords(latitude, longitude, 'Ma position');
                        document.getElementById('locationBadge').classList.add('live');
                    },
                    error => {
                        clearTimeout(fallbackTimeout);
                        let errorMsg = 'Erreur inconnue';
                        switch(error.code) {
                            case error.PERMISSION_DENIED:
                                errorMsg = 'Permission refusée';
                                break;
                            case error.POSITION_UNAVAILABLE:
                                errorMsg = 'Position indisponible';
                                break;
                            case error.TIMEOUT:
                                errorMsg = 'Timeout';
                                break;
                        }
                        console.warn('Géolocalisation échouée:', errorMsg, error);
                        showLoading(`Géolocalisation échouée (${errorMsg}). Chargement de Paris...`);
                        loadWeatherForCoords(48.8566, 2.3522, 'Paris');
                    },
                    {
                        timeout: 7000,
                        enableHighAccuracy: false,  // Plus rapide avec false
                        maximumAge: 300000  // Accepter une position de moins de 5 minutes
                    }
                );
            } else {
                console.warn('Géolocalisation non supportée');
                loadWeatherForCoords(48.8566, 2.3522, 'Paris');
            }
        }

        async function loadWeatherForCoords(lat, lon, cityName) {
            showLoading(`Chargement des données ${models[state.model].name}...`);

            try {
                state.currentCoords = { lat, lon };
                state.currentCity = cityName;
                locationText.textContent = cityName;
                savePreferences(); // Sauvegarder la dernière localisation

                const weatherData = await fetchWeatherData(lat, lon, state.model);
                state.weatherData = weatherData;
                state.lastUpdate = new Date();

                try {
                    const marineData = await fetchMarineData(lat, lon);
                    state.marineData = marineData;
                } catch (e) {
                    state.marineData = null;
                }

                state.tidesData = generateTidesData(lat, lon);

                apiStatus.classList.remove('error');
                // Afficher le modèle réellement utilisé (peut différer si hors zone)
                const usedModel = state.actualModel || state.model;
                const modelInfo = models[usedModel].name;
                const fallbackNote = (usedModel !== state.model) ? ' (auto)' : '';
                apiStatusText.textContent = `API Live - ${modelInfo}${fallbackNote}`;
                state.apiError = false;

                renderCurrentView();

                // Sauvegarder en cache pour le mode offline
                cacheWeatherData();

            } catch (error) {
                console.error('Erreur API:', error);
                state.apiError = true;
                apiStatus.classList.add('error');
                apiStatusText.textContent = 'Erreur API';
                showError('Impossible de charger les données météo.');

                // En cas d'erreur, essayer de charger les données en cache
                if (!isOnline) {
                    loadCachedData();
                }
            }
        }

        async function handleSearch() {
            const query = searchInput.value.trim();
            if (query) {
                showLoading(`Recherche de "${query}"...`);
                try {
                    const location = await geocodeCity(query);
                    document.querySelectorAll('.favorite-chip').forEach(c => c.classList.remove('active'));
                    document.getElementById('locationBadge').classList.remove('live');
                    loadWeatherForCoords(location.lat, location.lon, location.name);
                    searchInput.value = '';
                } catch (error) {
                    showError(`Ville "${query}" non trouvée`);
                }
            }
        }

        function setMode(mode) {
            state.mode = mode;
            weatherModeBtn.classList.toggle('active', mode === 'weather');
            marineModeBtn.classList.toggle('active', mode === 'marine');
            ephemerideModeBtn.classList.toggle('active', mode === 'ephemeride');
            fishingModeBtn.classList.toggle('active', mode === 'fishing');

            // Icône du logo selon le mode
            const modeIcons = {
                weather: '🌊',
                marine: '⚓',
                ephemeride: '🌙',
                fishing: '🎣'
            };
            logoIcon.textContent = modeIcons[mode] || '🌊';

            // Afficher le sélecteur de vagues uniquement en mode marine
            waveUnitGroup.style.display = (mode === 'marine' || mode === 'fishing') ? 'block' : 'none';

            savePreferences();
            renderCurrentView();
        }

        function showLoading(text = 'Chargement...') {
            state.isLoading = true;
            mainContent.innerHTML = `
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <p class="loading-text">${text}</p>
                </div>
            `;
        }

        function showError(message) {
            mainContent.innerHTML = `
                <div class="error-message">
                    <div class="icon">⚠️</div>
                    <div class="text">${message}</div>
                    <button class="retry-btn" onclick="initGeolocation()">Réessayer</button>
                </div>
            `;
        }

        function renderCurrentView() {
            if (!state.weatherData) return;
            state.isLoading = false;

            switch(state.mode) {
                case 'marine':
                    if (state.marineData) {
                        renderMarine();
                    } else {
                        mainContent.innerHTML = `
                            <div class="error-message">
                                <div class="icon">🌊</div>
                                <div class="text">Données marines non disponibles pour cette position.<br>Essayez une ville côtière.</div>
                            </div>
                        `;
                    }
                    break;
                case 'ephemeride':
                    renderEphemeride();
                    break;
                case 'fishing':
                    renderFishingMode();
                    break;
                default:
                    renderWeather();
            }
        }

        // Rendu du graphique vent/rafales
        function renderWindChart(hourlyWind, hourlyGust, hours = 24) {
            const windData = hourlyWind.slice(0, hours);
            const gustData = hourlyGust.slice(0, hours);

            const maxValue = Math.max(...gustData, ...windData) + 10;
            const minValue = 0;

            const windPoints = windData.map((v, i) => {
                const x = 5 + (i / (windData.length - 1)) * 90;
                const y = 95 - ((v - minValue) / (maxValue - minValue)) * 85;
                return `${x},${y}`;
            }).join(' ');

            const gustPoints = gustData.map((v, i) => {
                const x = 5 + (i / (gustData.length - 1)) * 90;
                const y = 95 - ((v - minValue) / (maxValue - minValue)) * 85;
                return `${x},${y}`;
            }).join(' ');

            const windAreaPoints = `5,95 ${windPoints} 95,95`;

            const timeLabels = ['Maintenant', '+6h', '+12h', '+18h', '+24h'];
            if (hours > 24) {
                timeLabels[4] = '+48h';
            }

            return `
                <div class="wind-chart-container">
                    <div class="wind-chart-header">
                        <div class="wind-chart-title">📊 Vent & Rafales (${hours}h)</div>
                        <div class="wind-chart-legend">
                            <div class="legend-item">
                                <span class="legend-dot wind"></span>
                                <span>Vent moyen</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-dot gust"></span>
                                <span>Rafales</span>
                            </div>
                        </div>
                    </div>
                    <div class="wind-chart">
                        <svg viewBox="0 0 100 100" preserveAspectRatio="none">
                            <defs>
                                <linearGradient id="windGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" style="stop-color:rgba(0,180,216,0.4)"/>
                                    <stop offset="100%" style="stop-color:rgba(0,180,216,0.05)"/>
                                </linearGradient>
                                <linearGradient id="gustGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" style="stop-color:rgba(255,107,53,0.2)"/>
                                    <stop offset="100%" style="stop-color:rgba(255,107,53,0.02)"/>
                                </linearGradient>
                            </defs>
                            <!-- Grid -->
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="25" x2="95" y2="25"/>
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="50" x2="95" y2="50"/>
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="75" x2="95" y2="75"/>
                            <!-- Wind area -->
                            <polygon class="wind-area" points="${windAreaPoints}"/>
                            <!-- Gust line -->
                            <polyline class="wind-line gust" points="${gustPoints}"/>
                            <!-- Wind line -->
                            <polyline class="wind-line main" points="${windPoints}"/>
                            <!-- Scale labels -->
                            <text x="2" y="12" fill="rgba(255,255,255,0.4)" font-size="6">${Math.round(maxValue)} ${getWindUnitLabel()}</text>
                            <text x="2" y="52" fill="rgba(255,255,255,0.4)" font-size="6">${Math.round(maxValue/2)}</text>
                            <text x="2" y="95" fill="rgba(255,255,255,0.4)" font-size="6">0</text>
                        </svg>
                    </div>
                    <div class="wind-chart-labels">
                        ${timeLabels.map(l => `<span>${l}</span>`).join('')}
                    </div>
                </div>
            `;
        }

        // Rendu du graphique de houle
        function renderWaveChart(hourlyWaveHeight, hours = 24) {
            const waveData = hourlyWaveHeight?.slice(0, hours) || [];
            if (waveData.length === 0) return '';

            const maxValue = Math.max(...waveData) + 0.5;
            const minValue = 0;

            const points = waveData.map((v, i) => {
                const x = 5 + (i / (waveData.length - 1)) * 90;
                const y = 95 - ((v - minValue) / (maxValue - minValue)) * 85;
                return `${x},${y}`;
            }).join(' ');

            const areaPoints = `5,95 ${points} 95,95`;

            return `
                <div class="wave-chart-container">
                    <div class="wind-chart-header">
                        <div class="wind-chart-title">🌊 Hauteur des vagues (${hours}h)</div>
                    </div>
                    <div class="wave-chart">
                        <svg viewBox="0 0 100 100" preserveAspectRatio="none">
                            <defs>
                                <linearGradient id="waveGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" style="stop-color:rgba(155,89,182,0.5)"/>
                                    <stop offset="100%" style="stop-color:rgba(155,89,182,0.05)"/>
                                </linearGradient>
                            </defs>
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="25" x2="95" y2="25"/>
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="50" x2="95" y2="50"/>
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="75" x2="95" y2="75"/>
                            <polygon class="wave-area-fill" points="${areaPoints}"/>
                            <polyline class="wave-line-chart" points="${points}"/>
                            <text x="2" y="12" fill="rgba(255,255,255,0.4)" font-size="6">${maxValue.toFixed(1)}${getWaveUnit()}</text>
                            <text x="2" y="52" fill="rgba(255,255,255,0.4)" font-size="6">${(maxValue/2).toFixed(1)}</text>
                            <text x="2" y="95" fill="rgba(255,255,255,0.4)" font-size="6">0</text>
                        </svg>
                    </div>
                    <div class="wind-chart-labels">
                        <span>Maintenant</span>
                        <span>+6h</span>
                        <span>+12h</span>
                        <span>+18h</span>
                        <span>+24h</span>
                    </div>
                </div>
            `;
        }

        // Rendu de la courbe de marée
        function renderTideCurve(tidesData) {
            if (!tidesData) return '';

            const now = new Date();
            const startOfDay = new Date(now);
            startOfDay.setHours(0, 0, 0, 0);

            // Générer une courbe sinusoïdale pour 24h
            const points = [];
            const baseHeight = tidesData.currentHeight;
            const amplitude = tidesData.range / 2;

            for (let i = 0; i <= 24; i++) {
                const hour = i;
                const phase = (hour / 12.4) * Math.PI * 2; // période de marée ~12.4h
                const height = baseHeight + Math.sin(phase - Math.PI/2) * amplitude;
                const x = 5 + (i / 24) * 90;
                const y = 90 - ((height / (baseHeight + amplitude + 1)) * 80);
                points.push(`${x},${y}`);
            }

            const pathPoints = points.join(' ');
            const areaPoints = `5,95 ${pathPoints} 95,95`;

            // Position actuelle sur la courbe
            const currentHour = now.getHours() + now.getMinutes() / 60;
            const nowX = 5 + (currentHour / 24) * 90;
            const nowPhase = (currentHour / 12.4) * Math.PI * 2;
            const nowHeight = baseHeight + Math.sin(nowPhase - Math.PI/2) * amplitude;
            const nowY = 90 - ((nowHeight / (baseHeight + amplitude + 1)) * 80);

            return `
                <div class="tide-curve-container">
                    <div class="tide-curve-header">
                        <div class="wind-chart-title">📈 Courbe de marée (24h)</div>
                        <div style="font-size:0.75rem;color:rgba(255,255,255,0.6)">Coef. ${tidesData.coefficient}</div>
                    </div>
                    <div class="tide-curve-chart">
                        <svg viewBox="0 0 100 100" preserveAspectRatio="none">
                            <defs>
                                <linearGradient id="tideGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" style="stop-color:rgba(0,119,182,0.5)"/>
                                    <stop offset="100%" style="stop-color:rgba(0,119,182,0.05)"/>
                                </linearGradient>
                            </defs>
                            <!-- Grid -->
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="30" x2="95" y2="30"/>
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="60" x2="95" y2="60"/>
                            <!-- Area fill -->
                            <polygon class="tide-area-fill" points="${areaPoints}"/>
                            <!-- Curve -->
                            <polyline class="tide-curve-path" points="${pathPoints}"/>
                            <!-- Now marker -->
                            <line x1="${nowX}" y1="5" x2="${nowX}" y2="95" stroke="var(--accent-orange)" stroke-width="1" stroke-dasharray="3 2"/>
                            <circle class="tide-now-marker" cx="${nowX}" cy="${nowY}" r="4"/>
                            <!-- Height labels -->
                            <text x="2" y="15" fill="rgba(255,255,255,0.4)" font-size="5">${(baseHeight + amplitude).toFixed(1)}m</text>
                            <text x="2" y="85" fill="rgba(255,255,255,0.4)" font-size="5">${(baseHeight - amplitude).toFixed(1)}m</text>
                        </svg>
                    </div>
                    <div class="tide-labels">
                        <span>00h</span>
                        <span>06h</span>
                        <span>12h</span>
                        <span>18h</span>
                        <span>24h</span>
                    </div>
                    <div style="text-align:center;margin-top:10px;font-size:0.85rem;">
                        <span style="color:var(--accent-orange);font-weight:600;">${tidesData.currentHeight}m</span>
                        <span style="opacity:0.6;"> niveau actuel</span>
                    </div>
                </div>
            `;
        }

        // Rendu du radar de pluie
        function renderRainRadar(lat, lon) {
            return `
                <div class="radar-container">
                    <div class="radar-header">
                        <div class="radar-title">🌧️ Radar de pluie</div>
                        <div class="radar-live">
                            <span class="pulse"></span>
                            <span>Live</span>
                        </div>
                    </div>
                    <div class="radar-map">
                        <div id="radarMap"></div>
                    </div>
                    <div class="radar-time-display" id="radarTimeDisplay">
                        <div class="radar-time-main" id="radarTimeMain">--:--</div>
                        <div class="radar-time-delta" id="radarTimeDelta">Chargement...</div>
                    </div>
                    <div class="radar-controls">
                        <button class="radar-btn" id="radarPlayBtn" onclick="playRadar()">▶️</button>
                        <div class="radar-timeline-wrapper">
                            <div class="radar-timeline">
                                <div class="radar-timeline-progress" id="radarProgress" style="width: 100%"></div>
                            </div>
                            <div class="radar-timeline-ticks" id="radarTimelineTicks"></div>
                        </div>
                    </div>
                    <div class="radar-frames-list" id="radarFramesList"></div>
                    <div class="radar-legend">
                        <div class="radar-legend-item">
                            <span class="radar-legend-color" style="background: #88ddff"></span>
                            <span>Légère</span>
                        </div>
                        <div class="radar-legend-item">
                            <span class="radar-legend-color" style="background: #00bb00"></span>
                            <span>Modérée</span>
                        </div>
                        <div class="radar-legend-item">
                            <span class="radar-legend-color" style="background: #ffff00"></span>
                            <span>Forte</span>
                        </div>
                        <div class="radar-legend-item">
                            <span class="radar-legend-color" style="background: #ff8800"></span>
                            <span>Intense</span>
                        </div>
                        <div class="radar-legend-item">
                            <span class="radar-legend-color" style="background: #ff0000"></span>
                            <span>Très intense</span>
                        </div>
                    </div>
                </div>
            `;
        }

        // Carte Marine OpenSeaMap
        let marineChartMap = null;

        function renderMarineChart(lat, lon) {
            return `
                <div class="marine-chart-container" id="marineChartContainer">
                    <div class="marine-chart-header">
                        <div class="marine-chart-title">
                            🗺️ Carte Marine
                            <span class="fullscreen-hint">(double-clic pour agrandir)</span>
                        </div>
                        <div class="marine-chart-source">OpenSeaMap</div>
                    </div>
                    <div class="marine-chart-map" id="marineChartMap"></div>

                    <!-- Contrôles de couches (visible en fullscreen) -->
                    <div class="layer-controls" id="layerControls">
                        <div class="layer-control-title">📑 Couches cartographiques</div>
                        <label class="layer-toggle">
                            <input type="checkbox" id="layerSeamarks" checked onchange="toggleLayer('seamark', this.checked)">
                            ⚓ Balises, bouées & marques
                        </label>
                        <label class="layer-toggle">
                            <input type="checkbox" id="layerDepth" checked onchange="toggleLayer('depth', this.checked)">
                            🌊 Sondes de profondeur
                        </label>
                        <label class="layer-toggle">
                            <input type="checkbox" id="layerHarbours" checked onchange="toggleLayer('harbours', this.checked)">
                            🏠 Ports, marinas & mouillages
                        </label>
                        <label class="layer-toggle">
                            <input type="checkbox" id="layerBathy" checked onchange="toggleLayer('bathy', this.checked)">
                            🌊 Bathymétrie colorée
                        </label>
                        <label class="layer-toggle">
                            <input type="checkbox" id="layerContours" checked onchange="toggleLayer('contours', this.checked)">
                            〰️ Isobathes (lignes profondeur)
                        </label>
                        <label class="layer-toggle">
                            <input type="checkbox" id="layerSST" onchange="toggleLayer('sst', this.checked)">
                            🌡️ Température de mer (SST)
                        </label>

                        <div class="layer-control-title" style="margin-top:12px">🎣 Mode Pêche</div>
                        <label class="layer-toggle">
                            <input type="checkbox" id="layerFishing" onchange="toggleFishingMode(this.checked)">
                            🐟 Zones favorables pêche
                        </label>
                        <div id="fishingInfo" class="fishing-info" style="display:none;">
                            <div class="fishing-data">
                                <span>SST:</span> <span id="sstValue">--</span>°C
                            </div>
                            <div class="fishing-data">
                                <span>Conditions:</span> <span id="fishingCondition">--</span>
                            </div>
                        </div>

                        <div class="layer-control-title" style="margin-top:12px">📍 GPS & Tracking</div>
                        <label class="layer-toggle">
                            <input type="checkbox" id="gpsTracking" onchange="toggleGPSTracking(this.checked)">
                            📡 Suivi GPS temps réel
                        </label>
                        <label class="layer-toggle">
                            <input type="checkbox" id="gpsTrackShow" onchange="toggleGPSTrack(this.checked)">
                            〰️ Afficher la trace
                        </label>
                        <button class="gps-center-btn" onclick="centerOnGPS()">📍 Centrer sur ma position</button>
                        <div id="gpsStatus" class="gps-status">GPS inactif</div>
                    </div>

                    <!-- Légende détaillée (visible en fullscreen) -->
                    <div class="map-legend-detailed" id="mapLegendDetailed">
                        <div class="legend-section">
                            <div class="legend-section-title">🚨 Balisage latéral (AISM-A)</div>
                            <div class="legend-row"><span class="legend-icon" style="background:#e74c3c">▲</span> Bâbord (rouge) - à gauche en entrant</div>
                            <div class="legend-row"><span class="legend-icon" style="background:#27ae60">▲</span> Tribord (vert) - à droite en entrant</div>
                        </div>
                        <div class="legend-section">
                            <div class="legend-section-title">⚠️ Balisage cardinal</div>
                            <div class="legend-row"><span class="legend-icon cardinal-n">▲▲</span> Nord - passer au Nord</div>
                            <div class="legend-row"><span class="legend-icon cardinal-s">▼▼</span> Sud - passer au Sud</div>
                            <div class="legend-row"><span class="legend-icon cardinal-e">▲▼</span> Est - passer à l'Est</div>
                            <div class="legend-row"><span class="legend-icon cardinal-w">▼▲</span> Ouest - passer à l'Ouest</div>
                        </div>
                        <div class="legend-section">
                            <div class="legend-section-title">💡 Feux & Phares</div>
                            <div class="legend-row"><span class="legend-icon light-white">★</span> Feu blanc</div>
                            <div class="legend-row"><span class="legend-icon light-red">★</span> Feu rouge</div>
                            <div class="legend-row"><span class="legend-icon light-green">★</span> Feu vert</div>
                            <div class="legend-row"><span class="legend-icon light-yellow">★</span> Feu jaune/orange</div>
                        </div>
                        <div class="legend-section">
                            <div class="legend-section-title">🌊 Profondeurs (GEBCO)</div>
                            <div class="depth-gradient-large"></div>
                            <div class="depth-labels-large">
                                <span>0m</span><span>5m</span><span>10m</span><span>20m</span><span>50m</span><span>100m</span><span>200m+</span>
                            </div>
                        </div>
                        <div class="legend-section">
                            <div class="legend-section-title">⚓ Infrastructures</div>
                            <div class="legend-row"><span class="legend-icon port-icon">⚓</span> Port / Marina</div>
                            <div class="legend-row"><span class="legend-icon anchor-icon">⚓</span> Zone de mouillage</div>
                            <div class="legend-row"><span class="legend-icon fuel-icon">⛽</span> Station carburant</div>
                            <div class="legend-row"><span class="legend-icon repair-icon">🔧</span> Réparations</div>
                        </div>
                        <div class="legend-section">
                            <div class="legend-section-title">⛔ Dangers & Restrictions</div>
                            <div class="legend-row"><span class="legend-icon danger-icon">☠️</span> Épave / Obstruction</div>
                            <div class="legend-row"><span class="legend-icon rock-icon">▲</span> Rocher / Récif</div>
                            <div class="legend-row"><span class="legend-icon restricted-icon">⊘</span> Zone interdite / Réglementée</div>
                            <div class="legend-row"><span class="legend-icon cable-icon">〰️</span> Câble sous-marin</div>
                        </div>
                        <div class="legend-section">
                            <div class="legend-section-title">🧭 Navigation</div>
                            <div class="legend-row"><span class="legend-icon lane-icon">→</span> Chenal / Rail de navigation</div>
                            <div class="legend-row"><span class="legend-icon separation-icon">║</span> Dispositif de séparation du trafic</div>
                        </div>
                    </div>

                    <!-- Info box compact -->
                    <div class="map-info-box" id="mapInfoBox">
                        <div class="info-coords">📍 <span class="coords" id="mapCoords">${lat.toFixed(4)}°N, ${lon.toFixed(4)}°E</span></div>
                        <div class="info-zoom">🔍 Zoom: <span id="mapZoomLevel">13</span></div>
                        <div class="info-sources">Sources: OpenSeaMap, GEBCO</div>
                    </div>

                    <!-- Légende compacte (mode normal) -->
                    <div class="marine-chart-legend">
                        <div class="marine-legend-item"><span class="legend-marker" style="background:#e74c3c">◀</span> Bâbord</div>
                        <div class="marine-legend-item"><span class="legend-marker" style="background:#27ae60">▶</span> Tribord</div>
                        <div class="marine-legend-item"><span class="legend-marker" style="background:#f1c40f">●</span> Cardinal</div>
                        <div class="marine-legend-item"><span class="legend-marker light">★</span> Phare/Feu</div>
                        <div class="marine-legend-item"><span class="legend-marker port">⚓</span> Port</div>
                        <div class="marine-legend-item"><span class="legend-marker depth"></span> Profondeur</div>
                        <div class="marine-legend-item"><span class="legend-marker" style="background:#e74c3c">☠</span> Danger</div>
                        <div class="marine-legend-item"><span class="legend-marker" style="background:#9b59b6">⊘</span> Interdit</div>
                    </div>
                    <div class="marine-chart-controls">
                        <button class="marine-zoom-btn close-btn" onclick="toggleMarineFullscreen()" title="Fermer (Escape)">✕</button>
                        <button class="marine-zoom-btn expand-btn" onclick="toggleMarineFullscreen()" title="Plein écran">⛶</button>
                        <button class="marine-zoom-btn" onclick="marineChartZoom(1)" title="Zoom +">➕</button>
                        <button class="marine-zoom-btn" onclick="marineChartZoom(-1)" title="Zoom -">➖</button>
                        <button class="marine-zoom-btn" onclick="marineChartCenter()" title="Recentrer">📍</button>
                        <button class="marine-zoom-btn" onclick="toggleMapStyle()" title="Changer le style">🎨</button>
                        <button class="marine-zoom-btn gps-btn" id="gpsToggleBtn" onclick="toggleGPSTracking()" title="Suivi GPS">📡</button>
                        <button class="marine-zoom-btn fishing-btn" id="fishingToggleBtn" onclick="toggleFishingMode()" title="Mode Pêche">🎣</button>
                        <button class="marine-zoom-btn panel-toggle-btn" id="toggleLeftPanel" onclick="toggleMapPanel('left')" title="Masquer/Afficher couches">◀</button>
                        <button class="marine-zoom-btn panel-toggle-btn" id="toggleRightPanel" onclick="toggleMapPanel('right')" title="Masquer/Afficher légende">▶</button>
                    </div>
                </div>
            `;
        }

        async function initMarineChart(lat, lon) {
            // Charger Leaflet si pas déjà chargé
            if (!window.L) {
                const leafletCSS = document.createElement('link');
                leafletCSS.rel = 'stylesheet';
                leafletCSS.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
                document.head.appendChild(leafletCSS);

                await new Promise((resolve) => {
                    const script = document.createElement('script');
                    script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
                    script.onload = resolve;
                    document.head.appendChild(script);
                });
            }

            await new Promise(r => setTimeout(r, 100));

            const mapContainer = document.getElementById('marineChartMap');
            if (!mapContainer) return;

            if (marineChartMap) {
                marineChartMap.remove();
            }

            marineChartMap = L.map('marineChartMap', {
                zoomControl: false,
                attributionControl: false
            }).setView([lat, lon], 13);

            // Couches de base
            marineChartMap._baseLayers = {
                light: L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { maxZoom: 18 }),
                dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { maxZoom: 18 }),
                satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { maxZoom: 18 }),
                osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 18 })
            };
            marineChartMap._currentBaseLayer = 'light';
            marineChartMap._baseLayers.light.addTo(marineChartMap);

            // Couche GEBCO bathymétrie colorée (fond marin avec relief)
            marineChartMap._gebcoLayer = L.tileLayer.wms('https://wms.gebco.net/mapserv?', {
                layers: 'GEBCO_LATEST_SUB_ICE_TOPO',
                format: 'image/png',
                transparent: true,
                opacity: 0.4,
                maxZoom: 18
            });

            // Couche OpenSeaMap (données marines: bouées, phares, ports, etc.)
            // Utiliser plusieurs serveurs pour la redondance
            marineChartMap._seaLayer = L.tileLayer('https://t1.openseamap.org/seamark/{z}/{x}/{y}.png', {
                maxZoom: 18,
                opacity: 1,
                errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
            }).addTo(marineChartMap);

            // Couche de bathymétrie (profondeurs sondes) - OpenSeaMap
            marineChartMap._depthLayer = L.tileLayer('https://t1.openseamap.org/depth/{z}/{x}/{y}.png', {
                maxZoom: 18,
                opacity: 0.7,
                errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
            }).addTo(marineChartMap);

            // Couche des ports/harbours/sport
            marineChartMap._harbourLayer = L.tileLayer('https://t1.openseamap.org/sport/{z}/{x}/{y}.png', {
                maxZoom: 18,
                opacity: 0.9,
                errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
            }).addTo(marineChartMap);

            // Initialiser et ajouter la couche Bathymétrie colorée (GEBCO)
            marineChartMap._bathyLayer = L.tileLayer.wms('https://wms.gebco.net/mapserv?', {
                layers: 'GEBCO_LATEST',
                format: 'image/png',
                transparent: true,
                opacity: 0.5
            }).addTo(marineChartMap);

            // Initialiser et ajouter les isobathes (lignes de profondeur) - EMODnet
            marineChartMap._contoursLayer = L.tileLayer.wms('https://ows.emodnet-bathymetry.eu/wms', {
                layers: 'contours',
                format: 'image/png',
                transparent: true,
                opacity: 0.8,
                styles: ''
            }).addTo(marineChartMap);

            // Afficher les légendes par défaut
            setTimeout(() => {
                showBathyLegend(true);
                showContoursLegend(true);
            }, 500);

            // Marqueur position actuelle (statique)
            marineChartMap._homeMarker = L.circleMarker([lat, lon], {
                radius: 10,
                fillColor: '#e74c3c',
                color: '#fff',
                weight: 3,
                opacity: 1,
                fillOpacity: 0.9
            }).addTo(marineChartMap).bindPopup(`
                <div style="text-align:center">
                    <b>${state.currentCity || 'Position'}</b><br>
                    <small>Lat: ${lat.toFixed(4)}° | Lon: ${lon.toFixed(4)}°</small>
                </div>
            `);

            // Marqueur GPS temps réel (initialement caché)
            marineChartMap._gpsMarker = L.marker([lat, lon], {
                icon: L.divIcon({
                    className: 'gps-marker',
                    html: '<div class="gps-marker-inner"><div class="gps-arrow"></div></div>',
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                })
            });

            // Cercle de précision GPS
            marineChartMap._gpsAccuracy = L.circle([lat, lon], {
                radius: 50,
                color: '#3498db',
                fillColor: '#3498db',
                fillOpacity: 0.15,
                weight: 1
            });

            // Trace du parcours GPS
            marineChartMap._gpsTrack = L.polyline([], {
                color: '#e74c3c',
                weight: 3,
                opacity: 0.7
            });

            // Stocker les coordonnées pour recentrer
            marineChartMap._homeCoords = [lat, lon];
            marineChartMap._gpsTracking = false;
            marineChartMap._gpsWatchId = null;
            marineChartMap._gpsTrackPoints = [];

            // Mettre à jour les coordonnées au survol
            marineChartMap.on('mousemove', (e) => {
                const coordsEl = document.getElementById('mapCoords');
                if (coordsEl) {
                    coordsEl.textContent = `${e.latlng.lat.toFixed(4)}°N, ${e.latlng.lng.toFixed(4)}°E`;
                }
            });

            // Mettre à jour le niveau de zoom
            marineChartMap.on('zoomend', () => {
                const zoomEl = document.getElementById('mapZoomLevel');
                if (zoomEl) {
                    zoomEl.textContent = marineChartMap.getZoom();
                }
            });

            // Double-clic pour fullscreen (évite le conflit avec le pan)
            marineChartMap.doubleClickZoom.disable(); // Désactiver le zoom par double-clic
            marineChartMap.on('dblclick', () => {
                const container = document.getElementById('marineChartContainer');
                if (container && !container.classList.contains('fullscreen')) {
                    toggleMarineFullscreen();
                }
            });
        }

        // Toggle fullscreen
        function toggleMarineFullscreen() {
            const container = document.getElementById('marineChartContainer');
            if (!container) return;

            container.classList.toggle('fullscreen');

            // Invalider la taille de la carte après la transition
            setTimeout(() => {
                if (marineChartMap) {
                    marineChartMap.invalidateSize();
                }
            }, 350);

            // Fermer avec Escape
            if (container.classList.contains('fullscreen')) {
                document.addEventListener('keydown', handleEscapeKey);
            } else {
                document.removeEventListener('keydown', handleEscapeKey);
            }
        }

        function handleEscapeKey(e) {
            if (e.key === 'Escape') {
                const container = document.getElementById('marineChartContainer');
                if (container && container.classList.contains('fullscreen')) {
                    toggleMarineFullscreen();
                }
            }
        }

        // Toggle des panneaux gauche/droite
        function toggleMapPanel(side) {
            if (side === 'left') {
                const layerControls = document.getElementById('layerControls');
                const btn = document.getElementById('toggleLeftPanel');
                if (layerControls) {
                    layerControls.classList.toggle('hidden');
                    btn.textContent = layerControls.classList.contains('hidden') ? '▶' : '◀';
                    btn.style.left = layerControls.classList.contains('hidden') ? '15px' : '240px';
                }
            } else if (side === 'right') {
                const legend = document.getElementById('mapLegendDetailed');
                const btn = document.getElementById('toggleRightPanel');
                if (legend) {
                    legend.classList.toggle('hidden');
                    btn.textContent = legend.classList.contains('hidden') ? '◀' : '▶';
                    btn.style.right = legend.classList.contains('hidden') ? '15px' : '300px';
                }
            }
            // Redimensionner la carte après toggle
            setTimeout(() => {
                if (marineChartMap) marineChartMap.invalidateSize();
            }, 100);
        }

        // Changer le style de carte
        let mapStyleIndex = 0;
        const mapStyles = ['light', 'dark', 'satellite', 'osm'];

        function toggleMapStyle() {
            if (!marineChartMap || !marineChartMap._baseLayers) return;

            // Retirer la couche actuelle
            marineChartMap.removeLayer(marineChartMap._baseLayers[marineChartMap._currentBaseLayer]);

            // Passer au style suivant
            mapStyleIndex = (mapStyleIndex + 1) % mapStyles.length;
            marineChartMap._currentBaseLayer = mapStyles[mapStyleIndex];

            // Ajouter la nouvelle couche (en dessous des autres)
            marineChartMap._baseLayers[marineChartMap._currentBaseLayer].addTo(marineChartMap);
            marineChartMap._baseLayers[marineChartMap._currentBaseLayer].bringToBack();
        }

        // Toggle des couches
        function toggleLayer(layerName, show) {
            if (!marineChartMap) return;

            // Initialiser les couches SST et Bathy si nécessaires
            if (layerName === 'sst' && !marineChartMap._sstLayer) {
                // Couche SST (température de surface) - NOAA/CMEMS
                marineChartMap._sstLayer = L.tileLayer.wms('https://nrt.cmems-du.eu/thredds/wms/METOFFICE-GLO-SST-L4-NRT-OBS-SST-V2', {
                    layers: 'analysed_sst',
                    format: 'image/png',
                    transparent: true,
                    opacity: 0.6,
                    styles: 'boxfill/rainbow',
                    colorscalerange: '270,305' // Kelvin
                });
            }

            if (layerName === 'bathy' && !marineChartMap._bathyLayer) {
                // Bathymétrie colorée - GEBCO WMS
                marineChartMap._bathyLayer = L.tileLayer.wms('https://wms.gebco.net/mapserv?', {
                    layers: 'GEBCO_LATEST',
                    format: 'image/png',
                    transparent: true,
                    opacity: 0.5
                });
            }

            if (layerName === 'contours' && !marineChartMap._contoursLayer) {
                // Isobathes (lignes de profondeur) - EMODnet Bathymetry
                marineChartMap._contoursLayer = L.tileLayer.wms('https://ows.emodnet-bathymetry.eu/wms', {
                    layers: 'contours',
                    format: 'image/png',
                    transparent: true,
                    opacity: 0.8,
                    styles: ''
                });
            }

            const layers = {
                seamark: marineChartMap._seaLayer,
                depth: marineChartMap._depthLayer,
                harbours: marineChartMap._harbourLayer,
                gebco: marineChartMap._gebcoLayer,
                sst: marineChartMap._sstLayer,
                contours: marineChartMap._contoursLayer,
                bathy: marineChartMap._bathyLayer
            };

            const layer = layers[layerName];
            if (layer) {
                if (show) {
                    layer.addTo(marineChartMap);
                    // Afficher la légende correspondante
                    if (layerName === 'bathy') {
                        showBathyLegend(true);
                    }
                    if (layerName === 'sst') {
                        showSSTLegend(true);
                    }
                    if (layerName === 'contours') {
                        showContoursLegend(true);
                    }
                } else {
                    if (marineChartMap.hasLayer(layer)) {
                        marineChartMap.removeLayer(layer);
                    }
                    if (layerName === 'bathy') {
                        showBathyLegend(false);
                    }
                    if (layerName === 'sst') {
                        showSSTLegend(false);
                    }
                    if (layerName === 'contours') {
                        showContoursLegend(false);
                    }
                }
            }
        }

        function showBathyLegend(show) {
            let legend = document.getElementById('bathyLegend');
            if (!legend && show) {
                const container = document.getElementById('marineChartContainer');
                if (container) {
                    legend = document.createElement('div');
                    legend.id = 'bathyLegend';
                    legend.className = 'bathy-legend';
                    legend.innerHTML = `
                        <span style="font-size:0.7rem;color:rgba(255,255,255,0.7)">Profondeur:</span>
                        <div>
                            <div class="bathy-gradient"></div>
                            <div class="bathy-labels">
                                <span>0m</span>
                                <span>50m</span>
                                <span>200m</span>
                                <span>1000m+</span>
                            </div>
                        </div>
                    `;
                    container.appendChild(legend);
                }
            }
            if (legend) {
                legend.style.display = show ? 'flex' : 'none';
            }
        }

        function showSSTLegend(show) {
            let legend = document.getElementById('sstLegend');
            if (!legend && show) {
                const container = document.getElementById('marineChartContainer');
                if (container) {
                    legend = document.createElement('div');
                    legend.id = 'sstLegend';
                    legend.className = 'sst-legend';
                    legend.innerHTML = `
                        <div style="font-size:0.7rem;color:rgba(255,255,255,0.7);margin-bottom:3px">Temp. mer (SST):</div>
                        <div class="sst-gradient"></div>
                        <div class="sst-labels">
                            <span>5°C</span>
                            <span>15°C</span>
                            <span>25°C</span>
                        </div>
                    `;
                    container.appendChild(legend);
                }
            }
            if (legend) {
                legend.style.display = show ? 'block' : 'none';
            }
        }

        function showContoursLegend(show) {
            let legend = document.getElementById('contoursLegend');
            if (!legend && show) {
                const container = document.getElementById('marineChartContainer');
                if (container) {
                    legend = document.createElement('div');
                    legend.id = 'contoursLegend';
                    legend.className = 'contours-legend';
                    legend.innerHTML = `
                        <div style="font-size:0.7rem;color:rgba(255,255,255,0.7);margin-bottom:5px">〰️ Isobathes (EMODnet)</div>
                        <div class="contour-items">
                            <div class="contour-item"><span class="contour-line" style="background:#a8d8ff"></span> 0-10m</div>
                            <div class="contour-item"><span class="contour-line" style="background:#7bc8ff"></span> 10-20m</div>
                            <div class="contour-item"><span class="contour-line" style="background:#4db8ff"></span> 20-50m</div>
                            <div class="contour-item"><span class="contour-line" style="background:#1a9fff"></span> 50-100m</div>
                            <div class="contour-item"><span class="contour-line" style="background:#0077cc"></span> 100-200m</div>
                            <div class="contour-item"><span class="contour-line" style="background:#005599"></span> 200-500m</div>
                            <div class="contour-item"><span class="contour-line" style="background:#003366"></span> 500m+</div>
                        </div>
                    `;
                    container.appendChild(legend);
                }
            }
            if (legend) {
                legend.style.display = show ? 'block' : 'none';
            }
        }

        function marineChartZoom(delta) {
            if (marineChartMap) {
                marineChartMap.setZoom(marineChartMap.getZoom() + delta);
            }
        }

        function marineChartCenter() {
            if (marineChartMap && marineChartMap._homeCoords) {
                marineChartMap.setView(marineChartMap._homeCoords, 13);
            }
        }

        // ========== SUIVI GPS TEMPS RÉEL ==========
        function toggleGPSTracking(forceState) {
            if (!marineChartMap) return;

            const isActive = typeof forceState === 'boolean' ? forceState : !marineChartMap._gpsTracking;
            const btn = document.getElementById('gpsToggleBtn');
            const checkbox = document.getElementById('gpsTracking');
            const statusEl = document.getElementById('gpsStatus');

            if (isActive) {
                // Démarrer le suivi GPS
                if (!navigator.geolocation) {
                    if (statusEl) {
                        statusEl.textContent = 'GPS non disponible';
                        statusEl.className = 'gps-status error';
                    }
                    return;
                }

                marineChartMap._gpsTracking = true;
                if (btn) btn.classList.add('active');
                if (checkbox) checkbox.checked = true;
                if (statusEl) {
                    statusEl.textContent = 'Acquisition GPS...';
                    statusEl.className = 'gps-status';
                }

                // Ajouter le marqueur GPS
                marineChartMap._gpsMarker.addTo(marineChartMap);
                marineChartMap._gpsAccuracy.addTo(marineChartMap);

                // Démarrer le suivi
                marineChartMap._gpsWatchId = navigator.geolocation.watchPosition(
                    (position) => updateGPSPosition(position),
                    (error) => handleGPSError(error),
                    {
                        enableHighAccuracy: true,
                        maximumAge: 5000,
                        timeout: 10000
                    }
                );
            } else {
                // Arrêter le suivi GPS
                marineChartMap._gpsTracking = false;
                if (btn) btn.classList.remove('active');
                if (checkbox) checkbox.checked = false;
                if (statusEl) {
                    statusEl.textContent = 'GPS inactif';
                    statusEl.className = 'gps-status';
                }

                if (marineChartMap._gpsWatchId) {
                    navigator.geolocation.clearWatch(marineChartMap._gpsWatchId);
                    marineChartMap._gpsWatchId = null;
                }

                // Retirer le marqueur GPS
                if (marineChartMap.hasLayer(marineChartMap._gpsMarker)) {
                    marineChartMap.removeLayer(marineChartMap._gpsMarker);
                }
                if (marineChartMap.hasLayer(marineChartMap._gpsAccuracy)) {
                    marineChartMap.removeLayer(marineChartMap._gpsAccuracy);
                }
            }
        }

        function updateGPSPosition(position) {
            if (!marineChartMap || !marineChartMap._gpsTracking) return;

            const lat = position.coords.latitude;
            const lon = position.coords.longitude;
            const accuracy = position.coords.accuracy;
            const heading = position.coords.heading;
            const speed = position.coords.speed;

            // Mettre à jour le marqueur
            marineChartMap._gpsMarker.setLatLng([lat, lon]);
            marineChartMap._gpsAccuracy.setLatLng([lat, lon]);
            marineChartMap._gpsAccuracy.setRadius(accuracy);

            // Rotation selon le cap
            if (heading !== null && !isNaN(heading)) {
                const markerEl = document.querySelector('.gps-marker-inner');
                if (markerEl) {
                    markerEl.style.transform = `rotate(${heading}deg)`;
                }
            }

            // Ajouter au track si activé
            if (document.getElementById('gpsTrackShow')?.checked) {
                marineChartMap._gpsTrackPoints.push([lat, lon]);
                marineChartMap._gpsTrack.setLatLngs(marineChartMap._gpsTrackPoints);
                if (!marineChartMap.hasLayer(marineChartMap._gpsTrack)) {
                    marineChartMap._gpsTrack.addTo(marineChartMap);
                }
            }

            // Mettre à jour le statut
            const statusEl = document.getElementById('gpsStatus');
            if (statusEl) {
                const speedKmh = speed ? (speed * 3.6).toFixed(1) : '--';
                statusEl.innerHTML = `📍 ${lat.toFixed(5)}°, ${lon.toFixed(5)}°<br>Précision: ${accuracy.toFixed(0)}m | Vitesse: ${speedKmh} km/h`;
                statusEl.className = 'gps-status active';
            }

            // Mettre à jour les coordonnées affichées
            const coordsEl = document.getElementById('mapCoords');
            if (coordsEl) {
                coordsEl.textContent = `${lat.toFixed(4)}°N, ${lon.toFixed(4)}°E`;
            }
        }

        function handleGPSError(error) {
            const statusEl = document.getElementById('gpsStatus');
            if (statusEl) {
                let msg = 'Erreur GPS';
                if (error.code === 1) msg = 'GPS refusé par l\'utilisateur';
                if (error.code === 2) msg = 'Position indisponible';
                if (error.code === 3) msg = 'Timeout GPS';
                statusEl.textContent = msg;
                statusEl.className = 'gps-status error';
            }
        }

        function centerOnGPS() {
            if (!marineChartMap) return;

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lon = position.coords.longitude;
                    marineChartMap.setView([lat, lon], 15);
                },
                (error) => handleGPSError(error),
                { enableHighAccuracy: true }
            );
        }

        function toggleGPSTrack(show) {
            if (!marineChartMap) return;

            if (show) {
                if (marineChartMap._gpsTrackPoints.length > 0) {
                    marineChartMap._gpsTrack.setLatLngs(marineChartMap._gpsTrackPoints);
                    marineChartMap._gpsTrack.addTo(marineChartMap);
                }
            } else {
                if (marineChartMap.hasLayer(marineChartMap._gpsTrack)) {
                    marineChartMap.removeLayer(marineChartMap._gpsTrack);
                }
            }
        }

        // ========== MODE PÊCHE ==========
        let fishingModeActive = false;
        let seaSurfaceTemp = null;

        async function toggleFishingMode(forceState) {
            const isActive = typeof forceState === 'boolean' ? forceState : !fishingModeActive;
            fishingModeActive = isActive;

            const btn = document.getElementById('fishingToggleBtn');
            const checkbox = document.getElementById('layerFishing');
            const infoEl = document.getElementById('fishingInfo');

            if (isActive) {
                if (btn) btn.classList.add('active');
                if (checkbox) checkbox.checked = true;
                if (infoEl) infoEl.style.display = 'block';

                // Charger les données SST et activer la couche
                await loadFishingData();
                toggleLayer('sst', true);
                document.getElementById('layerSST').checked = true;
            } else {
                if (btn) btn.classList.remove('active');
                if (checkbox) checkbox.checked = false;
                if (infoEl) infoEl.style.display = 'none';

                toggleLayer('sst', false);
                document.getElementById('layerSST').checked = false;
            }
        }

        async function loadFishingData() {
            if (!state.currentCoords) return;

            const { lat, lon } = state.currentCoords;

            try {
                // Récupérer la température de surface de mer via Open-Meteo Marine
                const response = await fetch(
                    `https://api.open-meteo.com/v1/marine?latitude=${lat}&longitude=${lon}&current=sea_surface_temperature&hourly=sea_surface_temperature`
                );

                if (response.ok) {
                    const data = await response.json();
                    seaSurfaceTemp = data.current?.sea_surface_temperature;

                    updateFishingDisplay();
                }
            } catch (e) {
                console.warn('Erreur chargement données pêche:', e);
                // Fallback: estimation basée sur la saison et la latitude
                estimateFishingConditions();
            }
        }

        function updateFishingDisplay() {
            const sstEl = document.getElementById('sstValue');
            const conditionEl = document.getElementById('fishingCondition');

            if (sstEl) {
                sstEl.textContent = seaSurfaceTemp !== null ? seaSurfaceTemp.toFixed(1) : '--';
            }

            if (conditionEl && seaSurfaceTemp !== null) {
                // Évaluer les conditions de pêche
                let condition = '';
                let cssClass = '';

                // Conditions générales de pêche selon la température
                // (varie selon les espèces ciblées)
                if (seaSurfaceTemp >= 14 && seaSurfaceTemp <= 22) {
                    condition = 'Excellentes (bar, dorade)';
                    cssClass = 'fishing-good';
                } else if (seaSurfaceTemp >= 10 && seaSurfaceTemp <= 26) {
                    condition = 'Bonnes (selon espèces)';
                    cssClass = 'fishing-medium';
                } else if (seaSurfaceTemp < 10) {
                    condition = 'Froides (morue, lieu)';
                    cssClass = 'fishing-medium';
                } else {
                    condition = 'Eau chaude (thon, espadon)';
                    cssClass = 'fishing-medium';
                }

                conditionEl.textContent = condition;
                conditionEl.className = cssClass;
            }
        }

        function estimateFishingConditions() {
            // Estimation basée sur la saison
            const month = new Date().getMonth();
            const lat = state.currentCoords?.lat || 45;

            // Estimation grossière de la SST
            let baseSst = 15; // Température de base
            const seasonalVariation = 8 * Math.sin((month - 3) * Math.PI / 6); // Max en août
            const latitudeEffect = -(lat - 45) * 0.5; // Plus froid vers le nord

            seaSurfaceTemp = baseSst + seasonalVariation + latitudeEffect;
            updateFishingDisplay();
        }

        // ========== COUCHES BATHYMÉTRIE & SST ==========

        // État et fonctions du radar
        let radarMap = null;
        let radarLayer = null;
        let radarFrames = [];
        let currentRadarFrame = 0;
        let radarPlaying = false;
        let radarInterval = null;

        async function initRadar(lat, lon) {
            // Charger Leaflet si pas déjà chargé
            if (!window.L) {
                const leafletCSS = document.createElement('link');
                leafletCSS.rel = 'stylesheet';
                leafletCSS.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
                document.head.appendChild(leafletCSS);

                await new Promise((resolve) => {
                    const script = document.createElement('script');
                    script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
                    script.onload = resolve;
                    document.head.appendChild(script);
                });
            }

            // Attendre que le DOM soit prêt
            await new Promise(r => setTimeout(r, 100));

            const mapContainer = document.getElementById('radarMap');
            if (!mapContainer) return;

            // Initialiser la carte
            if (radarMap) {
                radarMap.remove();
            }

            radarMap = L.map('radarMap', {
                zoomControl: false,
                attributionControl: false
            }).setView([lat, lon], 8);

            // Fond de carte sombre
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                maxZoom: 19
            }).addTo(radarMap);

            // Marqueur position
            L.circleMarker([lat, lon], {
                radius: 6,
                fillColor: '#ff6b35',
                color: '#fff',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.8
            }).addTo(radarMap);

            // Charger les données RainViewer
            try {
                const response = await fetch('https://api.rainviewer.com/public/weather-maps.json');
                const data = await response.json();

                // Séparer passé et prévisions (nowcast)
                const pastFrames = data.radar.past || [];
                const nowcastFrames = data.radar.nowcast || [];

                // Marquer les frames nowcast
                nowcastFrames.forEach(f => f.isNowcast = true);

                radarFrames = pastFrames.concat(nowcastFrames);
                currentRadarFrame = pastFrames.length - 1; // Commencer au présent

                renderRadarFramesList();
                updateRadarFrame();
            } catch (e) {
                console.error('Erreur RainViewer:', e);
            }
        }

        // Afficher la liste des horaires disponibles
        function renderRadarFramesList() {
            const container = document.getElementById('radarFramesList');
            const ticksContainer = document.getElementById('radarTimelineTicks');
            if (!container) return;

            const now = new Date();

            // Générer les boutons pour chaque frame
            container.innerHTML = radarFrames.map((frame, index) => {
                const time = new Date(frame.time * 1000);
                const diffMinutes = Math.round((time - now) / 60000);
                const timeStr = time.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });

                const isFuture = diffMinutes > 0;
                const isNowcast = frame.isNowcast;
                const classes = ['radar-frame-btn'];
                if (index === currentRadarFrame) classes.push('active');
                if (isFuture) classes.push('future');
                if (isNowcast) classes.push('nowcast');

                return `<button class="${classes.join(' ')}" onclick="selectRadarFrame(${index})" title="${isFuture ? 'Prévision' : 'Passé'}: ${diffMinutes > 0 ? '+' : ''}${diffMinutes} min">
                    ${timeStr}
                </button>`;
            }).join('');

            // Générer les ticks de la timeline (premier, milieu, dernier)
            if (ticksContainer && radarFrames.length > 0) {
                const firstTime = new Date(radarFrames[0].time * 1000);
                const lastTime = new Date(radarFrames[radarFrames.length - 1].time * 1000);
                const midIndex = Math.floor(radarFrames.length / 2);
                const midTime = new Date(radarFrames[midIndex].time * 1000);

                const formatTick = (d) => d.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });

                ticksContainer.innerHTML = `
                    <span>${formatTick(firstTime)}</span>
                    <span>|</span>
                    <span>${formatTick(midTime)}</span>
                    <span>|</span>
                    <span>${formatTick(lastTime)}</span>
                `;
            }
        }

        // Sélectionner une frame spécifique
        function selectRadarFrame(index) {
            currentRadarFrame = index;
            updateRadarFrame();

            // Mettre à jour les boutons actifs
            document.querySelectorAll('.radar-frame-btn').forEach((btn, i) => {
                btn.classList.toggle('active', i === index);
            });
        }

        function updateRadarFrame() {
            if (!radarMap || radarFrames.length === 0) return;

            const frame = radarFrames[currentRadarFrame];
            const tileUrl = `https://tilecache.rainviewer.com${frame.path}/256/{z}/{x}/{y}/4/1_1.png`;

            if (radarLayer) {
                radarMap.removeLayer(radarLayer);
            }

            radarLayer = L.tileLayer(tileUrl, {
                opacity: 0.7,
                zIndex: 1000
            }).addTo(radarMap);

            // Mettre à jour l'affichage du temps
            const time = new Date(frame.time * 1000);
            const now = new Date();
            const diffMinutes = Math.round((time - now) / 60000);

            // Formater l'heure locale
            const localTime = time.toLocaleTimeString('fr-FR', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            });

            // Affichage principal de l'heure
            const timeMain = document.getElementById('radarTimeMain');
            if (timeMain) {
                timeMain.textContent = localTime;
            }

            // Affichage du delta et type
            const timeDelta = document.getElementById('radarTimeDelta');
            if (timeDelta) {
                let deltaText;
                let typeText = frame.isNowcast ? '📡 Prévision' : '📍 Observation';

                if (Math.abs(diffMinutes) <= 5) {
                    deltaText = 'Maintenant';
                } else if (diffMinutes > 0) {
                    deltaText = `dans ${diffMinutes} min`;
                } else {
                    deltaText = `il y a ${Math.abs(diffMinutes)} min`;
                }

                timeDelta.textContent = `${typeText} • ${deltaText}`;
                timeDelta.className = 'radar-time-delta ' + (diffMinutes > 0 ? 'future' : 'past');
            }

            // Mettre à jour la barre de progression
            const progress = document.getElementById('radarProgress');
            if (progress) {
                progress.style.width = `${((currentRadarFrame + 1) / radarFrames.length) * 100}%`;
            }
        }

        function playRadar() {
            const playBtn = document.getElementById('radarPlayBtn');

            if (radarPlaying) {
                radarPlaying = false;
                clearInterval(radarInterval);
                if (playBtn) playBtn.textContent = '▶️';
                return;
            }

            radarPlaying = true;
            if (playBtn) playBtn.textContent = '⏸️';
            currentRadarFrame = 0;

            radarInterval = setInterval(() => {
                currentRadarFrame = (currentRadarFrame + 1) % radarFrames.length;
                updateRadarFrame();

                // Mettre à jour les boutons actifs
                document.querySelectorAll('.radar-frame-btn').forEach((btn, i) => {
                    btn.classList.toggle('active', i === currentRadarFrame);
                });

                if (currentRadarFrame === radarFrames.length - 1) {
                    setTimeout(() => {
                        if (radarPlaying) {
                            currentRadarFrame = 0;
                        }
                    }, 2000);
                }
            }, 700);
        }

        // Rendu de la rose des vents SVG
        // Widget vent compact style Windy
        // Wind particles animation state
        let windParticlesAnimation = null;
        let windParticles = [];

        function renderWindWidget(windSpeed, windGust, windDir) {
            const beaufort = kmhToBeaufort(windSpeed);
            const gustBeaufort = kmhToBeaufort(windGust);
            const dirText = getWindDirection(windDir);

            // Générer les segments Beaufort (points)
            let bfDots = '';
            for (let i = 0; i < 12; i++) {
                let cls = 'bf-seg';
                if (i < beaufort) cls += ' active';
                else if (i < gustBeaufort) cls += ' gust';
                bfDots += `<div class="${cls}"></div>`;
            }

            // ID unique pour le canvas
            const canvasId = 'windCanvas' + Date.now();

            // Stocker les données pour l'animation
            window.currentWindData = { speed: windSpeed, gust: windGust, dir: windDir };

            return `
                <div class="wind-particles-container">
                    <canvas id="${canvasId}" class="wind-particles-canvas"></canvas>
                    <div class="wind-particles-overlay">
                        <div class="wind-data-box">
                            <div class="wind-data-speed">
                                ${convertWind(windSpeed, state.units.wind)}<span class="unit">${getWindUnitLabel()}</span>
                            </div>
                            <div class="wind-data-dir">${dirText} (${Math.round(windDir)}°)</div>
                            <div class="wind-data-beaufort">${bfDots}</div>
                        </div>
                        <div class="wind-gust-box">
                            <div class="wind-gust-val">${convertWind(windGust, state.units.wind)}</div>
                            <div class="wind-gust-lbl">Rafales</div>
                        </div>
                    </div>
                    <div class="wind-compass-overlay">
                        <svg viewBox="0 0 55 55">
                            <circle cx="27.5" cy="27.5" r="25" fill="rgba(0,0,0,0.5)" stroke="rgba(255,255,255,0.2)" stroke-width="1"/>
                            <text x="27.5" y="9" fill="rgba(255,255,255,0.7)" font-size="7" text-anchor="middle" font-weight="bold">N</text>
                            <text x="27.5" y="51" fill="rgba(255,255,255,0.4)" font-size="6" text-anchor="middle">S</text>
                            <text x="49" y="30" fill="rgba(255,255,255,0.4)" font-size="6" text-anchor="middle">E</text>
                            <text x="6" y="30" fill="rgba(255,255,255,0.4)" font-size="6" text-anchor="middle">O</text>
                            <g transform="rotate(${windDir + 180}, 27.5, 27.5)">
                                <path d="M27.5,8 L24,20 L27.5,17 L31,20 Z" fill="#4fc3f7"/>
                                <line x1="27.5" y1="17" x2="27.5" y2="40" stroke="#4fc3f7" stroke-width="2"/>
                            </g>
                            <circle cx="27.5" cy="27.5" r="3" fill="white"/>
                        </svg>
                    </div>
                </div>
            `;
        }

        // Initialiser l'animation des particules de vent
        function initWindParticles(canvasId) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * 2;
            canvas.height = rect.height * 2;
            ctx.scale(2, 2);

            const width = rect.width;
            const height = rect.height;

            // Récupérer les données de vent
            const windData = window.currentWindData || { speed: 0, gust: 0, dir: 270 };
            const windSpeed = windData.speed || 0;
            const gustSpeed = windData.gust || 0;

            // Si pas de vent (< 2 km/h), afficher un canvas calme sans animation
            if (windSpeed < 2) {
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.font = '14px -apple-system, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Vent calme', width / 2, height / 2);
                return;
            }

            // +90 pour convertir la direction météo (d'où vient le vent) en direction de flux (où va le vent)
            const windRad = (windData.dir + 90) * Math.PI / 180;
            const normalizedSpeed = Math.min(windSpeed / 10, 4); // Vitesse plus douce

            // Créer les particules réparties sur toute la surface
            const particleCount = Math.min(60 + Math.floor(windSpeed), 150);
            windParticles = [];

            for (let i = 0; i < particleCount; i++) {
                const isGust = gustSpeed > windSpeed * 1.2 && Math.random() < 0.2;
                windParticles.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    length: 15 + Math.random() * 25,
                    speed: 0.3 + Math.random() * normalizedSpeed,
                    opacity: 0.4 + Math.random() * 0.4,
                    isGust: isGust,
                    // Décalage de phase pour que les particules ne soient pas synchronisées
                    phase: Math.random() * Math.PI * 2
                });
            }

            if (windParticlesAnimation) {
                cancelAnimationFrame(windParticlesAnimation);
            }

            function animate() {
                if (!document.getElementById(canvasId)) {
                    cancelAnimationFrame(windParticlesAnimation);
                    return;
                }

                ctx.clearRect(0, 0, width, height);

                windParticles.forEach(p => {
                    const endX = p.x + Math.cos(windRad) * p.length;
                    const endY = p.y + Math.sin(windRad) * p.length;

                    // Dessiner le vecteur/particule
                    if (p.isGust) {
                        ctx.strokeStyle = `rgba(231, 76, 60, ${p.opacity})`; // Rouge pour les rafales
                        ctx.lineWidth = 2;
                    } else {
                        ctx.strokeStyle = `rgba(79, 195, 247, ${p.opacity})`; // Bleu pour le vent
                        ctx.lineWidth = 1.5;
                    }

                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(endX, endY);
                    ctx.lineCap = 'round';
                    ctx.stroke();

                    // Petite pointe de flèche
                    const arrowSize = 4;
                    const arrowAngle = Math.PI / 6;
                    ctx.beginPath();
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(
                        endX - arrowSize * Math.cos(windRad - arrowAngle),
                        endY - arrowSize * Math.sin(windRad - arrowAngle)
                    );
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(
                        endX - arrowSize * Math.cos(windRad + arrowAngle),
                        endY - arrowSize * Math.sin(windRad + arrowAngle)
                    );
                    ctx.stroke();

                    // Déplacer la particule
                    p.x += Math.cos(windRad) * p.speed;
                    p.y += Math.sin(windRad) * p.speed;

                    // Wrap around - réapparaître de l'autre côté avec position Y aléatoire
                    const margin = 50;
                    if (p.x > width + margin) {
                        p.x = -margin;
                        p.y = Math.random() * height;
                    } else if (p.x < -margin) {
                        p.x = width + margin;
                        p.y = Math.random() * height;
                    }
                    if (p.y > height + margin) {
                        p.y = -margin;
                        p.x = Math.random() * width;
                    } else if (p.y < -margin) {
                        p.y = height + margin;
                        p.x = Math.random() * width;
                    }
                });

                windParticlesAnimation = requestAnimationFrame(animate);
            }

            animate();
        }

        // Observer pour initialiser le canvas quand il apparaît
        function setupWindParticlesObserver() {
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1) {
                            const canvas = node.querySelector?.('.wind-particles-canvas') ||
                                          (node.classList?.contains('wind-particles-canvas') ? node : null);
                            if (canvas && canvas.id) {
                                setTimeout(() => initWindParticles(canvas.id), 100);
                            }
                        }
                    });
                });
            });

            observer.observe(document.body, { childList: true, subtree: true });
        }

        // Initialiser l'observer au chargement
        document.addEventListener('DOMContentLoaded', setupWindParticlesObserver);

        // Prédiction de pluie par tranches
        function renderRainForecast(hourlyPrecip, hourlyWeatherCode, hourlyPrecipProb, hourlyTime) {
            // Heure actuelle
            const now = new Date();
            const currentHour = now.getHours();

            // IMPORTANT: Les données API commencent à minuit, pas à l'heure actuelle
            // Il faut trouver l'index correspondant à l'heure actuelle
            let currentIndex = currentHour; // Index de base = heure actuelle (0-23)

            // Si on a les timestamps horaires, utiliser pour plus de précision
            if (hourlyTime && hourlyTime.length > 0) {
                const nowTimestamp = now.getTime();
                currentIndex = hourlyTime.findIndex((t, i) => {
                    const tTime = new Date(t).getTime();
                    const nextTime = hourlyTime[i + 1] ? new Date(hourlyTime[i + 1]).getTime() : tTime + 3600000;
                    return nowTimestamp >= tTime && nowTimestamp < nextTime;
                });
                if (currentIndex === -1) currentIndex = currentHour;
            }

            // Tranches: maintenant, +1h, +2h, +3h, +6h (offsets depuis l'heure actuelle)
            const slots = [
                { label: 'Maint.', offset: 0, addMinutes: 0 },
                { label: '+1h', offset: 1, addMinutes: 60 },
                { label: '+2h', offset: 2, addMinutes: 120 },
                { label: '+3h', offset: 3, addMinutes: 180 },
                { label: '+6h', offset: 6, addMinutes: 360 }
            ];

            // Calculer les précipitations pour chaque tranche
            const rainData = slots.map((slot) => {
                const dataIndex = currentIndex + slot.offset;
                const precip = hourlyPrecip[dataIndex] || 0;
                const code = hourlyWeatherCode[dataIndex] || 0;
                const prob = hourlyPrecipProb ? (hourlyPrecipProb[dataIndex] || 0) : 0;

                // Calculer l'heure locale correspondante
                const futureTime = new Date(now.getTime() + slot.addMinutes * 60000);
                const localTime = futureTime.toLocaleTimeString('fr-FR', {
                    hour: '2-digit',
                    minute: '2-digit'
                });

                let amount = precip;
                let probability = prob;

                let level = 'none';
                let icon = '☀️';

                // Utiliser le code météo WMO comme source principale (plus fiable)
                // Codes WMO: 0=clair, 1-3=nuageux, 45-48=brouillard, 51-57=bruine, 61-67=pluie, 71-77=neige, 80-82=averses, 95-99=orage
                if (code >= 95) {
                    level = 'heavy'; icon = '⛈️'; // Orage
                } else if (code >= 80 && code <= 82) {
                    level = code === 82 ? 'heavy' : (code === 81 ? 'moderate' : 'light');
                    icon = code === 82 ? '⛈️' : '🌧️'; // Averses
                } else if (code >= 61 && code <= 67) {
                    // Pluie: 61=légère, 63=modérée, 65=forte, 66-67=verglaçante
                    if (code >= 65) { level = 'heavy'; icon = '🌧️'; }
                    else if (code >= 63) { level = 'moderate'; icon = '🌧️'; }
                    else { level = 'light'; icon = '🌧️'; }
                } else if (code >= 51 && code <= 57) {
                    level = 'light'; icon = '🌧️'; // Bruine
                } else if (code >= 71 && code <= 77) {
                    level = code >= 75 ? 'heavy' : 'moderate';
                    icon = '🌨️'; // Neige
                } else if (code >= 45 && code <= 48) {
                    level = 'none'; icon = '🌫️'; // Brouillard
                } else if (code === 3) {
                    level = 'none'; icon = '☁️'; // Couvert
                } else if (code === 2) {
                    level = 'none'; icon = '⛅'; // Partiellement nuageux
                } else if (code === 1) {
                    level = 'none'; icon = '🌤️'; // Peu nuageux
                } else if (code === 0) {
                    level = 'none'; icon = '☀️'; // Clair
                } else if (probability >= 70) {
                    level = 'moderate'; icon = '🌧️';
                } else if (probability >= 40) {
                    level = 'light'; icon = '🌧️';
                } else if (amount >= 2) {
                    level = 'heavy'; icon = '🌧️';
                } else if (amount >= 0.5) {
                    level = 'moderate'; icon = '🌧️';
                } else if (amount > 0.1) {
                    level = 'light'; icon = '🌧️';
                }

                return { ...slot, amount, level, icon, localTime, probability, code };
            });

            // Déterminer le statut global
            const maxLevel = rainData.reduce((max, r) => {
                if (r.level === 'heavy') return 'heavy';
                if (r.level === 'moderate' && max !== 'heavy') return 'moderate';
                if (r.level === 'light' && max === 'none') return 'light';
                return max;
            }, 'none');

            const statusText = {
                none: 'Pas de pluie',
                light: 'Pluie légère',
                moderate: 'Pluie modérée',
                heavy: 'Fortes pluies'
            };

            // Mini bar pour les 6 prochaines heures (basé sur les vraies données)
            const miniBar = [];
            for (let i = 0; i < 6; i++) {
                const dataIndex = currentIndex + i;
                const prob = hourlyPrecipProb ? (hourlyPrecipProb[dataIndex] || 0) : 0;
                const precip = hourlyPrecip[dataIndex] || 0;
                const code = hourlyWeatherCode[dataIndex] || 0;

                let lvl = 0;
                // Priorité: code météo > probabilité > quantité
                if (code >= 95 || code === 82) lvl = 5;
                else if (code >= 80 || code >= 65) lvl = 4;
                else if (code >= 61 || code >= 75) lvl = 3;
                else if (code >= 51 || code >= 71) lvl = 2;
                else if (prob >= 50 || precip >= 1) lvl = 3;
                else if (prob >= 30 || precip >= 0.5) lvl = 2;
                else if (prob >= 10 || precip > 0) lvl = 1;

                miniBar.push(lvl);
            }

            return `
                <div class="rain-forecast">
                    <div class="rain-forecast-header">
                        <div class="rain-forecast-title">🌧️ Prévision pluie</div>
                        <div class="rain-status ${maxLevel === 'none' ? 'dry' : maxLevel}">${statusText[maxLevel]}</div>
                    </div>
                    <div class="rain-timeline">
                        ${rainData.map(r => `
                            <div class="rain-slot ${r.level !== 'none' ? (r.level === 'heavy' ? 'heavy-rain' : 'has-rain') : ''}">
                                <div class="rain-slot-time">${r.label}</div>
                                <div class="rain-slot-icon">${r.icon}</div>
                                <div class="rain-slot-amount ${r.level}">${r.probability > 0 ? r.probability + '%' : (r.amount > 0 ? r.amount.toFixed(1) + 'mm' : '-')}</div>
                                <div class="rain-slot-hour">${r.localTime}</div>
                            </div>
                        `).join('')}
                    </div>
                    <div class="rain-mini-bar">
                        ${miniBar.map(lvl => `<div class="rain-mini-segment ${lvl > 0 ? 'level-' + lvl : ''}"></div>`).join('')}
                    </div>
                </div>
            `;
        }

        // Prévision de pluie pour un jour futur (basé sur hourlyData préparé)
        function renderDayRainForecast(hourlyData) {
            if (!hourlyData || hourlyData.length === 0) {
                return `<div class="rain-forecast"><div class="rain-forecast-header">🌧️ Données non disponibles</div></div>`;
            }

            // Tranches: 6h, 9h, 12h, 15h, 18h, 21h
            const slots = [
                { label: '6h', hour: 6 },
                { label: '9h', hour: 9 },
                { label: '12h', hour: 12 },
                { label: '15h', hour: 15 },
                { label: '18h', hour: 18 },
                { label: '21h', hour: 21 }
            ];

            const rainData = slots.map(slot => {
                // Trouver l'heure correspondante dans hourlyData
                const hourData = hourlyData.find(h => parseInt(h.time) === slot.hour);
                if (!hourData) return { ...slot, level: 'none', icon: '❓', probability: 0, amount: 0 };

                const code = hourData.weatherCode;
                const precip = hourData.precipitation || 0;
                const prob = hourData.precipProb || 0;

                let level = 'none';
                let icon = '☀️';

                // Même logique que renderRainForecast
                if (code >= 95) { level = 'heavy'; icon = '⛈️'; }
                else if (code >= 80 && code <= 82) { level = code === 82 ? 'heavy' : 'moderate'; icon = '🌧️'; }
                else if (code >= 61 && code <= 67) {
                    if (code >= 65) { level = 'heavy'; icon = '🌧️'; }
                    else if (code >= 63) { level = 'moderate'; icon = '🌧️'; }
                    else { level = 'light'; icon = '🌧️'; }
                }
                else if (code >= 51 && code <= 57) { level = 'light'; icon = '🌧️'; }
                else if (code >= 71 && code <= 77) { level = code >= 75 ? 'heavy' : 'moderate'; icon = '🌨️'; }
                else if (code >= 45 && code <= 48) { level = 'none'; icon = '🌫️'; }
                else if (code === 3) { level = 'none'; icon = '☁️'; }
                else if (code === 2) { level = 'none'; icon = '⛅'; }
                else if (code === 1) { level = 'none'; icon = '🌤️'; }
                else if (code === 0) { level = 'none'; icon = '☀️'; }
                else if (prob >= 70) { level = 'moderate'; icon = '🌧️'; }
                else if (prob >= 40) { level = 'light'; icon = '🌧️'; }

                return { ...slot, level, icon, probability: prob, amount: precip };
            });

            const maxLevel = rainData.reduce((max, r) => {
                if (r.level === 'heavy') return 'heavy';
                if (r.level === 'moderate' && max !== 'heavy') return 'moderate';
                if (r.level === 'light' && max === 'none') return 'light';
                return max;
            }, 'none');

            const statusText = {
                none: 'Pas de pluie prévue',
                light: 'Pluie légère prévue',
                moderate: 'Pluie modérée prévue',
                heavy: 'Fortes pluies prévues'
            };

            return `
                <div class="rain-forecast">
                    <div class="rain-forecast-header">
                        <div class="rain-forecast-title">🌧️ Prévisions du jour</div>
                        <div class="rain-status ${maxLevel === 'none' ? 'dry' : maxLevel}">${statusText[maxLevel]}</div>
                    </div>
                    <div class="rain-timeline">
                        ${rainData.map(r => `
                            <div class="rain-slot ${r.level !== 'none' ? (r.level === 'heavy' ? 'heavy-rain' : 'has-rain') : ''}">
                                <div class="rain-slot-time">${r.label}</div>
                                <div class="rain-slot-icon">${r.icon}</div>
                                <div class="rain-slot-amount ${r.level}">${r.probability > 0 ? r.probability + '%' : '-'}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // Rendu de l'indicateur de houle compact
        function renderSwellIndicator(swellHeight, swellDir, swellPeriod) {
            return `
                <div class="swell-indicator">
                    <div class="swell-compass" style="width:60px;height:60px;">
                        <svg viewBox="0 0 60 60">
                            <circle cx="30" cy="30" r="26" fill="rgba(0,0,0,0.3)" stroke="rgba(155,89,182,0.3)" stroke-width="1"/>
                            <text x="30" y="9" fill="rgba(255,255,255,0.5)" font-size="6" text-anchor="middle">N</text>
                            <text x="30" y="56" fill="rgba(255,255,255,0.4)" font-size="5" text-anchor="middle">S</text>
                            <text x="54" y="32" fill="rgba(255,255,255,0.4)" font-size="5" text-anchor="middle">E</text>
                            <text x="6" y="32" fill="rgba(255,255,255,0.4)" font-size="5" text-anchor="middle">O</text>
                            <g transform="rotate(${swellDir}, 30, 30)">
                                <path d="M30,10 L27,22 L30,19 L33,22 Z" fill="var(--accent-purple)"/>
                                <line x1="30" y1="19" x2="30" y2="42" stroke="var(--accent-purple)" stroke-width="2"/>
                            </g>
                        </svg>
                    </div>
                    <div class="swell-info" style="flex:1;">
                        <div class="swell-title" style="font-size:0.8rem;margin-bottom:6px;">🌊 Houle</div>
                        <div class="swell-details" style="gap:15px;">
                            <div class="swell-detail">
                                <div class="value" style="font-size:1.1rem;">${getWindDirection(swellDir)}</div>
                                <div class="label">Dir.</div>
                            </div>
                            <div class="swell-detail">
                                <div class="value" style="font-size:1.1rem;">${convertWave(swellHeight)}${getWaveUnit()}</div>
                                <div class="label">Haut.</div>
                            </div>
                            <div class="swell-detail">
                                <div class="value" style="font-size:1.1rem;">${Math.round(swellPeriod || 0)}s</div>
                                <div class="label">Période</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Rendu des marées
        function renderTides(tidesData) {
            if (!tidesData) return '';

            const now = new Date();
            const nextTides = tidesData.tides.filter(t => t.time > now).slice(0, 2);

            return `
                <div class="tides-container">
                    <div class="tides-header">
                        <div class="tides-title">🌊 Marées</div>
                        <div class="tides-coefficient">Coef. ${tidesData.coefficient}</div>
                    </div>
                    <div style="text-align:center;margin-bottom:15px;">
                        <span style="font-size:1.5rem;font-weight:600;">${tidesData.currentHeight}m</span>
                        <span style="font-size:0.8rem;opacity:0.7;"> niveau actuel</span>
                    </div>
                    <div class="tides-times">
                        ${nextTides.map(tide => `
                            <div class="tide-time">
                                <div class="tide-icon">${tide.type === 'high' ? '⬆️' : '⬇️'}</div>
                                <div class="tide-info">
                                    <div class="time">${tide.time.toLocaleTimeString('fr-FR', {hour: '2-digit', minute: '2-digit'})}</div>
                                    <div class="height">${tide.height.toFixed(1)}m</div>
                                    <div class="label">${tide.type === 'high' ? 'Pleine mer' : 'Basse mer'}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    <div style="margin-top:10px;font-size:0.75rem;opacity:0.6;text-align:center;">
                        Marnage: ${tidesData.range.toFixed(1)}m
                    </div>
                </div>
            `;
        }

        // Rendu des infos port
        function renderPortInfo(cityName) {
            const port = portsInfo[cityName];
            if (!port) return '';

            return `
                <div class="port-info">
                    <div class="port-header">
                        <div class="port-title">⚓ ${port.harbor}</div>
                    </div>
                    <div class="port-grid">
                        <div class="port-item">
                            <div class="value">VHF ${port.vhf}</div>
                            <div class="label">Canal radio</div>
                        </div>
                        <div class="port-item">
                            <div class="value">${port.tidalRange}</div>
                            <div class="label">Marnage</div>
                        </div>
                    </div>
                    <div style="margin-top:12px;font-size:0.75rem;">
                        <strong>Services:</strong> ${port.facilities.join(' • ')}
                    </div>
                </div>
            `;
        }

        // Rendu du bulletin côtier
        function renderBulletin(bulletin) {
            if (!bulletin) return '';

            return `
                <div class="bulletin-container">
                    <div class="bulletin-header">
                        <div class="bulletin-title">📋 Bulletin Côtier</div>
                        <div class="bulletin-zone">${bulletin.zone}</div>
                    </div>
                    <div class="bulletin-date">${bulletin.date} - ${bulletin.time}</div>
                    <div class="bulletin-content">
                        ${bulletin.sections.map(section => `
                            <div class="bulletin-section">
                                <div class="bulletin-section-title">${section.title}</div>
                                <div class="bulletin-section-text">${section.text}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // ============== CALCULS ASTRONOMIQUES ==============

        // Calculer le lever et coucher du soleil
        function calculateSunTimes(lat, lon, date = new Date()) {
            const rad = Math.PI / 180;
            const dayOfYear = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / (1000 * 60 * 60 * 24));

            // Équation du temps et déclinaison solaire
            const B = (360 / 365) * (dayOfYear - 81) * rad;
            const EoT = 9.87 * Math.sin(2 * B) - 7.53 * Math.cos(B) - 1.5 * Math.sin(B);
            const decl = 23.45 * Math.sin((360 / 365) * (dayOfYear - 81) * rad);

            // Angle horaire
            const latRad = lat * rad;
            const declRad = decl * rad;
            const cosH = -Math.tan(latRad) * Math.tan(declRad);

            // Vérifier si le soleil se lève/couche
            if (cosH < -1 || cosH > 1) {
                return { sunrise: null, sunset: null, dayLength: cosH < -1 ? 24 : 0, solarNoon: 12 };
            }

            const H = Math.acos(cosH) / rad;
            const solarNoon = 12 - EoT / 60 - lon / 15;
            const sunriseHours = solarNoon - H / 15;
            const sunsetHours = solarNoon + H / 15;

            // Crépuscules
            const cosH_civil = (Math.cos(96 * rad) - Math.sin(latRad) * Math.sin(declRad)) / (Math.cos(latRad) * Math.cos(declRad));
            const cosH_nautic = (Math.cos(102 * rad) - Math.sin(latRad) * Math.sin(declRad)) / (Math.cos(latRad) * Math.cos(declRad));
            const cosH_astro = (Math.cos(108 * rad) - Math.sin(latRad) * Math.sin(declRad)) / (Math.cos(latRad) * Math.cos(declRad));

            const civilDawn = cosH_civil <= 1 && cosH_civil >= -1 ? solarNoon - Math.acos(cosH_civil) / rad / 15 : null;
            const civilDusk = cosH_civil <= 1 && cosH_civil >= -1 ? solarNoon + Math.acos(cosH_civil) / rad / 15 : null;
            const nauticDawn = cosH_nautic <= 1 && cosH_nautic >= -1 ? solarNoon - Math.acos(cosH_nautic) / rad / 15 : null;
            const nauticDusk = cosH_nautic <= 1 && cosH_nautic >= -1 ? solarNoon + Math.acos(cosH_nautic) / rad / 15 : null;
            const astroDawn = cosH_astro <= 1 && cosH_astro >= -1 ? solarNoon - Math.acos(cosH_astro) / rad / 15 : null;
            const astroDusk = cosH_astro <= 1 && cosH_astro >= -1 ? solarNoon + Math.acos(cosH_astro) / rad / 15 : null;

            return {
                sunrise: hoursToTime(sunriseHours),
                sunset: hoursToTime(sunsetHours),
                solarNoon: hoursToTime(solarNoon),
                dayLength: (sunsetHours - sunriseHours) * 60,
                civilDawn: civilDawn ? hoursToTime(civilDawn) : null,
                civilDusk: civilDusk ? hoursToTime(civilDusk) : null,
                nauticDawn: nauticDawn ? hoursToTime(nauticDawn) : null,
                nauticDusk: nauticDusk ? hoursToTime(nauticDusk) : null,
                astroDawn: astroDawn ? hoursToTime(astroDawn) : null,
                astroDusk: astroDusk ? hoursToTime(astroDusk) : null,
                sunriseHours,
                sunsetHours
            };
        }

        // Convertir heures décimales en heure:minutes
        function hoursToTime(hours) {
            if (hours === null || hours === undefined) return null;
            const h = Math.floor(hours);
            const m = Math.round((hours - h) * 60);
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
        }

        // Calculer la phase lunaire
        function calculateMoonPhase(date = new Date()) {
            // Nouvelle lune de référence: 6 janvier 2000
            const refNewMoon = new Date(2000, 0, 6, 18, 14);
            const lunarCycle = 29.53058867; // jours

            const daysSinceRef = (date - refNewMoon) / (1000 * 60 * 60 * 24);
            const lunations = daysSinceRef / lunarCycle;
            const phase = (lunations % 1 + 1) % 1;

            // Illumination approximative
            const illumination = Math.round((1 - Math.cos(phase * 2 * Math.PI)) / 2 * 100);

            let phaseName = '';
            let phaseIcon = '';
            if (phase < 0.03 || phase > 0.97) { phaseName = 'Nouvelle Lune'; phaseIcon = '🌑'; }
            else if (phase < 0.22) { phaseName = 'Premier croissant'; phaseIcon = '🌒'; }
            else if (phase < 0.28) { phaseName = 'Premier quartier'; phaseIcon = '🌓'; }
            else if (phase < 0.47) { phaseName = 'Gibbeuse croissante'; phaseIcon = '🌔'; }
            else if (phase < 0.53) { phaseName = 'Pleine Lune'; phaseIcon = '🌕'; }
            else if (phase < 0.72) { phaseName = 'Gibbeuse décroissante'; phaseIcon = '🌖'; }
            else if (phase < 0.78) { phaseName = 'Dernier quartier'; phaseIcon = '🌗'; }
            else { phaseName = 'Dernier croissant'; phaseIcon = '🌘'; }

            // Prochaines phases importantes
            const daysToNewMoon = ((1 - phase) % 1) * lunarCycle;
            const daysToFullMoon = ((0.5 - phase + 1) % 1) * lunarCycle;

            return {
                phase,
                phaseName,
                phaseIcon,
                illumination,
                daysToNewMoon: Math.round(daysToNewMoon),
                daysToFullMoon: Math.round(daysToFullMoon),
                isWaxing: phase < 0.5
            };
        }

        // Calculer lever/coucher de lune (algorithme amélioré)
        function calculateMoonTimes(lat, lon, date = new Date()) {
            const moonPhase = calculateMoonPhase(date);

            // Algorithme basé sur la formule astronomique simplifiée
            // La lune se lève en moyenne 50 minutes plus tard chaque jour
            // À la nouvelle lune: lune se lève avec le soleil (~6h)
            // À la pleine lune: lune se lève au coucher du soleil (~18h)

            const dayOfYear = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / (1000 * 60 * 60 * 24));

            // Base: nouvelle lune = lever ~6h, pleine lune = lever ~18h
            const baseRiseHour = 6 + (moonPhase.phase * 24); // 0-24h selon phase

            // Correction saisonnière basée sur la latitude
            const latRad = lat * Math.PI / 180;
            const declination = 23.45 * Math.sin(2 * Math.PI * (284 + dayOfYear) / 365);
            const seasonalOffset = latRad * declination / 15; // heures

            // La lune est visible environ 12-14 heures
            const moonVisibleDuration = 12 + Math.abs(Math.cos(moonPhase.phase * 2 * Math.PI)) * 2;

            let moonrise = (baseRiseHour + seasonalOffset) % 24;
            let moonset = (moonrise + moonVisibleDuration) % 24;

            // Normaliser les heures
            if (moonrise < 0) moonrise += 24;
            if (moonset < 0) moonset += 24;

            return {
                moonrise: hoursToTime(moonrise),
                moonset: hoursToTime(moonset),
                moonriseHours: moonrise,
                moonsetHours: moonset
            };
        }

        // Calculer les conditions de pêche
        // dayIndex = 0 pour aujourd'hui, 1 pour demain, etc.
        function calculateFishingConditions(lat, lon, weatherData, marineData = null, dayIndex = 0) {
            const isToday = dayIndex === 0;
            const selectedDate = new Date();
            selectedDate.setDate(selectedDate.getDate() + dayIndex);

            const sunTimes = calculateSunTimes(lat, lon, selectedDate);
            const moonPhase = calculateMoonPhase(selectedDate);
            const now = new Date();
            const currentHour = now.getHours() + now.getMinutes() / 60;

            let score = 50; // Score de base
            let factors = [];

            // 1. Phase lunaire (impact majeur)
            if (moonPhase.phaseName === 'Nouvelle Lune' || moonPhase.phaseName === 'Pleine Lune') {
                score += 20;
                factors.push({ name: 'Phase lunaire', value: 'Favorable', icon: moonPhase.phaseIcon, impact: 'positive' });
            } else if (moonPhase.phaseName.includes('quartier')) {
                score += 10;
                factors.push({ name: 'Phase lunaire', value: 'Modérée', icon: moonPhase.phaseIcon, impact: 'neutral' });
            } else {
                factors.push({ name: 'Phase lunaire', value: 'Moyenne', icon: moonPhase.phaseIcon, impact: 'neutral' });
            }

            // 2. Heures dorées (aube et crépuscule) - Pour les jours futurs, on considère que les heures dorées sont disponibles
            const sunriseH = parseFloat(sunTimes.sunrise?.split(':')[0]) + parseFloat(sunTimes.sunrise?.split(':')[1] || 0) / 60;
            const sunsetH = parseFloat(sunTimes.sunset?.split(':')[0]) + parseFloat(sunTimes.sunset?.split(':')[1] || 0) / 60;

            if (isToday) {
                if (Math.abs(currentHour - sunriseH) < 1.5 || Math.abs(currentHour - sunsetH) < 1.5) {
                    score += 25;
                    factors.push({ name: 'Heure dorée', value: 'Active', icon: '🌅', impact: 'positive' });
                } else if (Math.abs(currentHour - sunriseH) < 3 || Math.abs(currentHour - sunsetH) < 3) {
                    score += 10;
                    factors.push({ name: 'Heure dorée', value: 'Proche', icon: '🌅', impact: 'neutral' });
                } else {
                    factors.push({ name: 'Heure dorée', value: 'Éloignée', icon: '⏰', impact: 'negative' });
                }
            } else {
                // Pour les jours futurs, indiquer les heures optimales
                score += 15; // Bonus moyen car on ne sait pas à quelle heure l'utilisateur pêchera
                factors.push({ name: 'Heures dorées', value: `${sunTimes.sunrise} / ${sunTimes.sunset}`, icon: '🌅', impact: 'positive' });
            }

            // 3. Pression atmosphérique (utiliser données horaires pour les jours futurs)
            let pressure = 1013;
            if (isToday) {
                pressure = weatherData?.current?.pressure_msl || 1013;
            } else {
                // Moyenne de la journée depuis les données horaires si disponibles
                const hourlyStart = dayIndex * 24;
                if (weatherData?.hourly?.pressure_msl) {
                    const dayPressures = weatherData.hourly.pressure_msl.slice(hourlyStart, hourlyStart + 24).filter(p => p !== null);
                    if (dayPressures.length > 0) {
                        pressure = dayPressures.reduce((a, b) => a + b, 0) / dayPressures.length;
                    }
                }
            }
            if (pressure >= 1010 && pressure <= 1020) {
                score += 15;
                factors.push({ name: 'Pression', value: `${Math.round(pressure)} hPa`, icon: '📊', impact: 'positive' });
            } else if (pressure < 1005 || pressure > 1025) {
                score -= 10;
                factors.push({ name: 'Pression', value: `${Math.round(pressure)} hPa`, icon: '📊', impact: 'negative' });
            } else {
                factors.push({ name: 'Pression', value: `${Math.round(pressure)} hPa`, icon: '📊', impact: 'neutral' });
            }

            // 4. Vent
            let windSpeed = 0;
            if (isToday) {
                windSpeed = weatherData?.current?.wind_speed_10m || 0;
            } else {
                windSpeed = weatherData?.daily?.wind_speed_10m_max ? weatherData.daily.wind_speed_10m_max[dayIndex] : 0;
            }
            if (windSpeed < 15) {
                score += 10;
                factors.push({ name: 'Vent', value: `${Math.round(windSpeed)} km/h`, icon: '💨', impact: 'positive' });
            } else if (windSpeed > 30) {
                score -= 20;
                factors.push({ name: 'Vent', value: `${Math.round(windSpeed)} km/h`, icon: '💨', impact: 'negative' });
            } else {
                factors.push({ name: 'Vent', value: `${Math.round(windSpeed)} km/h`, icon: '💨', impact: 'neutral' });
            }

            // 5. Couverture nuageuse / Précipitations
            if (isToday) {
                const cloudCover = weatherData?.current?.cloud_cover || 0;
                if (cloudCover > 30 && cloudCover < 80) {
                    score += 10;
                    factors.push({ name: 'Nuages', value: `${cloudCover}%`, icon: '☁️', impact: 'positive' });
                } else {
                    factors.push({ name: 'Nuages', value: `${cloudCover}%`, icon: '☁️', impact: 'neutral' });
                }
            } else {
                // Pour les jours futurs, utiliser la probabilité de précipitation
                const precipProb = weatherData?.daily?.precipitation_probability_max ? weatherData.daily.precipitation_probability_max[dayIndex] : 0;
                if (precipProb < 20) {
                    score += 10;
                    factors.push({ name: 'Pluie', value: `${precipProb}% prob.`, icon: '🌧️', impact: 'positive' });
                } else if (precipProb > 60) {
                    score -= 15;
                    factors.push({ name: 'Pluie', value: `${precipProb}% prob.`, icon: '🌧️', impact: 'negative' });
                } else {
                    factors.push({ name: 'Pluie', value: `${precipProb}% prob.`, icon: '🌧️', impact: 'neutral' });
                }
            }

            // 6. Marées (si disponible)
            if (state.tidesData) {
                const nextTide = state.tidesData.tides.find(t => t.time > now);
                if (nextTide) {
                    const timeToTide = (nextTide.time - now) / (1000 * 60 * 60);
                    if (timeToTide < 2) {
                        score += 15;
                        factors.push({ name: 'Marée', value: `${nextTide.type === 'high' ? 'PM' : 'BM'} dans ${Math.round(timeToTide * 60)}min`, icon: '🌊', impact: 'positive' });
                    } else {
                        factors.push({ name: 'Marée', value: `${nextTide.type === 'high' ? 'PM' : 'BM'} dans ${Math.round(timeToTide)}h`, icon: '🌊', impact: 'neutral' });
                    }
                }
            }

            // Limiter le score entre 0 et 100
            score = Math.max(0, Math.min(100, score));

            // Déterminer le niveau
            let level = 'moderate';
            let levelText = 'Modéré';
            if (score >= 80) { level = 'excellent'; levelText = 'Excellent'; }
            else if (score >= 65) { level = 'good'; levelText = 'Bon'; }
            else if (score >= 40) { level = 'moderate'; levelText = 'Modéré'; }
            else if (score >= 20) { level = 'poor'; levelText = 'Faible'; }
            else { level = 'bad'; levelText = 'Défavorable'; }

            // Périodes solunarires majeures/mineures
            const solunarPeriods = calculateSolunarPeriods(lat, lon);

            return { score, level, levelText, factors, solunarPeriods };
        }

        // Calcul des périodes solunaires
        function calculateSolunarPeriods(lat, lon) {
            const moonTimes = calculateMoonTimes(lat, lon);
            const now = new Date();
            const periods = [];

            // Périodes majeures: transit lunaire (lune au zénith et au nadir)
            // Périodes mineures: lever et coucher de lune
            const parseTime = (timeStr) => {
                if (!timeStr) return null;
                const [h, m] = timeStr.split(':').map(Number);
                return h + m / 60;
            };

            const moonriseH = parseTime(moonTimes.moonrise);
            const moonsetH = parseTime(moonTimes.moonset);

            if (moonriseH !== null) {
                periods.push({ type: 'minor', start: moonriseH - 0.5, end: moonriseH + 0.5, label: 'Lever lune' });
            }
            if (moonsetH !== null) {
                periods.push({ type: 'minor', start: moonsetH - 0.5, end: moonsetH + 0.5, label: 'Coucher lune' });
            }

            // Transit approximatif
            if (moonriseH !== null && moonsetH !== null) {
                const transit = (moonriseH + (moonsetH > moonriseH ? moonsetH : moonsetH + 24)) / 2;
                periods.push({ type: 'major', start: transit - 1, end: transit + 1, label: 'Transit lune' });
                const antiTransit = (transit + 12) % 24;
                periods.push({ type: 'major', start: antiTransit - 1, end: antiTransit + 1, label: 'Anti-transit' });
            }

            return periods;
        }

        // ============== API HUBEAU (Crues et Débits) ==============

        // Calculer la distance entre deux points (Haversine)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Rayon de la Terre en km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        async function fetchHubeauData(lat, lon, options = {}) {
            const { radius = 50, maxStations = 5, riverName = null } = options;

            try {
                // Construire l'URL de recherche - API v2
                // Note: l'API Hub'Eau utilise distance en km
                let stationsUrl = `https://hubeau.eaufrance.fr/api/v2/hydrometrie/referentiel/stations?latitude=${lat}&longitude=${lon}&distance=${radius}&size=20`;

                // Si un nom de cours d'eau est spécifié, ajouter le filtre
                if (riverName) {
                    stationsUrl += `&libelle_cours_eau=${encodeURIComponent(riverName)}`;
                }

                console.log(`[Hub'Eau] Recherche stations proche de (${lat}, ${lon}) rayon ${radius}km...`);
                console.log(`[Hub'Eau] URL: ${stationsUrl}`);

                const response = await fetch(stationsUrl, {
                    headers: {
                        'Accept': 'application/json'
                    }
                });

                if (!response.ok) {
                    console.error(`[Hub'Eau] Erreur API stations: ${response.status}`);
                    throw new Error(`Hubeau API error: ${response.status}`);
                }

                const data = await response.json();
                console.log(`[Hub'Eau] ${data.count || data.data?.length || 0} stations trouvées`);

                if (!data.data || data.data.length === 0) {
                    console.log('[Hub\'Eau] Aucune station dans la zone');
                    return { stations: [], observations: [], closestStation: null };
                }

                // Filtrer les stations en service et calculer la distance
                const stationsWithDistance = data.data
                    .filter(station => station.en_service !== false)
                    .map(station => ({
                        ...station,
                        distance: calculateDistance(lat, lon,
                            station.latitude_station || station.latitude || lat,
                            station.longitude_station || station.longitude || lon
                        )
                    })).sort((a, b) => a.distance - b.distance);

                console.log(`[Hub'Eau] ${stationsWithDistance.length} stations en service`);

                // La station la plus proche
                const closestStation = stationsWithDistance[0];
                if (closestStation) {
                    console.log(`[Hub'Eau] Station la plus proche: ${closestStation.libelle_station} (${closestStation.code_station}) - ${closestStation.distance?.toFixed(1)}km`);
                }

                // Récupérer les observations pour les stations les plus proches
                const observations = [];
                const stationsToFetch = stationsWithDistance.slice(0, maxStations);

                for (const station of stationsToFetch) {
                    try {
                        // Récupérer HAUTEUR (H) et DEBIT (Q) en temps réel
                        const [heightData, flowData] = await Promise.all([
                            fetchStationObservation(station.code_station, 'H'),
                            fetchStationObservation(station.code_station, 'Q')
                        ]);

                        console.log(`[Hub'Eau] Station ${station.code_station}: H=${heightData?.value || 'N/A'}, Q=${flowData?.value || 'N/A'}`);

                        observations.push({
                            station: station,
                            height: heightData,
                            flow: flowData,
                            distance: station.distance
                        });
                    } catch (e) {
                        console.warn('Erreur observation station:', station.code_station, e);
                    }
                }

                return {
                    stations: stationsWithDistance,
                    observations: observations.filter(o => o.height || o.flow),
                    closestStation: closestStation
                };
            } catch (error) {
                console.error('Erreur Hubeau:', error);
                return { stations: [], observations: [], closestStation: null };
            }
        }

        // Récupérer une observation spécifique (H=hauteur, Q=débit)
        async function fetchStationObservation(stationCode, grandeur = 'H') {
            try {
                // API observations temps réel Hub'Eau v2
                // Utiliser code_station au lieu de code_entite pour les observations
                const url = `https://hubeau.eaufrance.fr/api/v2/hydrometrie/observations_tr?code_entite=${stationCode}&grandeur_hydro=${grandeur}&size=10&sort=desc`;

                console.log(`[Hub'Eau] Fetching ${grandeur} for station ${stationCode}...`);

                const response = await fetch(url, {
                    headers: {
                        'Accept': 'application/json'
                    }
                });

                if (!response.ok) {
                    console.warn(`[Hub'Eau] API response not OK: ${response.status} for station ${stationCode}`);
                    return null;
                }

                const data = await response.json();
                console.log(`[Hub'Eau] Response for ${stationCode} ${grandeur}:`, data.count || 0, 'observations');

                if (!data.data || data.data.length === 0) {
                    console.log(`[Hub'Eau] No data for station ${stationCode} ${grandeur}`);
                    return null;
                }

                // Retourner la dernière observation valide
                const lastObs = data.data[0];
                const rawValue = lastObs.resultat_obs;

                console.log(`[Hub'Eau] Station ${stationCode} ${grandeur} - Valeur brute: ${rawValue}`);

                // Calculer la tendance (si on a assez de données)
                let trend = 'stable';
                if (data.data.length >= 3) {
                    const recent = data.data.slice(0, 3).map(d => d.resultat_obs);
                    const avg = recent.reduce((a, b) => a + b, 0) / recent.length;
                    if (rawValue > avg * 1.05) trend = 'rising';
                    else if (rawValue < avg * 0.95) trend = 'falling';
                }

                // IMPORTANT: Selon la documentation Hub'Eau v2:
                // - Hauteurs (H): en millimètres (mm) -> convertir en mètres (÷1000)
                // - Débits (Q): en litres par seconde (L/s) -> convertir en m³/s (÷1000)
                //
                // MAIS certaines stations peuvent avoir des unités différentes
                // On détecte si la valeur semble déjà être en mètres ou m³/s
                let value;
                if (grandeur === 'H') {
                    // Hauteur: si > 100, c'est probablement en mm
                    // Les rivières françaises dépassent rarement 20m de hauteur
                    if (rawValue > 100) {
                        value = rawValue / 1000; // mm -> m
                    } else {
                        value = rawValue; // Déjà en mètres
                    }
                } else {
                    // Débit: si > 10000, c'est probablement en L/s
                    // Les grands fleuves français dépassent rarement 10000 m³/s
                    if (rawValue > 10000) {
                        value = rawValue / 1000; // L/s -> m³/s
                    } else {
                        value = rawValue; // Déjà en m³/s
                    }
                }

                console.log(`[Hub'Eau] Station ${stationCode} ${grandeur}: ${value.toFixed(2)} ${grandeur === 'H' ? 'm' : 'm³/s'} (brut: ${rawValue})`);

                return {
                    value: value,
                    unit: grandeur === 'H' ? 'm' : 'm³/s',
                    date: lastObs.date_obs,
                    trend: trend,
                    grandeur: grandeur
                };
            } catch (e) {
                return null;
            }
        }

        // Rechercher une station par nom de cours d'eau
        async function searchHubeauByRiver(riverName, lat, lon) {
            return fetchHubeauData(lat, lon, { riverName: riverName, radius: 100 });
        }

        // Récupérer les alertes Vigicrues
        async function fetchVigicruesAlert(lat, lon) {
            try {
                // API Vigicrues pour les alertes de vigilance
                const url = `https://www.vigicrues.gouv.fr/services/1/InfoVigiCru.json`;
                const response = await fetch(url);
                if (!response.ok) return null;

                const data = await response.json();
                return data;
            } catch (error) {
                console.warn('Vigicrues non disponible');
                return null;
            }
        }

        // Déterminer le niveau d'alerte basé sur la hauteur
        function getFloodAlertLevel(height, stationCode) {
            // Seuils génériques (idéalement à récupérer par station)
            // Ces seuils varient selon les stations
            if (height === null || height === undefined) return { level: 'unknown', color: 'gray', text: 'Inconnu' };

            // Seuils approximatifs (en mètres)
            if (height > 4) return { level: 'red', color: '#e74c3c', text: 'Crue majeure', icon: '🔴' };
            if (height > 2.5) return { level: 'orange', color: '#e67e22', text: 'Crue importante', icon: '🟠' };
            if (height > 1.5) return { level: 'yellow', color: '#f1c40f', text: 'Vigilance', icon: '🟡' };
            return { level: 'green', color: '#2ecc71', text: 'Normal', icon: '🟢' };
        }

        // Déterminer si le débit est favorable à la pêche
        // Basé sur l'expérience des pêcheurs et les conditions de sécurité
        function evaluateFlowForFishing(flow, riverType = 'medium') {
            if (flow === null || flow === undefined) {
                return {
                    quality: 'unknown',
                    text: 'Inconnu',
                    icon: '❓',
                    fishable: null,
                    advice: 'Données non disponibles',
                    normalcy: '--'
                };
            }

            // Évaluation basée sur le débit absolu
            // Ces seuils sont des moyennes pour les rivières françaises
            let result = {};

            if (flow < 2) {
                result = {
                    quality: 'critical',
                    text: 'Étiage sévère',
                    color: '#e74c3c',
                    icon: '🔴',
                    fishable: false,
                    advice: '⛔ Pêche déconseillée - Stress des poissons',
                    normalcy: 'Très bas'
                };
            } else if (flow < 10) {
                result = {
                    quality: 'low',
                    text: 'Étiage',
                    color: '#e67e22',
                    icon: '🟠',
                    fishable: true,
                    advice: '⚠️ Eau basse - Pêche possible tôt/tard',
                    normalcy: 'Bas'
                };
            } else if (flow < 50) {
                result = {
                    quality: 'good',
                    text: 'Normal bas',
                    color: '#f1c40f',
                    icon: '🟡',
                    fishable: true,
                    advice: '✅ Bonnes conditions de pêche',
                    normalcy: 'Normal'
                };
            } else if (flow < 150) {
                result = {
                    quality: 'optimal',
                    text: 'Optimal',
                    color: '#2ecc71',
                    icon: '🟢',
                    fishable: true,
                    advice: '🎣 Conditions idéales !',
                    normalcy: 'Normal'
                };
            } else if (flow < 300) {
                result = {
                    quality: 'good',
                    text: 'Normal haut',
                    color: '#f1c40f',
                    icon: '🟡',
                    fishable: true,
                    advice: '✅ Pêche possible - Eau soutenue',
                    normalcy: 'Normal+'
                };
            } else if (flow < 500) {
                result = {
                    quality: 'moderate',
                    text: 'Élevé',
                    color: '#e67e22',
                    icon: '🟠',
                    fishable: true,
                    advice: '⚠️ Courant fort - Prudence',
                    normalcy: 'Haut'
                };
            } else if (flow < 1000) {
                result = {
                    quality: 'high',
                    text: 'Très élevé',
                    color: '#e74c3c',
                    icon: '🔴',
                    fishable: false,
                    advice: '⛔ Crue - Pêche dangereuse',
                    normalcy: 'Très haut'
                };
            } else {
                result = {
                    quality: 'flood',
                    text: 'Crue majeure',
                    color: '#9b59b6',
                    icon: '🟣',
                    fishable: false,
                    advice: '🚫 DANGER - Ne pas approcher',
                    normalcy: 'Crue'
                };
            }

            return result;
        }

        // ============== RENDU MODE EPHEMERIDE ==============

        function renderEphemeride() {
            const lat = state.currentCoords.lat;
            const lon = state.currentCoords.lon;
            const now = new Date();
            const data = state.weatherData;
            const dayIndex = state.selectedDay;
            const isToday = dayIndex === 0;

            // Date du jour sélectionné pour les calculs de lune
            const selectedDate = getSelectedDate();

            // Utiliser les VRAIES données de l'API pour le jour sélectionné
            let sunTimes = {};
            if (data && data.daily && data.daily.sunrise && data.daily.sunset) {
                const daySunrise = data.daily.sunrise[dayIndex] || null;
                const daySunset = data.daily.sunset[dayIndex] || null;
                const daylightDuration = data.daily.sunshine_duration ? data.daily.sunshine_duration[dayIndex] : null;

                // Extraire les heures
                const sunriseTime = daySunrise ? new Date(daySunrise) : null;
                const sunsetTime = daySunset ? new Date(daySunset) : null;

                sunTimes = {
                    sunrise: sunriseTime ? sunriseTime.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }) : '--',
                    sunset: sunsetTime ? sunsetTime.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }) : '--',
                    sunriseHours: sunriseTime ? sunriseTime.getHours() + sunriseTime.getMinutes() / 60 : 7,
                    sunsetHours: sunsetTime ? sunsetTime.getHours() + sunsetTime.getMinutes() / 60 : 18,
                    dayLength: daylightDuration ? daylightDuration / 60 : 600, // en minutes
                    // Calculs approximatifs pour crépuscules (±30-40 min)
                    civilDawn: sunriseTime ? new Date(sunriseTime.getTime() - 30 * 60000).toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }) : '--',
                    civilDusk: sunsetTime ? new Date(sunsetTime.getTime() + 30 * 60000).toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }) : '--',
                    nauticDawn: sunriseTime ? new Date(sunriseTime.getTime() - 60 * 60000).toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }) : '--',
                    nauticDusk: sunsetTime ? new Date(sunsetTime.getTime() + 60 * 60000).toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }) : '--',
                    astroDawn: sunriseTime ? new Date(sunriseTime.getTime() - 90 * 60000).toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }) : '--',
                    astroDusk: sunsetTime ? new Date(sunsetTime.getTime() + 90 * 60000).toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }) : '--',
                    solarNoon: sunriseTime && sunsetTime ? new Date((sunriseTime.getTime() + sunsetTime.getTime()) / 2).toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }) : '--'
                };
            } else {
                // Fallback aux calculs si pas de données API
                sunTimes = calculateSunTimes(lat, lon, selectedDate);
            }

            // Phase lunaire pour le jour sélectionné
            const moonPhase = calculateMoonPhase(selectedDate);
            const moonTimes = calculateMoonTimes(lat, lon, selectedDate);
            const fishingCond = calculateFishingConditions(lat, lon, state.weatherData, state.marineData);

            // Calculer le temps avant lever/coucher (seulement pour aujourd'hui)
            const currentHour = now.getHours() + now.getMinutes() / 60;
            const sunriseH = sunTimes.sunriseHours;
            const sunsetH = sunTimes.sunsetHours;

            let timeToSunEvent = '';
            let sunEventLabel = '';
            if (isToday) {
                if (currentHour < sunriseH) {
                    const mins = Math.round((sunriseH - currentHour) * 60);
                    timeToSunEvent = `${Math.floor(mins/60)}h ${mins%60}min`;
                    sunEventLabel = 'avant lever';
                } else if (currentHour < sunsetH) {
                    const mins = Math.round((sunsetH - currentHour) * 60);
                    timeToSunEvent = `${Math.floor(mins/60)}h ${mins%60}min`;
                    sunEventLabel = 'avant coucher';
                } else {
                    const minsToMidnight = Math.round((24 - currentHour + sunriseH) * 60);
                    timeToSunEvent = `${Math.floor(minsToMidnight/60)}h ${minsToMidnight%60}min`;
                    sunEventLabel = 'avant lever';
                }
            }

            // Position du soleil sur l'arc (0-100%) - seulement pour aujourd'hui
            let sunProgress = 0;
            if (isToday && currentHour >= sunriseH && currentHour <= sunsetH) {
                sunProgress = ((currentHour - sunriseH) / (sunsetH - sunriseH)) * 100;
            } else if (!isToday) {
                sunProgress = 50; // Milieu de journée pour les prévisions
            }

            // Durée du jour
            const dayLengthH = Math.floor(sunTimes.dayLength / 60);
            const dayLengthM = Math.round(sunTimes.dayLength % 60);

            // Date affichée
            const dateStr = selectedDate.toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long' });

            mainContent.innerHTML = `
                <!-- Sélecteur de jours -->
                ${renderDaySelector()}
                ${renderDayIndicator()}

                <div class="ephemeride-container">
                    <!-- Carte Soleil -->
                    <div class="ephemeride-card">
                        <div class="ephemeride-card-title">☀️ Soleil - ${state.currentCity} ${!isToday ? `<span style="color:var(--accent-blue);font-size:0.8rem;">(${getSelectedDayLabel()})</span>` : ''}</div>

                        <div class="sun-arc">
                            <svg viewBox="0 0 200 120" preserveAspectRatio="xMidYMid meet">
                                <!-- Arc de fond -->
                                <path class="sun-arc-path" d="M 20 95 Q 100 10 180 95" />
                                <!-- Horizon -->
                                <line x1="15" y1="95" x2="185" y2="95" stroke="rgba(255,255,255,0.3)" stroke-width="1"/>
                                <!-- Arc de progression -->
                                <path class="sun-arc-progress" d="M 20 95 Q 100 10 180 95"
                                    stroke-dasharray="${sunProgress * 2.6}, 260"
                                    stroke-dashoffset="0"/>
                                <!-- Position du soleil -->
                                ${sunProgress > 0 ? `
                                <circle class="sun-position" cx="${20 + sunProgress * 1.6}" cy="${95 - Math.sin(sunProgress/100 * Math.PI) * 80}" r="10"/>
                                ` : ''}
                                <!-- Labels lever/coucher avec fond pour lisibilité -->
                                <rect x="5" y="100" width="45" height="16" rx="3" fill="rgba(241,196,15,0.2)"/>
                                <text x="27" y="112" fill="#f1c40f" font-size="11" font-weight="600" text-anchor="middle">🌅 ${sunTimes.sunrise || '--'}</text>
                                <rect x="150" y="100" width="45" height="16" rx="3" fill="rgba(230,126,34,0.2)"/>
                                <text x="172" y="112" fill="#e67e22" font-size="11" font-weight="600" text-anchor="middle">🌇 ${sunTimes.sunset || '--'}</text>
                            </svg>
                        </div>

                        ${isToday ? `
                        <div class="countdown-item">
                            <div class="countdown-value">${timeToSunEvent}</div>
                            <div class="countdown-label">${sunEventLabel}</div>
                        </div>
                        ` : `
                        <div class="countdown-item" style="background:rgba(0,180,216,0.1);border-color:var(--accent-blue);">
                            <div class="countdown-value" style="color:var(--accent-blue);">📅 Prévision</div>
                            <div class="countdown-label">${dateStr}</div>
                        </div>
                        `}

                        <div class="ephemeride-times">
                            <div class="ephemeride-time-item">
                                <div class="ephemeride-time-label">Aube civile</div>
                                <div class="ephemeride-time-value">${sunTimes.civilDawn || '--'}</div>
                            </div>
                            <div class="ephemeride-time-item">
                                <div class="ephemeride-time-label">Lever</div>
                                <div class="ephemeride-time-value" style="color:#f1c40f">${sunTimes.sunrise || '--'}</div>
                            </div>
                            <div class="ephemeride-time-item">
                                <div class="ephemeride-time-label">Midi solaire</div>
                                <div class="ephemeride-time-value">${sunTimes.solarNoon || '--'}</div>
                            </div>
                            <div class="ephemeride-time-item">
                                <div class="ephemeride-time-label">Coucher</div>
                                <div class="ephemeride-time-value" style="color:#e67e22">${sunTimes.sunset || '--'}</div>
                            </div>
                            <div class="ephemeride-time-item">
                                <div class="ephemeride-time-label">Crépuscule civil</div>
                                <div class="ephemeride-time-value">${sunTimes.civilDusk || '--'}</div>
                            </div>
                            <div class="ephemeride-time-item">
                                <div class="ephemeride-time-label">Nuit noire</div>
                                <div class="ephemeride-time-value">${sunTimes.astroDusk || '--'}</div>
                            </div>
                        </div>

                        <div style="margin-top:15px;padding:10px;background:rgba(0,0,0,0.2);border-radius:8px;text-align:center;">
                            <span style="color:rgba(255,255,255,0.6);">Durée du jour:</span>
                            <span style="font-weight:600;color:#f1c40f;"> ${dayLengthH}h ${dayLengthM}min</span>
                        </div>
                    </div>

                    <!-- Carte Lune -->
                    <div class="ephemeride-card">
                        <div class="ephemeride-card-title">🌙 Lune</div>

                        <div style="text-align:center;margin:20px 0;">
                            <div style="font-size:4rem;">${moonPhase.phaseIcon}</div>
                            <div style="font-size:1.1rem;font-weight:600;margin-top:10px;">${moonPhase.phaseName}</div>
                            <div style="font-size:0.85rem;color:rgba(255,255,255,0.6);">Illumination: ${moonPhase.illumination}%</div>
                        </div>

                        <div class="ephemeride-times">
                            <div class="ephemeride-time-item">
                                <div class="ephemeride-time-label">Lever lune</div>
                                <div class="ephemeride-time-value">${moonTimes.moonrise || '--'}</div>
                            </div>
                            <div class="ephemeride-time-item">
                                <div class="ephemeride-time-label">Coucher lune</div>
                                <div class="ephemeride-time-value">${moonTimes.moonset || '--'}</div>
                            </div>
                            <div class="ephemeride-time-item">
                                <div class="ephemeride-time-label">Nouvelle lune</div>
                                <div class="ephemeride-time-value">dans ${moonPhase.daysToNewMoon}j</div>
                            </div>
                            <div class="ephemeride-time-item">
                                <div class="ephemeride-time-label">Pleine lune</div>
                                <div class="ephemeride-time-value">dans ${moonPhase.daysToFullMoon}j</div>
                            </div>
                        </div>
                    </div>

                    <!-- Carte Conditions Pêche -->
                    <div class="ephemeride-card">
                        <div class="ephemeride-card-title">🎣 Conditions de pêche</div>

                        <div class="fishing-score ${fishingCond.level}">
                            <div class="fishing-score-value">${fishingCond.score}/100</div>
                            <div class="fishing-score-label">${fishingCond.levelText}</div>
                        </div>

                        <div class="fishing-conditions">
                            ${fishingCond.factors.map(f => `
                                <div class="fishing-condition-item">
                                    <div class="fishing-condition-icon">${f.icon}</div>
                                    <div class="fishing-condition-label">${f.name}</div>
                                    <div class="fishing-condition-value ${f.impact === 'positive' ? 'fishing-good' : f.impact === 'negative' ? 'fishing-poor' : ''}">${f.value}</div>
                                </div>
                            `).join('')}
                        </div>

                        <!-- Périodes solunaires -->
                        <div style="margin-top:20px;">
                            <div style="font-size:0.85rem;font-weight:600;margin-bottom:10px;">📊 Activité solunaire (24h)</div>
                            <div class="solunar-chart">
                                ${Array.from({length: 24}, (_, i) => {
                                    const period = fishingCond.solunarPeriods.find(p =>
                                        (i >= Math.floor(p.start) && i <= Math.ceil(p.end)) ||
                                        (p.start > p.end && (i >= Math.floor(p.start) || i <= Math.ceil(p.end)))
                                    );
                                    const isCurrent = i === now.getHours();
                                    const height = period ? (period.type === 'major' ? 100 : 60) : 20;
                                    return `<div class="solunar-bar ${period?.type || ''} ${isCurrent ? 'current' : ''}" style="height:${height}%" title="${i}h"></div>`;
                                }).join('')}
                            </div>
                            <div style="display:flex;justify-content:space-between;font-size:0.6rem;color:rgba(255,255,255,0.5);">
                                <span>00h</span><span>06h</span><span>12h</span><span>18h</span><span>24h</span>
                            </div>
                        </div>
                    </div>

                    <!-- Compas -->
                    <div class="ephemeride-card">
                        <div class="ephemeride-card-title">🧭 Compas & Position</div>
                        ${renderCompassWidget(state.weatherData?.current?.wind_direction_10m || 0)}
                        <div style="margin-top:15px;text-align:center;">
                            <div style="font-size:0.75rem;color:rgba(255,255,255,0.5);">Position</div>
                            <div style="font-family:monospace;font-size:0.9rem;">
                                ${lat.toFixed(4)}°N, ${lon.toFixed(4)}°E
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Widget Compas réutilisable
        function renderCompassWidget(windDirection) {
            return `
                <div style="display:flex;justify-content:center;margin:20px 0;">
                    <svg viewBox="0 0 120 120" style="width:150px;height:150px;">
                        <!-- Cercle de fond -->
                        <circle cx="60" cy="60" r="55" fill="rgba(0,0,0,0.4)" stroke="rgba(255,255,255,0.2)" stroke-width="2"/>

                        <!-- Points cardinaux -->
                        <text x="60" y="18" fill="#e74c3c" font-size="12" font-weight="bold" text-anchor="middle">N</text>
                        <text x="60" y="110" fill="rgba(255,255,255,0.6)" font-size="10" text-anchor="middle">S</text>
                        <text x="108" y="64" fill="rgba(255,255,255,0.6)" font-size="10" text-anchor="middle">E</text>
                        <text x="12" y="64" fill="rgba(255,255,255,0.6)" font-size="10" text-anchor="middle">O</text>

                        <!-- Marques -->
                        ${[0, 45, 90, 135, 180, 225, 270, 315].map(angle => `
                            <line x1="${60 + 45 * Math.sin(angle * Math.PI / 180)}"
                                  y1="${60 - 45 * Math.cos(angle * Math.PI / 180)}"
                                  x2="${60 + 50 * Math.sin(angle * Math.PI / 180)}"
                                  y2="${60 - 50 * Math.cos(angle * Math.PI / 180)}"
                                  stroke="rgba(255,255,255,0.4)" stroke-width="${angle % 90 === 0 ? 2 : 1}"/>
                        `).join('')}

                        <!-- Aiguille du vent -->
                        <g transform="rotate(${windDirection + 180}, 60, 60)">
                            <polygon points="60,20 55,60 60,55 65,60" fill="var(--accent-blue)"/>
                            <polygon points="60,100 55,60 60,65 65,60" fill="rgba(255,255,255,0.3)"/>
                        </g>

                        <!-- Centre -->
                        <circle cx="60" cy="60" r="5" fill="white"/>
                    </svg>
                </div>
                <div style="text-align:center;font-size:0.8rem;color:rgba(255,255,255,0.7);">
                    Vent: ${getWindDirection(windDirection)} (${windDirection}°)
                </div>
            `;
        }

        // ============== RENDU MODE PECHE ==============

        let fishingMap = null;

        async function renderFishingMode() {
            const lat = state.currentCoords.lat;
            const lon = state.currentCoords.lon;
            const dayIndex = state.selectedDay;
            const isToday = dayIndex === 0;
            const selectedDate = getSelectedDate();

            // Charger les données Hubeau en parallèle (seulement pour aujourd'hui, pas de prévision hydro)
            const hubeauPromise = isToday ? fetchHubeauData(lat, lon) : Promise.resolve({ observations: [] });

            // Phase lunaire pour le jour sélectionné
            const moonPhase = calculateMoonPhase(selectedDate);

            // Conditions de pêche basées sur les données du jour sélectionné
            const fishingCond = calculateFishingConditions(lat, lon, state.weatherData, state.marineData, dayIndex);

            // Utiliser les VRAIES données de lever/coucher du soleil depuis l'API pour le jour sélectionné
            let sunTimes = {};
            const data = state.weatherData;
            if (data && data.daily && data.daily.sunrise && data.daily.sunset) {
                const sunriseTime = new Date(data.daily.sunrise[dayIndex]);
                const sunsetTime = new Date(data.daily.sunset[dayIndex]);
                sunTimes = {
                    sunrise: sunriseTime.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }),
                    sunset: sunsetTime.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' })
                };
            } else {
                // Fallback aux calculs si pas de données API
                const calcTimes = calculateSunTimes(lat, lon, selectedDate);
                sunTimes = { sunrise: calcTimes.sunrise, sunset: calcTimes.sunset };
            }

            // Météo du jour sélectionné
            const dayWeather = data.daily ? {
                weatherCode: data.daily.weather_code ? data.daily.weather_code[dayIndex] : null,
                tempMax: data.daily.temperature_2m_max ? data.daily.temperature_2m_max[dayIndex] : null,
                tempMin: data.daily.temperature_2m_min ? data.daily.temperature_2m_min[dayIndex] : null,
                wind: data.daily.wind_speed_10m_max ? data.daily.wind_speed_10m_max[dayIndex] : null,
                precipProb: data.daily.precipitation_probability_max ? data.daily.precipitation_probability_max[dayIndex] : 0
            } : {};

            mainContent.innerHTML = `
                <!-- Sélecteur de jours -->
                ${renderDaySelector()}
                ${renderDayIndicator()}

                <div class="main-grid">
                    <div class="left-panel">
                        <!-- Carte Pêche -->
                        <div class="weather-card">
                            <div class="panel-title">🗺️ Carte des eaux - ${state.currentCity} ${!isToday ? `<span style="color:var(--accent-blue);font-size:0.8rem;">(${getSelectedDayLabel()})</span>` : ''}</div>
                            <div class="fishing-map-container" id="fishingMapContainer">
                                <div id="fishingMap" style="width:100%;height:100%;"></div>
                            </div>
                            <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;">
                                <button class="btn" onclick="toggleFishingMapFullscreen()">⛶ Plein écran</button>
                                <button class="btn" onclick="centerFishingMap()">📍 Recentrer</button>
                                <button class="btn" onclick="toggleFishingLayer('rivers')" style="background:var(--accent-blue);color:white;">🏞️ Rivières</button>
                                <button class="btn" onclick="toggleFishingLayer('lakes')" style="background:var(--accent-blue);color:white;">💧 Lacs</button>
                                <button class="btn" onclick="toggleFishingLayer('sea')">⚓ Mer</button>
                            </div>
                        </div>

                        <!-- Conditions de pêche -->
                        <div class="weather-card">
                            <div class="panel-title">🎣 ${isToday ? 'Conditions actuelles' : 'Conditions prévues'}</div>

                            ${!isToday ? `
                            <div style="margin-bottom:15px;padding:10px;background:rgba(0,180,216,0.1);border-radius:8px;display:flex;align-items:center;gap:10px;">
                                <span style="font-size:2rem;">${getWeatherIcon(dayWeather.weatherCode, true)}</span>
                                <div>
                                    <div style="font-weight:600;">${getWeatherDesc(dayWeather.weatherCode)}</div>
                                    <div style="font-size:0.8rem;color:rgba(255,255,255,0.7);">
                                        🌡️ ${dayWeather.tempMax ? Math.round(dayWeather.tempMax) : '--'}° / ${dayWeather.tempMin ? Math.round(dayWeather.tempMin) : '--'}°
                                        &nbsp;|&nbsp; 💨 ${dayWeather.wind ? Math.round(dayWeather.wind) : '--'} km/h
                                        &nbsp;|&nbsp; 🌧️ ${dayWeather.precipProb}%
                                    </div>
                                </div>
                            </div>
                            ` : ''}

                            <div class="fishing-score ${fishingCond.level}">
                                <div class="fishing-score-value">${fishingCond.score}/100</div>
                                <div class="fishing-score-label">${fishingCond.levelText}</div>
                            </div>
                            <div class="fishing-conditions">
                                ${fishingCond.factors.map(f => `
                                    <div class="fishing-condition-item">
                                        <div class="fishing-condition-icon">${f.icon}</div>
                                        <div class="fishing-condition-label">${f.name}</div>
                                        <div class="fishing-condition-value ${f.impact === 'positive' ? 'fishing-good' : f.impact === 'negative' ? 'fishing-poor' : ''}">${f.value}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>

                        <!-- Marées si zone côtière -->
                        ${state.tidesData ? `
                        <div class="weather-card">
                            <div class="panel-title">🌊 Marées</div>
                            <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:10px;">
                                <div style="text-align:center;padding:15px;background:rgba(0,0,0,0.3);border-radius:10px;">
                                    <div style="font-size:2rem;font-weight:700;">${state.tidesData.currentHeight}m</div>
                                    <div style="font-size:0.75rem;color:rgba(255,255,255,0.6);">Niveau actuel</div>
                                </div>
                                <div style="text-align:center;padding:15px;background:rgba(0,0,0,0.3);border-radius:10px;">
                                    <div style="font-size:2rem;font-weight:700;">${state.tidesData.coefficient}</div>
                                    <div style="font-size:0.75rem;color:rgba(255,255,255,0.6);">Coefficient</div>
                                </div>
                            </div>
                            <div style="margin-top:15px;">
                                ${state.tidesData.tides.map(t => `
                                    <div style="display:flex;justify-content:space-between;padding:8px 0;border-bottom:1px solid rgba(255,255,255,0.1);">
                                        <span>${t.type === 'high' ? '🔺 PM' : '🔻 BM'}</span>
                                        <span>${t.time.toLocaleTimeString('fr-FR', {hour:'2-digit', minute:'2-digit'})}</span>
                                        <span style="font-weight:600;">${t.height.toFixed(1)}m</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        ` : ''}
                    </div>

                    <div class="side-panel">
                        <!-- Éphéméride compact -->
                        <div class="panel-card">
                            <div class="panel-title">☀️ Éphéméride</div>
                            <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
                                <div style="text-align:center;padding:10px;background:rgba(241,196,15,0.1);border-radius:8px;">
                                    <div style="font-size:0.7rem;color:rgba(255,255,255,0.5);">Lever</div>
                                    <div style="font-size:1rem;font-weight:600;color:#f1c40f;">${sunTimes.sunrise || '--'}</div>
                                </div>
                                <div style="text-align:center;padding:10px;background:rgba(230,126,34,0.1);border-radius:8px;">
                                    <div style="font-size:0.7rem;color:rgba(255,255,255,0.5);">Coucher</div>
                                    <div style="font-size:1rem;font-weight:600;color:#e67e22;">${sunTimes.sunset || '--'}</div>
                                </div>
                            </div>
                            <div style="text-align:center;margin-top:10px;">
                                <span style="font-size:2rem;">${moonPhase.phaseIcon}</span>
                                <div style="font-size:0.8rem;">${moonPhase.phaseName}</div>
                            </div>
                        </div>

                        <!-- Stations hydrométriques -->
                        <div class="panel-card" id="hubeauStations">
                            <div class="panel-title">📊 Stations hydrométriques</div>
                            ${isToday ? `
                            <div class="loading" style="padding:20px;">
                                <div class="loading-spinner" style="width:30px;height:30px;"></div>
                                <p style="font-size:0.8rem;">Chargement des données...</p>
                            </div>
                            ` : `
                            <div style="padding:20px;text-align:center;color:rgba(255,255,255,0.6);">
                                <div style="font-size:2rem;margin-bottom:10px;">📅</div>
                                <div>Données temps réel uniquement</div>
                                <small style="color:rgba(255,255,255,0.4);">Les données hydrométriques ne sont pas disponibles pour les prévisions futures</small>
                                <div style="margin-top:10px;">
                                    <button onclick="selectDay(0)" class="btn" style="font-size:0.8rem;">↩️ Voir aujourd'hui</button>
                                </div>
                            </div>
                            `}
                        </div>

                        <!-- Conseils pêche -->
                        <div class="panel-card">
                            <div class="panel-title">💡 Conseils du jour</div>
                            ${generateFishingTips(fishingCond, moonPhase, sunTimes)}
                        </div>
                    </div>
                </div>
            `;

            // Initialiser la carte
            setTimeout(() => initFishingMap(lat, lon), 200);

            // Charger les données Hubeau
            const hubeauData = await hubeauPromise;
            renderHubeauStations(hubeauData);
        }

        // Initialiser la carte pêche
        async function initFishingMap(lat, lon) {
            if (!window.L) {
                const leafletCSS = document.createElement('link');
                leafletCSS.rel = 'stylesheet';
                leafletCSS.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
                document.head.appendChild(leafletCSS);

                await new Promise((resolve) => {
                    const script = document.createElement('script');
                    script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
                    script.onload = resolve;
                    document.head.appendChild(script);
                });
            }

            await new Promise(r => setTimeout(r, 100));

            const mapEl = document.getElementById('fishingMap');
            if (!mapEl) return;

            fishingMap = L.map('fishingMap', {
                zoomControl: true,
                scrollWheelZoom: true
            }).setView([lat, lon], 12);

            // Fond de carte avec cours d'eau bien visibles (OpenStreetMap standard)
            fishingMap._baseLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '© OpenStreetMap'
            }).addTo(fishingMap);

            // Couche hydrographique WMS (cours d'eau détaillés - France)
            // Utilise les données de la BD CARTHAGE via un service WMS
            fishingMap._waterLayer = L.tileLayer.wms('https://services.sandre.eaufrance.fr/geo/sandre', {
                layers: 'CoursEau_FXX',
                format: 'image/png',
                transparent: true,
                opacity: 0.9,
                attribution: '© Sandre'
            });

            // Couche plans d'eau (lacs, étangs) - France
            fishingMap._lakesLayer = L.tileLayer.wms('https://services.sandre.eaufrance.fr/geo/sandre', {
                layers: 'PlanEau_FXX',
                format: 'image/png',
                transparent: true,
                opacity: 0.7,
                attribution: '© Sandre'
            });

            // Alternative: carte avec mise en valeur de l'eau (Stamen Watercolor style)
            fishingMap._watercolorLayer = L.tileLayer('https://tiles.stadiamaps.com/tiles/stamen_watercolor/{z}/{x}/{y}.jpg', {
                maxZoom: 16,
                attribution: '© Stadia Maps, © Stamen Design'
            });

            // Couche OpenSeaMap pour les zones côtières
            fishingMap._seaLayer = L.tileLayer('https://t1.openseamap.org/seamark/{z}/{x}/{y}.png', {
                maxZoom: 18,
                opacity: 0.8
            });

            // Par défaut: activer la couche des cours d'eau
            fishingMap._waterLayer.addTo(fishingMap);
            fishingMap._lakesLayer.addTo(fishingMap);

            // État des couches
            fishingMap._layerStates = {
                rivers: true,
                lakes: true,
                sea: false,
                watercolor: false
            };

            // Marqueur position
            L.circleMarker([lat, lon], {
                radius: 10,
                fillColor: '#e74c3c',
                color: '#fff',
                weight: 3,
                opacity: 1,
                fillOpacity: 0.9
            }).addTo(fishingMap).bindPopup(`<b>${state.currentCity}</b>`);

            fishingMap._homeCoords = [lat, lon];
        }

        function toggleFishingMapFullscreen() {
            const container = document.getElementById('fishingMapContainer');
            if (container) {
                container.classList.toggle('fullscreen');
                setTimeout(() => {
                    if (fishingMap) fishingMap.invalidateSize();
                }, 300);
            }
        }

        function centerFishingMap() {
            if (fishingMap && fishingMap._homeCoords) {
                fishingMap.setView(fishingMap._homeCoords, 12);
            }
        }

        function toggleFishingLayer(layerType) {
            if (!fishingMap || !fishingMap._layerStates) {
                console.warn('Carte pêche non initialisée');
                return;
            }

            console.log('Toggle layer:', layerType);

            switch(layerType) {
                case 'rivers':
                    if (fishingMap._layerStates.rivers) {
                        fishingMap.removeLayer(fishingMap._waterLayer);
                        fishingMap._layerStates.rivers = false;
                    } else {
                        fishingMap._waterLayer.addTo(fishingMap);
                        fishingMap._layerStates.rivers = true;
                    }
                    break;

                case 'lakes':
                    if (fishingMap._layerStates.lakes) {
                        fishingMap.removeLayer(fishingMap._lakesLayer);
                        fishingMap._layerStates.lakes = false;
                    } else {
                        fishingMap._lakesLayer.addTo(fishingMap);
                        fishingMap._layerStates.lakes = true;
                    }
                    break;

                case 'sea':
                    if (fishingMap._layerStates.sea) {
                        fishingMap.removeLayer(fishingMap._seaLayer);
                        fishingMap._layerStates.sea = false;
                    } else {
                        fishingMap._seaLayer.addTo(fishingMap);
                        fishingMap._layerStates.sea = true;
                    }
                    break;

                case 'watercolor':
                    // Basculer entre carte standard et carte aquarelle
                    if (fishingMap._layerStates.watercolor) {
                        fishingMap.removeLayer(fishingMap._watercolorLayer);
                        fishingMap._baseLayer.addTo(fishingMap);
                        fishingMap._layerStates.watercolor = false;
                    } else {
                        fishingMap.removeLayer(fishingMap._baseLayer);
                        fishingMap._watercolorLayer.addTo(fishingMap);
                        fishingMap._layerStates.watercolor = true;
                    }
                    break;
            }

            // Mettre à jour les boutons visuellement
            updateFishingLayerButtons();
        }

        function updateFishingLayerButtons() {
            if (!fishingMap || !fishingMap._layerStates) return;

            // Retrouver les boutons et mettre à jour leur style
            document.querySelectorAll('[onclick^="toggleFishingLayer"]').forEach(btn => {
                const match = btn.getAttribute('onclick').match(/toggleFishingLayer\('(\w+)'\)/);
                if (match) {
                    const layerType = match[1];
                    const isActive = fishingMap._layerStates[layerType];
                    if (isActive) {
                        btn.style.background = 'var(--accent-blue)';
                        btn.style.color = 'white';
                    } else {
                        btn.style.background = 'rgba(255,255,255,0.1)';
                        btn.style.color = 'rgba(255,255,255,0.8)';
                    }
                }
            });
        }

        // Afficher les stations Hubeau
        function renderHubeauStations(hubeauData) {
            const container = document.getElementById('hubeauStations');
            if (!container) return;

            if (!hubeauData.observations || hubeauData.observations.length === 0) {
                container.innerHTML = `
                    <div class="panel-title">📊 Stations hydrométriques</div>
                    <div style="padding:15px;text-align:center;color:rgba(255,255,255,0.5);">
                        <div style="font-size:2rem;margin-bottom:10px;">📍</div>
                        Aucune station à proximité<br>
                        <small>(rayon de 50 km)</small>
                    </div>
                    <div style="margin-top:10px;">
                        <input type="text" id="riverSearchInput" placeholder="Rechercher un cours d'eau..."
                            style="width:100%;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.2);background:rgba(0,0,0,0.3);color:white;font-size:0.8rem;">
                        <button onclick="searchRiverStation()" class="btn" style="width:100%;margin-top:5px;">🔍 Rechercher</button>
                    </div>
                `;
                return;
            }

            // Station la plus proche en premier
            const closestObs = hubeauData.observations[0];

            const stationsHtml = hubeauData.observations.map((obs, index) => {
                const station = obs.station;
                const heightData = obs.height;
                const flowData = obs.flow;
                const distance = obs.distance;

                // Valeurs
                const height = heightData?.value;
                const flow = flowData?.value;

                // Alertes et évaluations
                const floodAlert = getFloodAlertLevel(height);
                const flowEval = evaluateFlowForFishing(flow);

                // Tendances
                const heightTrend = heightData?.trend || 'stable';
                const flowTrend = flowData?.trend || 'stable';
                const trendIcons = { rising: '↗️', falling: '↘️', stable: '→' };

                // Date de mise à jour
                const updateTime = heightData?.date || flowData?.date;
                const updateStr = updateTime ? new Date(updateTime).toLocaleString('fr-FR', {
                    day: '2-digit', month: '2-digit',
                    hour: '2-digit', minute: '2-digit'
                }) : '--';

                const isClosest = index === 0;

                // Construire le lien Vigicrues pour cette station
                const vigicruesUrl = station.code_station ?
                    `https://www.vigicrues.gouv.fr/niv3-station.php?CdEntViworkaround=${station.code_station}` :
                    'https://www.vigicrues.gouv.fr';

                return `
                    <div class="station-info" style="${isClosest ? 'border: 2px solid var(--accent-blue);' : ''}">
                        <div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:8px;">
                            <div>
                                <div class="station-name">${station.libelle_station || 'Station'}</div>
                                <div style="font-size:0.7rem;color:rgba(255,255,255,0.5);">
                                    🏞️ ${station.libelle_cours_eau || 'Cours d\'eau inconnu'}
                                </div>
                                <div style="font-size:0.65rem;color:rgba(255,255,255,0.4);">
                                    📍 ${station.libelle_commune || ''} ${distance ? `- ${distance.toFixed(1)} km` : ''}
                                </div>
                            </div>
                            ${isClosest ? '<span style="background:var(--accent-blue);color:white;padding:2px 8px;border-radius:10px;font-size:0.65rem;">Plus proche</span>' : ''}
                        </div>

                        <div class="station-data" style="grid-template-columns: repeat(2, 1fr);gap:8px;">
                            <!-- Hauteur -->
                            <div class="station-data-item">
                                <div class="station-data-value" style="color:${floodAlert.color};">
                                    ${height !== null && height !== undefined ? height.toFixed(2) : '--'} m
                                    <span style="font-size:0.7rem;">${trendIcons[heightTrend]}</span>
                                </div>
                                <div class="station-data-label">Hauteur</div>
                            </div>

                            <!-- Débit -->
                            <div class="station-data-item">
                                <div class="station-data-value" style="color:${flowEval.color || '#fff'};">
                                    ${flow !== null && flow !== undefined ? flow.toFixed(1) : '--'} m³/s
                                    <span style="font-size:0.7rem;">${trendIcons[flowTrend]}</span>
                                </div>
                                <div class="station-data-label">Débit</div>
                            </div>
                        </div>

                        <!-- Indicateur de normalité et praticabilité pêche -->
                        <div style="margin-top:10px;padding:10px;background:rgba(0,0,0,0.3);border-radius:8px;">
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
                                <span style="font-size:0.75rem;color:rgba(255,255,255,0.6);">Niveau:</span>
                                <span style="font-size:0.85rem;font-weight:600;color:${flowEval.color || '#fff'};">
                                    ${flowEval.icon || ''} ${flowEval.normalcy || flowEval.text}
                                </span>
                            </div>
                            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
                                <span style="font-size:0.75rem;color:rgba(255,255,255,0.6);">Pêche:</span>
                                <span style="font-size:0.85rem;font-weight:600;color:${flowEval.fishable === true ? '#2ecc71' : flowEval.fishable === false ? '#e74c3c' : '#fff'};">
                                    ${flowEval.fishable === true ? '✅ Praticable' : flowEval.fishable === false ? '⛔ Déconseillée' : '❓ Inconnu'}
                                </span>
                            </div>
                            <div style="font-size:0.7rem;color:rgba(255,255,255,0.7);padding:5px;background:rgba(255,255,255,0.05);border-radius:4px;text-align:center;">
                                ${flowEval.advice || ''}
                            </div>
                        </div>

                        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px;">
                            <div style="font-size:0.6rem;color:rgba(255,255,255,0.4);">
                                Mis à jour: ${updateStr}
                            </div>
                            <a href="${vigicruesUrl}" target="_blank"
                               style="font-size:0.65rem;color:var(--accent-blue);text-decoration:none;">
                                📊 Vigicrues →
                            </a>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `
                <div class="panel-title" style="display:flex;justify-content:space-between;align-items:center;">
                    <span>📊 Stations hydrométriques</span>
                    <span style="font-size:0.7rem;color:rgba(255,255,255,0.5);">${hubeauData.observations.length} station(s)</span>
                </div>

                <!-- Recherche -->
                <div style="margin-bottom:10px;display:flex;gap:5px;">
                    <input type="text" id="riverSearchInput" placeholder="Nom du cours d'eau..."
                        style="flex:1;padding:6px 10px;border-radius:6px;border:1px solid rgba(255,255,255,0.2);background:rgba(0,0,0,0.3);color:white;font-size:0.75rem;">
                    <button onclick="searchRiverStation()" style="padding:6px 12px;border:none;border-radius:6px;background:var(--accent-blue);color:white;cursor:pointer;font-size:0.75rem;">🔍</button>
                </div>

                ${stationsHtml}

                <!-- Liens officiels -->
                <div style="margin-top:12px;padding:10px;background:rgba(52,152,219,0.1);border-radius:8px;border:1px solid rgba(52,152,219,0.3);">
                    <div style="font-size:0.7rem;color:rgba(255,255,255,0.7);margin-bottom:6px;text-align:center;">
                        🔗 Sites officiels de référence
                    </div>
                    <div style="display:flex;gap:8px;justify-content:center;flex-wrap:wrap;">
                        <a href="https://www.vigicrues.gouv.fr" target="_blank"
                           style="display:inline-flex;align-items:center;gap:4px;padding:6px 12px;background:rgba(231,76,60,0.2);border-radius:6px;color:#e74c3c;text-decoration:none;font-size:0.75rem;font-weight:600;">
                            🌊 Vigicrues
                        </a>
                        <a href="https://hubeau.eaufrance.fr/page/api-hydrometrie" target="_blank"
                           style="display:inline-flex;align-items:center;gap:4px;padding:6px 12px;background:rgba(52,152,219,0.2);border-radius:6px;color:#3498db;text-decoration:none;font-size:0.75rem;font-weight:600;">
                            💧 Hub'Eau
                        </a>
                        <a href="https://www.hydro.eaufrance.fr" target="_blank"
                           style="display:inline-flex;align-items:center;gap:4px;padding:6px 12px;background:rgba(46,204,113,0.2);border-radius:6px;color:#2ecc71;text-decoration:none;font-size:0.75rem;font-weight:600;">
                            📈 Hydro
                        </a>
                    </div>
                    <div style="font-size:0.6rem;color:rgba(255,255,255,0.4);text-align:center;margin-top:6px;">
                        Vigicrues = référence officielle vigilance crues
                    </div>
                </div>
            `;
        }

        // Rechercher une station par nom de rivière
        async function searchRiverStation() {
            const input = document.getElementById('riverSearchInput');
            if (!input || !input.value.trim()) return;

            const riverName = input.value.trim();
            const container = document.getElementById('hubeauStations');

            if (container) {
                container.innerHTML = `
                    <div class="panel-title">📊 Recherche en cours...</div>
                    <div class="loading" style="padding:20px;">
                        <div class="loading-spinner" style="width:30px;height:30px;"></div>
                        <p style="font-size:0.8rem;">Recherche "${riverName}"...</p>
                    </div>
                `;
            }

            const hubeauData = await searchHubeauByRiver(riverName, state.currentCoords.lat, state.currentCoords.lon);
            renderHubeauStations(hubeauData);
        }

        // Générer des conseils de pêche
        function generateFishingTips(fishingCond, moonPhase, sunTimes) {
            const tips = [];

            if (fishingCond.score >= 70) {
                tips.push("🎯 Conditions excellentes pour la pêche aujourd'hui !");
            }

            if (moonPhase.phaseName === 'Nouvelle Lune' || moonPhase.phaseName === 'Pleine Lune') {
                tips.push(`🌙 ${moonPhase.phaseName}: activité des poissons accrue`);
            }

            const now = new Date();
            const currentH = now.getHours();
            const sunriseH = parseInt(sunTimes.sunrise?.split(':')[0] || 6);
            const sunsetH = parseInt(sunTimes.sunset?.split(':')[0] || 20);

            if (Math.abs(currentH - sunriseH) < 2) {
                tips.push("🌅 Heure dorée du matin - moment idéal !");
            } else if (Math.abs(currentH - sunsetH) < 2) {
                tips.push("🌆 Heure dorée du soir - les carnassiers chassent");
            } else if (currentH >= sunriseH - 1 && currentH <= sunriseH + 1) {
                tips.push("⏰ Préparez-vous pour l'aube, meilleur moment à venir");
            }

            const pressure = state.weatherData?.current?.pressure_msl || 1013;
            if (pressure > 1020) {
                tips.push("📈 Haute pression: poissons en surface, pêche lente");
            } else if (pressure < 1005) {
                tips.push("📉 Basse pression: poissons actifs en profondeur");
            }

            if (tips.length === 0) {
                tips.push("🎣 Conditions moyennes - patience recommandée");
            }

            return tips.map(tip => `
                <div style="padding:8px 0;border-bottom:1px solid rgba(255,255,255,0.1);font-size:0.8rem;">
                    ${tip}
                </div>
            `).join('');
        }

        function renderWeather() {
            const data = state.weatherData;
            const current = data.current;
            const model = models[state.model];
            const dayIndex = state.selectedDay;
            const isToday = dayIndex === 0;

            // Date affichée selon le jour sélectionné
            const selectedDate = getSelectedDate();
            const dateStr = selectedDate.toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long' });

            // Générer le bulletin côtier si données marines disponibles
            const bulletin = state.marineData ? generateCoastalBulletin(state.currentCity, data, state.marineData) : null;

            // Index de départ pour les données horaires du jour sélectionné
            const hourlyStartIndex = getHourlyIndexForSelectedDay();

            // Si c'est aujourd'hui, commencer à l'heure actuelle, sinon à 0h
            const currentHour = new Date().getHours();
            const startOffset = isToday ? currentHour : 0;
            const sliceStart = hourlyStartIndex + startOffset;
            const sliceEnd = Math.min(sliceStart + 24, data.hourly.time.length);

            const hourlyData = data.hourly.time.slice(sliceStart, sliceEnd).map((t, i) => ({
                time: new Date(t).getHours().toString().padStart(2, '0') + ':00',
                temp: data.hourly.temperature_2m[sliceStart + i],
                wind: data.hourly.wind_speed_10m[sliceStart + i],
                windGust: data.hourly.wind_gusts_10m[sliceStart + i],
                weatherCode: data.hourly.weather_code ? data.hourly.weather_code[sliceStart + i] : null,
                humidity: data.hourly.relative_humidity_2m ? data.hourly.relative_humidity_2m[sliceStart + i] : null,
                precipitation: data.hourly.precipitation ? data.hourly.precipitation[sliceStart + i] : 0,
                precipProb: data.hourly.precipitation_probability ? data.hourly.precipitation_probability[sliceStart + i] : 0,
                isDay: new Date(t).getHours() >= 6 && new Date(t).getHours() < 20
            }));

            const dailyData = data.daily.time.map((t, i) => ({
                day: ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'][new Date(t).getDay()],
                date: new Date(t).toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' }),
                high: data.daily.temperature_2m_max[i],
                low: data.daily.temperature_2m_min[i],
                weatherCode: data.daily.weather_code[i],
                wind: data.daily.wind_speed_10m_max[i],
                windGust: data.daily.wind_gusts_10m_max[i],
                sunrise: data.daily.sunrise ? data.daily.sunrise[i] : null,
                sunset: data.daily.sunset ? data.daily.sunset[i] : null,
                sunshineDuration: data.daily.sunshine_duration ? Math.round(data.daily.sunshine_duration[i] / 3600) : null,
                precipSum: data.daily.precipitation_sum ? data.daily.precipitation_sum[i] : 0,
                precipProb: data.daily.precipitation_probability_max ? data.daily.precipitation_probability_max[i] : 0,
                uvIndex: data.daily.uv_index_max ? data.daily.uv_index_max[i] : null
            }));

            // Pour les jours futurs, utiliser les données daily au lieu de current
            const dayData = data.daily;
            const displayTemp = isToday ? current.temperature_2m : (dayData.temperature_2m_max[dayIndex] + dayData.temperature_2m_min[dayIndex]) / 2;
            const displayTempMax = dayData.temperature_2m_max[dayIndex];
            const displayTempMin = dayData.temperature_2m_min[dayIndex];
            const displayWeatherCode = isToday ? current.weather_code : dayData.weather_code[dayIndex];
            const displayWind = isToday ? current.wind_speed_10m : dayData.wind_speed_10m_max[dayIndex];
            const displayGust = isToday ? current.wind_gusts_10m : dayData.wind_gusts_10m_max[dayIndex];
            const displayWindDir = isToday ? current.wind_direction_10m : (dayData.wind_direction_10m_dominant ? dayData.wind_direction_10m_dominant[dayIndex] : 0);
            const displayHumidity = isToday ? current.relative_humidity_2m : '--';
            const displayPressure = isToday ? current.pressure_msl : '--';
            const displayCloudCover = isToday ? current.cloud_cover : '--';
            const displayPrecip = isToday ? current.precipitation : dayData.precipitation_sum[dayIndex];

            mainContent.innerHTML = `
                <!-- Sélecteur de jours -->
                ${renderDaySelector()}
                ${renderDayIndicator()}

                <div class="main-grid">
                    <div class="left-panel">
                        <div class="weather-card">
                            <div class="current-weather">
                                <span class="weather-icon-large">${getWeatherIcon(displayWeatherCode, true)}</span>
                                <div class="weather-info">
                                    <h1 class="city-name">${state.currentCity}</h1>
                                    <p class="weather-date">${dateStr}${!isToday ? ' <span style="color:var(--accent-blue);">(Prévision)</span>' : ''}</p>
                                    <div class="temp-display">
                                        ${isToday ? `
                                            <span class="temp-main">${convertTemp(displayTemp)}${getTempUnit()}</span>
                                            <span class="temp-feels">Ressenti ${convertTemp(current.apparent_temperature)}${getTempUnit()}</span>
                                        ` : `
                                            <span class="temp-main" style="font-size:2.5rem;">
                                                <span style="color:#e74c3c;">${convertTemp(displayTempMax)}°</span>
                                                <span style="color:rgba(255,255,255,0.5);margin:0 5px;">/</span>
                                                <span style="color:#3498db;">${convertTemp(displayTempMin)}°</span>
                                            </span>
                                            <span class="temp-feels">Max / Min</span>
                                        `}
                                    </div>
                                    <p class="weather-desc">${getWeatherDesc(displayWeatherCode)}</p>
                                </div>
                            </div>

                            <!-- Widget Vent Compact -->
                            ${renderWindWidget(displayWind, displayGust, displayWindDir)}

                            <!-- Prévision Pluie (horaire du jour sélectionné) -->
                            ${isToday ?
                                renderRainForecast(data.hourly.precipitation, data.hourly.weather_code, data.hourly.precipitation_probability, data.hourly.time) :
                                renderDayRainForecast(hourlyData)
                            }

                            <div class="details-grid">
                                <div class="detail-item">
                                    <div class="detail-icon">💧</div>
                                    <div class="detail-value">${displayHumidity}${displayHumidity !== '--' ? '%' : ''}</div>
                                    <div class="detail-label">Humidité</div>
                                </div>
                                <div class="detail-item">
                                    <div class="detail-icon">📊</div>
                                    <div class="detail-value">${displayPressure !== '--' ? convertPressure(displayPressure) + getPressureUnit() : '--'}</div>
                                    <div class="detail-label">Pression</div>
                                </div>
                                <div class="detail-item">
                                    <div class="detail-icon">☁️</div>
                                    <div class="detail-value">${displayCloudCover}${displayCloudCover !== '--' ? '%' : ''}</div>
                                    <div class="detail-label">Couverture</div>
                                </div>
                                <div class="detail-item">
                                    <div class="detail-icon">🌧️</div>
                                    <div class="detail-value">${displayPrecip !== null && displayPrecip !== undefined ? displayPrecip.toFixed(1) : '0'}mm</div>
                                    <div class="detail-label">${isToday ? 'Précipitations' : 'Cumul prévu'}</div>
                                </div>
                            </div>

                            <div class="last-update">
                                Mise à jour: ${state.lastUpdate?.toLocaleTimeString('fr-FR')} - Source: Open-Meteo / ${model.provider}
                            </div>
                        </div>

                        <!-- Graphique Vent/Rafales -->
                        ${renderWindChart(data.hourly.wind_speed_10m, data.hourly.wind_gusts_10m, 24)}

                        <!-- Radar de pluie -->
                        ${renderRainRadar(state.currentCoords.lat, state.currentCoords.lon)}

                        <div class="tabs">
                            <button class="tab-btn active" data-tab="hourly">⏱️ Horaire</button>
                            <button class="tab-btn" data-tab="daily">📅 7 jours</button>
                        </div>

                        <div class="tab-content active" id="tab-hourly">
                            <div class="weather-card">
                                <div class="panel-title">Prévisions horaires (48h)</div>
                                <div class="hourly-scroll">
                                    ${hourlyData.map((h, i) => `
                                        <div class="hour-item ${i === 0 ? 'active' : ''}">
                                            <div class="hour-time">${h.time}</div>
                                            <div class="hour-icon">${getWeatherIcon(h.weatherCode, h.isDay)}</div>
                                            <div class="hour-temp">${convertTemp(h.temp)}°</div>
                                            <div class="hour-wind">${convertWind(h.wind, state.units.wind)}</div>
                                            <div class="hour-gust">↑${convertWind(h.windGust, state.units.wind)}</div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        </div>

                        <div class="tab-content" id="tab-daily">
                            <div class="weather-card">
                                <div class="panel-title">Prévisions 7 jours</div>
                                ${dailyData.map((d, i) => `
                                    <div class="daily-item" style="flex-wrap:wrap;gap:8px;">
                                        <div class="daily-day" style="min-width:50px;">
                                            <div>${i === 0 ? 'Auj.' : d.day}</div>
                                            <div style="font-size:0.65rem;opacity:0.6;">${d.date}</div>
                                        </div>
                                        <span class="daily-icon">${getWeatherIcon(d.weatherCode, true)}</span>
                                        <div class="daily-temps">
                                            <span class="daily-high">${convertTemp(d.high)}°</span>
                                            <span class="daily-low">${convertTemp(d.low)}°</span>
                                        </div>
                                        <div class="daily-rain" style="min-width:45px;text-align:center;">
                                            <div style="font-size:0.75rem;color:${d.precipProb > 50 ? '#3498db' : 'rgba(255,255,255,0.7)'};">${d.precipProb}%</div>
                                            <div style="font-size:0.6rem;opacity:0.5;">pluie</div>
                                        </div>
                                        <div class="daily-sun" style="min-width:40px;text-align:center;">
                                            ${d.sunshineDuration !== null ? `
                                                <div style="font-size:0.75rem;color:#f39c12;">${d.sunshineDuration}h</div>
                                                <div style="font-size:0.6rem;opacity:0.5;">☀️</div>
                                            ` : ''}
                                        </div>
                                        <div class="daily-uv" style="min-width:35px;text-align:center;">
                                            ${d.uvIndex !== null ? `
                                                <div style="font-size:0.75rem;color:${d.uvIndex >= 8 ? '#e74c3c' : d.uvIndex >= 6 ? '#f39c12' : d.uvIndex >= 3 ? '#f1c40f' : '#2ecc71'};">UV ${Math.round(d.uvIndex)}</div>
                                            ` : ''}
                                        </div>
                                        <div class="daily-wind">${convertWind(d.wind, state.units.wind)} ${getWindUnitLabel()}</div>
                                        <div class="daily-gust">↑${convertWind(d.windGust, state.units.wind)}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>

                    <div class="side-panel">
                        <!-- Pression atmosphérique -->
                        <div class="panel-card">
                            <div class="panel-title">📊 Pression atmosphérique</div>
                            <div style="text-align:center;margin-bottom:10px;">
                                <span style="font-size:2rem;font-weight:700;">${convertPressure(current.pressure_msl)}</span>
                                <span style="font-size:0.9rem;opacity:0.7;">${getPressureUnit()}</span>
                            </div>
                            ${renderPressureChart(data.hourly.pressure_msl.slice(0, 40))}
                        </div>

                        <!-- Compas -->
                        <div class="panel-card">
                            <div class="panel-title">🧭 Compas</div>
                            ${renderCompassWidget(current.wind_direction_10m || 0)}
                        </div>

                        <!-- Bulletin côtier si disponible -->
                        ${bulletin ? renderBulletin(bulletin) : ''}

                        <!-- Infos modèle -->
                        <div class="panel-card">
                            <div class="panel-title">ℹ️ Modèle ${model.name}</div>
                            <div class="marine-grid" style="gap:8px">
                                <div class="marine-item">
                                    <div class="marine-info">
                                        <div class="value">${model.resolution}</div>
                                        <div class="label">Résolution</div>
                                    </div>
                                </div>
                                <div class="marine-item">
                                    <div class="marine-info">
                                        <div class="value">${model.range}</div>
                                        <div class="label">Portée</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            setupTabs();
            // Initialiser le radar après le rendu
            setTimeout(() => initRadar(state.currentCoords.lat, state.currentCoords.lon), 200);
        }

        function renderMarine() {
            const weather = state.weatherData;
            const marine = state.marineData;
            const model = models[state.model];
            const current = weather.current;
            const marineCurrent = marine.current;
            const dayIndex = state.selectedDay;
            const isToday = dayIndex === 0;

            // Index de début pour les données horaires du jour sélectionné
            const hourlyStartIndex = dayIndex * 24;

            // Pour les jours futurs, utiliser la moyenne des données horaires
            let waveHeight, windSpeed, windGust, windDir, wavePeriod, waveDir, swellHeight, swellDir, swellPeriod;

            if (isToday) {
                waveHeight = marineCurrent.wave_height || 0;
                windSpeed = current.wind_speed_10m || 0;
                windGust = current.wind_gusts_10m || 0;
                windDir = current.wind_direction_10m || 0;
                wavePeriod = marineCurrent.wave_period || 0;
                waveDir = marineCurrent.wave_direction || 0;
                swellHeight = marineCurrent.swell_wave_height || 0;
                swellDir = marineCurrent.swell_wave_direction || 0;
                swellPeriod = marineCurrent.swell_wave_period || 0;
            } else {
                // Moyenne des données horaires du jour sélectionné
                const dayWaveHeights = marine.hourly.wave_height.slice(hourlyStartIndex, hourlyStartIndex + 24).filter(v => v !== null);
                waveHeight = dayWaveHeights.length > 0 ? Math.max(...dayWaveHeights) : 0; // Max de la journée
                windSpeed = weather.daily.wind_speed_10m_max ? weather.daily.wind_speed_10m_max[dayIndex] : 0;
                windGust = weather.daily.wind_gusts_10m_max ? weather.daily.wind_gusts_10m_max[dayIndex] : 0;
                windDir = weather.daily.wind_direction_10m_dominant ? weather.daily.wind_direction_10m_dominant[dayIndex] : 0;

                const dayWavePeriods = marine.hourly.wave_period ? marine.hourly.wave_period.slice(hourlyStartIndex, hourlyStartIndex + 24).filter(v => v !== null) : [];
                wavePeriod = dayWavePeriods.length > 0 ? dayWavePeriods.reduce((a, b) => a + b, 0) / dayWavePeriods.length : 0;

                const dayWaveDirs = marine.hourly.wave_direction ? marine.hourly.wave_direction.slice(hourlyStartIndex, hourlyStartIndex + 24).filter(v => v !== null) : [];
                waveDir = dayWaveDirs.length > 0 ? dayWaveDirs[Math.floor(dayWaveDirs.length / 2)] : 0;

                // Houle
                const daySwellHeights = marine.hourly.swell_wave_height ? marine.hourly.swell_wave_height.slice(hourlyStartIndex, hourlyStartIndex + 24).filter(v => v !== null) : [];
                swellHeight = daySwellHeights.length > 0 ? Math.max(...daySwellHeights) : 0;
                swellDir = marine.hourly.swell_wave_direction ? (marine.hourly.swell_wave_direction[hourlyStartIndex + 12] || 0) : 0;
                swellPeriod = marine.hourly.swell_wave_period ? (marine.hourly.swell_wave_period[hourlyStartIndex + 12] || 0) : 0;
            }

            const seaStateIndex = getSeaState(waveHeight);
            const seaState = seaStates[seaStateIndex];

            const safetyLevel = seaStateIndex <= 3 ? 'safe' : seaStateIndex <= 5 ? 'warning' : 'danger';
            const safetyIcon = safetyLevel === 'safe' ? '✅' : safetyLevel === 'warning' ? '⚠️' : '🚨';
            const safetyTitle = safetyLevel === 'safe' ? 'Conditions favorables' :
                               safetyLevel === 'warning' ? 'Prudence recommandée' : 'Navigation déconseillée';

            const bulletin = generateCoastalBulletin(state.currentCity, weather, marine);

            // Données horaires pour graphiques (slice selon le jour)
            const sliceStart = isToday ? 0 : hourlyStartIndex;
            const sliceEnd = Math.min(sliceStart + 24, marine.hourly.time.length);

            const marineHourly = marine.hourly.time.slice(sliceStart, sliceEnd).map((t, i) => ({
                time: new Date(t).getHours().toString().padStart(2, '0') + ':00',
                waveHeight: marine.hourly.wave_height[sliceStart + i],
                wind: weather.hourly.wind_speed_10m[sliceStart + i],
                windGust: weather.hourly.wind_gusts_10m[sliceStart + i]
            }));

            mainContent.innerHTML = `
                <!-- Sélecteur de jours -->
                ${renderDaySelector()}
                ${renderDayIndicator()}

                <div class="safety-alert ${safetyLevel}">
                    <span class="safety-icon">${safetyIcon}</span>
                    <div class="safety-text">
                        <div class="title">${safetyTitle}${!isToday ? ' (Prévision)' : ''}</div>
                        <div class="desc">Mer ${seaState.name.toLowerCase()} - ${seaState.desc}</div>
                    </div>
                    <span class="model-tag ${model.isHD ? 'hd' : ''}">${model.name}</span>
                </div>

                <div class="main-grid">
                    <div class="left-panel">
                        <div class="weather-card">
                            <div class="panel-title">🌊 État de la mer <span class="model-tag ${model.isHD ? 'hd' : ''}">${model.name} ${model.resolution}</span></div>

                            <div class="wave-visual">
                                <div class="wave-line"></div>
                                <div class="wave-stats">
                                    <div class="wave-height-value">${convertWave(waveHeight)}${getWaveUnit()}</div>
                                    <div class="wave-height-label">Hauteur des vagues</div>
                                </div>
                            </div>

                            <div class="sea-state-bar">
                                <div class="sea-state-marker" style="left: ${(seaStateIndex / 9) * 100}%"></div>
                            </div>
                            <div class="sea-state-labels">
                                <span>Calme</span>
                                <span>Agitée</span>
                                <span>Forte</span>
                                <span>Grosse</span>
                                <span>Énorme</span>
                            </div>

                            <!-- Widget Vent Compact Marine -->
                            ${renderWindWidget(windSpeed, windGust, windDir)}

                            <!-- Prévision Pluie -->
                            ${isToday ?
                                renderRainForecast(weather.hourly.precipitation, weather.hourly.weather_code, weather.hourly.precipitation_probability, weather.hourly.time) :
                                renderDayRainForecast(marineHourly.map((h, i) => ({
                                    time: h.time,
                                    weatherCode: weather.hourly.weather_code ? weather.hourly.weather_code[sliceStart + i] : null,
                                    precipitation: weather.hourly.precipitation ? weather.hourly.precipitation[sliceStart + i] : 0,
                                    precipProb: weather.hourly.precipitation_probability ? weather.hourly.precipitation_probability[sliceStart + i] : 0
                                })))
                            }

                            <!-- Indicateur de houle -->
                            ${renderSwellIndicator(swellHeight, swellDir, swellPeriod)}

                            <!-- Graphique hauteur des vagues -->
                            ${renderWaveChart(marine.hourly.wave_height.slice(sliceStart, sliceEnd), 24)}

                            <!-- Graphique Vent/Rafales Marine -->
                            ${renderWindChart(weather.hourly.wind_speed_10m.slice(sliceStart, sliceEnd), weather.hourly.wind_gusts_10m.slice(sliceStart, sliceEnd), 24)}

                            <div class="marine-grid" style="margin-top:15px">
                                <div class="marine-item">
                                    <span class="marine-icon">🌊</span>
                                    <div class="marine-info">
                                        <div class="value">${Math.round(wavePeriod)}s</div>
                                        <div class="label">Période vagues</div>
                                    </div>
                                </div>
                                <div class="marine-item">
                                    <span class="marine-icon">🧭</span>
                                    <div class="marine-info">
                                        <div class="value">${getWindDirection(waveDir)}</div>
                                        <div class="label">Dir. vagues</div>
                                    </div>
                                </div>
                            </div>

                            <div class="last-update">
                                Mise à jour: ${state.lastUpdate?.toLocaleTimeString('fr-FR')} - Source: Open-Meteo Marine
                            </div>
                        </div>

                        <div class="weather-card">
                            <div class="panel-title">⏱️ Prévisions horaires</div>
                            <div class="hourly-scroll">
                                ${marineHourly.map((h, i) => `
                                    <div class="hour-item ${i === 0 ? 'active' : ''}">
                                        <div class="hour-time">${h.time}</div>
                                        <div class="hour-icon">🌊</div>
                                        <div class="hour-temp">${convertWave(h.waveHeight)}${getWaveUnit()}</div>
                                        <div class="hour-wind">${convertWind(h.wind, state.units.wind)}</div>
                                        <div class="hour-gust">↑${convertWind(h.windGust, state.units.wind)}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>

                    <div class="side-panel">
                        <!-- Bulletin Marine Détaillé Météo-France -->
                        <div id="marineBulletinContainer">
                            <div class="panel-card"><p style="opacity:0.6;text-align:center;">Chargement du bulletin marine...</p></div>
                        </div>

                        <!-- Marées avec courbe -->
                        ${renderTides(state.tidesData)}
                        ${renderTideCurve(state.tidesData)}

                        <!-- Carte Marine OpenSeaMap -->
                        ${renderMarineChart(state.currentCoords.lat, state.currentCoords.lon)}

                        <!-- Radar de pluie -->
                        ${renderRainRadar(state.currentCoords.lat, state.currentCoords.lon)}

                        <!-- Info Port -->
                        ${renderPortInfo(state.currentCity)}

                        <div class="panel-card">
                            <div class="panel-title">📈 Pression (40h)</div>
                            ${renderPressureChart(weather.hourly.pressure_msl.slice(0, 40))}
                        </div>

                        <!-- Compas -->
                        <div class="panel-card">
                            <div class="panel-title">🧭 Compas</div>
                            ${renderCompassWidget(current.wind_direction_10m || 0)}
                        </div>
                    </div>
                </div>
            `;

            // Initialiser la carte marine et le radar après le rendu
            setTimeout(() => {
                initMarineChart(state.currentCoords.lat, state.currentCoords.lon);
                initRadar(state.currentCoords.lat, state.currentCoords.lon);
            }, 200);

            // Charger le bulletin marine détaillé
            setTimeout(async () => {
                const bulletin = await generateMarineBulletin(selectedMarineZone);
                const container = document.getElementById('marineBulletinContainer');
                if (container) {
                    container.innerHTML = renderMarineBulletin(bulletin);
                }
            }, 100);
        }

        function renderPressureChart(pressureData) {
            if (!pressureData?.length) return '<p>Données non disponibles</p>';

            const minP = Math.min(...pressureData) - 3;
            const maxP = Math.max(...pressureData) + 3;

            const points = pressureData.map((p, i) => {
                const x = 5 + (i / (pressureData.length - 1)) * 90;
                const y = 95 - ((p - minP) / (maxP - minP)) * 90;
                return `${x},${y}`;
            }).join(' ');

            const trendDiff = pressureData.length >= 8 ?
                (pressureData.slice(-4).reduce((a, b) => a + b, 0) / 4) -
                (pressureData.slice(0, 4).reduce((a, b) => a + b, 0) / 4) : 0;

            return `
                <div class="pressure-chart">
                    <svg class="chart-svg" viewBox="0 0 100 100" preserveAspectRatio="none">
                        <defs>
                            <linearGradient id="pressureGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" style="stop-color:rgba(0,180,216,0.3)"/>
                                <stop offset="100%" style="stop-color:rgba(0,180,216,0.02)"/>
                            </linearGradient>
                        </defs>
                        <line class="chart-grid" x1="5" y1="25" x2="95" y2="25"/>
                        <line class="chart-grid" x1="5" y1="50" x2="95" y2="50"/>
                        <line class="chart-grid" x1="5" y1="75" x2="95" y2="75"/>
                        <polygon class="chart-area" points="5,95 ${points} 95,95"/>
                        <polyline class="chart-line" points="${points}"/>
                    </svg>
                </div>
                <div class="pressure-stats">
                    <div class="pressure-stat">
                        <div class="value">${convertPressure(pressureData[0])}${getPressureUnit()}</div>
                        <div class="label">Actuelle</div>
                    </div>
                    <div class="pressure-stat">
                        <div class="value ${trendDiff > 1 ? 'trend-up' : trendDiff < -1 ? 'trend-down' : 'trend-stable'}">
                            ${trendDiff > 1 ? '↗️ Hausse' : trendDiff < -1 ? '↘️ Baisse' : '➡️ Stable'}
                        </div>
                        <div class="label">Tendance</div>
                    </div>
                </div>
            `;
        }

        function setupTabs() {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    btn.classList.add('active');
                    document.getElementById(`tab-${btn.dataset.tab}`)?.classList.add('active');
                });
            });
        }
    </script>
</body>
</html>
