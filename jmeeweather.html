<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1a1a2e">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Jmee Weather Station</title>
    <link rel="manifest" href="manifest.json">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --sunny-gradient: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            --rainy-gradient: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            --cloudy-gradient: linear-gradient(135deg, #1a1a2e 0%, #2c3e50 100%);
            --night-gradient: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            --marine-gradient: linear-gradient(135deg, #0a1628 0%, #0d2137 50%, #0a1a2e 100%);
            --glass-bg: rgba(255,255,255,0.08);
            --glass-border: rgba(255,255,255,0.12);
            --accent-blue: #00b4d8;
            --accent-orange: #ff6b35;
            --accent-green: #2ecc71;
            --accent-purple: #9b59b6;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            background: var(--sunny-gradient);
            color: white;
            overflow-x: hidden;
        }

        .app-container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 10px 15px;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        /* Header Windy Style */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            flex-wrap: wrap;
            gap: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 15px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.3rem;
            font-weight: 700;
        }

        .logo-icon {
            font-size: 1.6rem;
        }

        /* Mode Toggle */
        .mode-toggle {
            display: flex;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 3px;
        }

        .mode-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background: transparent;
            color: rgba(255,255,255,0.6);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }

        .mode-btn.active {
            background: var(--accent-blue);
            color: white;
        }

        .search-container {
            display: flex;
            gap: 6px;
        }

        .search-input {
            padding: 10px 16px;
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            font-size: 0.9rem;
            width: 220px;
            min-width: 120px;
            max-width: 100%;
            background: rgba(0,0,0,0.3);
            color: white;
            outline: none;
            transition: all 0.2s;
            flex-shrink: 1;
        }

        .search-input::placeholder {
            color: rgba(255,255,255,0.5);
        }

        .search-input:focus {
            border-color: var(--accent-blue);
            background: rgba(0,0,0,0.4);
        }

        .btn {
            padding: 10px 14px;
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .btn-icon {
            width: 40px;
            padding: 10px;
        }

        .btn-add {
            background: rgba(46,204,113,0.2);
            border-color: rgba(46,204,113,0.3);
        }

        .btn-add:hover {
            background: rgba(46,204,113,0.3);
        }

        /* Control Bar - Windy Style */
        .control-bar {
            display: flex;
            gap: 15px;
            padding: 12px 15px;
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-label {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-select {
            padding: 6px 10px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            background: rgba(0,0,0,0.4);
            color: white;
            font-size: 0.85rem;
            cursor: pointer;
            outline: none;
        }

        .control-select option {
            background: #1a1a2e;
        }

        /* Unit Selector */
        .unit-selector {
            display: flex;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            padding: 2px;
        }

        .unit-btn {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            background: transparent;
            color: rgba(255,255,255,0.6);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .unit-btn.active {
            background: var(--accent-blue);
            color: white;
        }

        /* Location Badge */
        .location-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(0,180,216,0.2);
            border: 1px solid rgba(0,180,216,0.3);
            border-radius: 20px;
            font-size: 0.85rem;
        }

        .location-badge .dot {
            width: 8px;
            height: 8px;
            background: var(--accent-green);
            border-radius: 50%;
            animation: pulse-dot 2s infinite;
        }

        .location-badge.live .dot {
            background: #ff4444;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* API Status Badge */
        .api-status {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: rgba(46,204,113,0.2);
            border: 1px solid rgba(46,204,113,0.3);
            border-radius: 15px;
            font-size: 0.75rem;
        }

        .api-status.error {
            background: rgba(231,76,60,0.2);
            border-color: rgba(231,76,60,0.3);
        }

        .api-status .status-dot {
            width: 6px;
            height: 6px;
            background: var(--accent-green);
            border-radius: 50%;
        }

        .api-status.error .status-dot {
            background: #e74c3c;
        }

        .api-status.offline {
            background: rgba(241,196,15,0.2);
            border-color: rgba(241,196,15,0.3);
        }

        .api-status.offline .status-dot {
            background: #f1c40f;
        }

        /* Offline Banner */
        .offline-banner {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(90deg, #f39c12, #e67e22);
            color: white;
            padding: 8px 15px;
            text-align: center;
            font-size: 0.8rem;
            z-index: 10000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .offline-banner.show {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .offline-banner .offline-icon {
            font-size: 1rem;
        }

        .offline-banner .offline-time {
            font-size: 0.7rem;
            opacity: 0.8;
        }

        body.offline-mode {
            padding-top: 40px;
        }

        /* Cache indicator */
        .cache-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 0.65rem;
            color: rgba(255,255,255,0.5);
            margin-left: 8px;
        }

        .cache-indicator.fresh {
            color: #2ecc71;
        }

        .cache-indicator.stale {
            color: #f1c40f;
        }

        .cache-indicator.old {
            color: #e74c3c;
        }

        /* Favorites Section */
        .favorites-section {
            margin-bottom: 15px;
        }

        .favorites-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .favorites-title {
            font-size: 0.85rem;
            color: rgba(255,255,255,0.7);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .favorites-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .favorite-chip {
            padding: 6px 14px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            color: rgba(255,255,255,0.8);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .favorite-chip:hover {
            background: rgba(255,255,255,0.1);
            border-color: var(--accent-blue);
        }

        .favorite-chip.active {
            background: rgba(0,180,216,0.2);
            border-color: var(--accent-blue);
            color: white;
        }

        .favorite-chip.port {
            border-color: rgba(155,89,182,0.4);
        }

        .favorite-chip.port.active {
            background: rgba(155,89,182,0.2);
            border-color: var(--accent-purple);
        }

        .favorite-chip .delete-fav {
            margin-left: 4px;
            opacity: 0;
            font-size: 0.7rem;
            transition: opacity 0.2s;
        }

        .favorite-chip:hover .delete-fav {
            opacity: 0.7;
        }

        .favorite-chip .delete-fav:hover {
            opacity: 1;
            color: #e74c3c;
        }

        /* Main Grid */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr minmax(300px, 380px);
            gap: 15px;
            max-width: 100%;
            overflow: hidden;
        }

        @media (max-width: 1000px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 600px) {
            .app-container {
                padding: 8px 10px;
            }
        }

        /* Weather Card - Windy Style */
        .weather-card {
            background: rgba(0,0,0,0.4);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.08);
            margin-bottom: 15px;
        }

        .current-weather {
            display: flex;
            align-items: center;
            gap: 25px;
            margin-bottom: 20px;
        }

        .weather-icon-large {
            font-size: 5rem;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
        }

        .weather-info {
            flex: 1;
        }

        .city-name {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .weather-date {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.6);
            margin-bottom: 10px;
        }

        .temp-display {
            display: flex;
            align-items: baseline;
            gap: 8px;
        }

        .temp-main {
            font-size: 3.5rem;
            font-weight: 300;
        }

        .temp-feels {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.6);
        }

        .weather-desc {
            font-size: 1.1rem;
            color: rgba(255,255,255,0.8);
            margin-top: 5px;
        }

        /* Wind Particles Visualization - Windy Style */
        .wind-particles-container {
            background: linear-gradient(135deg, rgba(0,30,60,0.9) 0%, rgba(0,50,100,0.7) 100%);
            border-radius: 12px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
            height: 140px;
        }

        .wind-particles-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .wind-particles-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 12px 15px;
            pointer-events: none;
            z-index: 10;
        }

        .wind-data-box {
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            border-radius: 10px;
            padding: 10px 14px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .wind-data-speed {
            font-size: 2.2rem;
            font-weight: 700;
            color: #4fc3f7;
            line-height: 1;
            text-shadow: 0 2px 10px rgba(79,195,247,0.5);
        }

        .wind-data-speed .unit {
            font-size: 0.9rem;
            font-weight: 400;
            opacity: 0.8;
        }

        .wind-data-dir {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.8);
            margin-top: 4px;
        }

        .wind-data-beaufort {
            display: flex;
            gap: 2px;
            margin-top: 6px;
        }

        .bf-seg {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(255,255,255,0.15);
        }

        .bf-seg.active { background: #4fc3f7; box-shadow: 0 0 6px #4fc3f7; }
        .bf-seg.gust { background: #ff7043; box-shadow: 0 0 6px #ff7043; }

        .wind-gust-box {
            background: rgba(255,107,53,0.25);
            backdrop-filter: blur(8px);
            border-radius: 10px;
            padding: 10px 14px;
            border: 1px solid rgba(255,107,53,0.4);
            text-align: center;
        }

        .wind-gust-val {
            font-size: 1.6rem;
            font-weight: 700;
            color: #ff7043;
            text-shadow: 0 2px 10px rgba(255,112,67,0.5);
        }

        .wind-gust-lbl {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.7);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .wind-compass-overlay {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 55px;
            height: 55px;
            z-index: 10;
        }

        .wind-compass-overlay svg {
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        /* Rain Forecast Widget */
        .rain-forecast {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 12px 15px;
            margin: 10px 0;
        }

        .rain-forecast-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .rain-forecast-title {
            font-size: 0.85rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .rain-status {
            font-size: 0.75rem;
            padding: 3px 8px;
            border-radius: 10px;
        }

        .rain-status.dry {
            background: rgba(46,204,113,0.2);
            color: #2ecc71;
        }

        .rain-status.light {
            background: rgba(0,180,216,0.2);
            color: var(--accent-blue);
        }

        .rain-status.moderate {
            background: rgba(241,196,15,0.2);
            color: #f1c40f;
        }

        .rain-status.heavy {
            background: rgba(231,76,60,0.2);
            color: #e74c3c;
        }

        .rain-timeline {
            display: flex;
            gap: 6px;
        }

        .rain-slot {
            flex: 1;
            text-align: center;
            padding: 8px 4px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            transition: all 0.3s;
        }

        .rain-slot.has-rain {
            background: rgba(0,180,216,0.15);
            border: 1px solid rgba(0,180,216,0.3);
        }

        .rain-slot.heavy-rain {
            background: rgba(231,76,60,0.15);
            border: 1px solid rgba(231,76,60,0.3);
        }

        .rain-slot-time {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            margin-bottom: 4px;
        }

        .rain-slot-icon {
            font-size: 1.2rem;
            margin-bottom: 2px;
        }

        .rain-slot-amount {
            font-size: 0.75rem;
            font-weight: 600;
        }

        .rain-slot-amount.none {
            color: rgba(255,255,255,0.4);
        }

        .rain-slot-amount.light {
            color: var(--accent-blue);
        }

        .rain-slot-amount.moderate {
            color: #f1c40f;
        }

        .rain-slot-amount.heavy {
            color: #e74c3c;
        }

        .rain-slot-hour {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.5);
            margin-top: 3px;
            font-family: 'SF Mono', 'Monaco', monospace;
        }

        /* Mini Rain Bar */
        .rain-mini-bar {
            display: flex;
            gap: 1px;
            height: 20px;
            margin-top: 8px;
            border-radius: 4px;
            overflow: hidden;
        }

        .rain-mini-segment {
            flex: 1;
            background: rgba(255,255,255,0.05);
            transition: background 0.3s;
        }

        .rain-mini-segment.level-1 { background: rgba(0,180,216,0.4); }
        .rain-mini-segment.level-2 { background: rgba(0,180,216,0.7); }
        .rain-mini-segment.level-3 { background: rgba(241,196,15,0.7); }
        .rain-mini-segment.level-4 { background: rgba(255,107,53,0.8); }
        .rain-mini-segment.level-5 { background: rgba(231,76,60,0.9); }

        .model-tag {
            font-size: 0.7rem;
            padding: 3px 8px;
            background: rgba(0,180,216,0.3);
            border-radius: 10px;
            font-weight: 500;
        }

        .model-tag.hd {
            background: linear-gradient(135deg, rgba(255,107,53,0.4), rgba(255,165,0,0.4));
            border: 1px solid rgba(255,165,0,0.5);
        }

        /* Swell Direction */
        .swell-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(155,89,182,0.15);
            border: 1px solid rgba(155,89,182,0.3);
            border-radius: 10px;
            margin: 15px 0;
        }

        .swell-compass {
            width: 80px;
            height: 80px;
            position: relative;
        }

        .swell-compass svg {
            width: 100%;
            height: 100%;
        }

        .swell-arrow {
            fill: var(--accent-purple);
            transition: transform 0.5s ease;
        }

        .swell-info {
            flex: 1;
        }

        .swell-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .swell-details {
            display: flex;
            gap: 20px;
        }

        .swell-detail {
            text-align: center;
        }

        .swell-detail .value {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--accent-purple);
        }

        .swell-detail .label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
        }

        /* Details Grid */
        .details-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        @media (max-width: 600px) {
            .details-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .detail-item {
            background: rgba(0,0,0,0.25);
            border-radius: 10px;
            padding: 12px;
            text-align: center;
        }

        .detail-icon {
            font-size: 1.4rem;
            margin-bottom: 6px;
        }

        .detail-value {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .detail-label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            margin-top: 3px;
        }

        /* Side Panel */
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 0;
            overflow: hidden;
        }

        .panel-card {
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255,255,255,0.08);
            overflow: hidden;
        }

        .left-panel {
            min-width: 0;
            overflow: hidden;
        }

        .panel-title {
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Tides Section */
        .tides-container {
            padding: 15px;
            background: rgba(0,119,182,0.15);
            border: 1px solid rgba(0,119,182,0.3);
            border-radius: 12px;
        }

        .tides-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .tides-title {
            font-size: 0.9rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tides-coefficient {
            padding: 4px 10px;
            background: rgba(0,180,216,0.3);
            border-radius: 15px;
            font-size: 0.75rem;
        }

        .tides-chart {
            height: 80px;
            position: relative;
            margin: 15px 0;
        }

        .tides-chart svg {
            width: 100%;
            height: 100%;
        }

        .tide-curve {
            fill: none;
            stroke: var(--accent-blue);
            stroke-width: 2;
        }

        .tide-area {
            fill: url(#tideGrad);
        }

        .tide-now-line {
            stroke: var(--accent-orange);
            stroke-width: 2;
            stroke-dasharray: 4 2;
        }

        .tide-now-dot {
            fill: var(--accent-orange);
        }

        .tides-times {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .tide-time {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .tide-icon {
            font-size: 1.5rem;
        }

        .tide-info .time {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .tide-info .height {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.6);
        }

        .tide-info .label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
        }

        /* Port Info */
        .port-info {
            background: rgba(155,89,182,0.15);
            border: 1px solid rgba(155,89,182,0.3);
            border-radius: 12px;
            padding: 15px;
        }

        .port-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .port-title {
            font-size: 0.9rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .port-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .port-item {
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            text-align: center;
        }

        .port-item .value {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent-purple);
        }

        .port-item .label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            margin-top: 4px;
        }

        /* Bulletin Côtier */
        .bulletin-container {
            background: rgba(46,204,113,0.1);
            border: 1px solid rgba(46,204,113,0.3);
            border-radius: 12px;
            padding: 15px;
        }

        .bulletin-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .bulletin-title {
            font-size: 0.9rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .bulletin-date {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
        }

        .bulletin-zone {
            padding: 4px 10px;
            background: rgba(46,204,113,0.3);
            border-radius: 15px;
            font-size: 0.75rem;
        }

        /* Bulletin Marine Détaillé */
        .marine-bulletin {
            background: linear-gradient(135deg, rgba(0,119,182,0.2) 0%, rgba(0,80,120,0.15) 100%);
            border: 1px solid rgba(0,119,182,0.3);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .marine-bulletin-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .marine-bulletin-title {
            font-size: 1rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .marine-bulletin-title img {
            height: 24px;
        }

        .zone-selector {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .zone-select {
            padding: 6px 12px;
            border: 1px solid rgba(0,119,182,0.4);
            border-radius: 8px;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 0.85rem;
            cursor: pointer;
            outline: none;
        }

        .zone-select option {
            background: #1a1a2e;
        }

        .zone-select:focus {
            border-color: var(--accent-blue);
        }

        .marine-bulletin-meta {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            font-size: 0.75rem;
            color: rgba(255,255,255,0.6);
            flex-wrap: wrap;
        }

        .marine-bulletin-meta span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .bulletin-block {
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .bulletin-block:last-child {
            margin-bottom: 0;
        }

        .bulletin-block-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--accent-blue);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .bulletin-block-content {
            font-size: 0.85rem;
            line-height: 1.6;
            color: rgba(255,255,255,0.9);
        }

        .bulletin-warning {
            background: rgba(241,196,15,0.15);
            border: 1px solid rgba(241,196,15,0.3);
            border-radius: 8px;
            padding: 10px 12px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bulletin-warning.danger {
            background: rgba(231,76,60,0.15);
            border-color: rgba(231,76,60,0.3);
        }

        .bulletin-warning-icon {
            font-size: 1.2rem;
        }

        .bulletin-warning-text {
            font-size: 0.8rem;
            font-weight: 500;
        }

        .bulletin-forecast-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        @media (max-width: 600px) {
            .bulletin-forecast-grid {
                grid-template-columns: 1fr;
            }
        }

        .bulletin-forecast-item {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }

        .bulletin-forecast-period {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            margin-bottom: 5px;
        }

        .bulletin-forecast-wind {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent-blue);
        }

        .bulletin-forecast-sea {
            font-size: 0.75rem;
            color: var(--accent-purple);
            margin-top: 4px;
        }

        .bulletin-content {
            font-size: 0.85rem;
            line-height: 1.6;
            color: rgba(255,255,255,0.9);
        }

        .bulletin-section {
            margin-bottom: 12px;
        }

        .bulletin-section-title {
            font-weight: 600;
            color: var(--accent-green);
            margin-bottom: 4px;
            font-size: 0.8rem;
        }

        .bulletin-section-text {
            font-size: 0.8rem;
            opacity: 0.9;
        }

        /* Hourly Scroll */
        .hourly-scroll {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding-bottom: 8px;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.2) transparent;
        }

        .hourly-scroll::-webkit-scrollbar {
            height: 4px;
        }

        .hourly-scroll::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }

        .hour-item {
            min-width: 65px;
            padding: 10px 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            text-align: center;
            flex-shrink: 0;
            transition: all 0.2s;
            cursor: pointer;
        }

        .hour-item:hover {
            background: rgba(255,255,255,0.1);
        }

        .hour-item.active {
            background: rgba(0,180,216,0.2);
            border: 1px solid rgba(0,180,216,0.3);
        }

        .hour-time {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.6);
            margin-bottom: 6px;
        }

        .hour-icon {
            font-size: 1.3rem;
            margin-bottom: 6px;
        }

        .hour-temp {
            font-size: 0.9rem;
            font-weight: 600;
        }

        .hour-wind {
            font-size: 0.7rem;
            color: var(--accent-blue);
            margin-top: 4px;
        }

        .hour-gust {
            font-size: 0.65rem;
            color: var(--accent-orange);
        }

        .hour-wave {
            font-size: 0.65rem;
            color: var(--accent-purple);
            margin-top: 2px;
        }

        /* Pressure Chart */
        .pressure-chart {
            height: 100px;
            position: relative;
            margin: 10px 0;
        }

        .chart-svg {
            width: 100%;
            height: 100%;
        }

        .chart-line {
            fill: none;
            stroke: var(--accent-blue);
            stroke-width: 2;
            stroke-linecap: round;
        }

        .chart-area {
            fill: url(#pressureGrad);
        }

        .chart-grid {
            stroke: rgba(255,255,255,0.1);
            stroke-width: 1;
        }

        .pressure-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 0.75rem;
        }

        .pressure-stat {
            text-align: center;
        }

        .pressure-stat .value {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .pressure-stat .label {
            color: rgba(255,255,255,0.5);
            font-size: 0.65rem;
        }

        .trend-up { color: var(--accent-green); }
        .trend-down { color: var(--accent-orange); }
        .trend-stable { color: var(--accent-blue); }

        /* Marine Specific */
        .marine-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .marine-item {
            background: rgba(0,0,0,0.25);
            border-radius: 10px;
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .marine-icon {
            font-size: 1.5rem;
        }

        .marine-info .value {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .marine-info .label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
        }

        /* Wave Display */
        .wave-visual {
            height: 80px;
            background: linear-gradient(180deg, transparent, rgba(0,119,182,0.3));
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            margin: 10px 0;
        }

        .wave-line {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 200%;
            height: 100%;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1200 120'%3E%3Cpath fill='rgba(0,180,216,0.4)' d='M0,60 C150,120 350,0 600,60 C850,120 1050,0 1200,60 L1200,120 L0,120 Z'/%3E%3C/svg%3E") repeat-x;
            animation: wave-move 4s linear infinite;
        }

        @keyframes wave-move {
            from { transform: translateX(0); }
            to { transform: translateX(-50%); }
        }

        .wave-stats {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .wave-height-value {
            font-size: 2rem;
            font-weight: 700;
        }

        .wave-height-label {
            font-size: 0.75rem;
            opacity: 0.7;
        }

        /* Wind/Gust Chart */
        .wind-chart-container {
            background: rgba(0,0,0,0.25);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
        }

        .wind-chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .wind-chart-title {
            font-size: 0.9rem;
            font-weight: 600;
        }

        .wind-chart-legend {
            display: flex;
            gap: 15px;
            font-size: 0.75rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .legend-dot.wind {
            background: var(--accent-blue);
        }

        .legend-dot.gust {
            background: var(--accent-orange);
        }

        .wind-chart {
            height: 120px;
            position: relative;
        }

        .wind-chart svg {
            width: 100%;
            height: 100%;
        }

        .wind-line {
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .wind-line.main {
            stroke: var(--accent-blue);
        }

        .wind-line.gust {
            stroke: var(--accent-orange);
            stroke-dasharray: 4 2;
        }

        .wind-area {
            fill: url(#windGrad);
        }

        .gust-area {
            fill: url(#gustGrad);
        }

        .wind-chart-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.65rem;
            color: rgba(255,255,255,0.5);
            margin-top: 5px;
        }

        /* Wave Chart */
        .wave-chart-container {
            background: linear-gradient(135deg, rgba(155,89,182,0.15), rgba(155,89,182,0.05));
            border: 1px solid rgba(155,89,182,0.2);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
        }

        .wave-chart {
            height: 100px;
            position: relative;
        }

        .wave-chart svg {
            width: 100%;
            height: 100%;
        }

        .wave-line-chart {
            fill: none;
            stroke: var(--accent-purple);
            stroke-width: 2.5;
            stroke-linecap: round;
        }

        .wave-area-fill {
            fill: url(#waveGrad);
        }

        /* Tide Curve */
        .tide-curve-container {
            background: linear-gradient(135deg, rgba(0,119,182,0.15), rgba(0,119,182,0.05));
            border: 1px solid rgba(0,119,182,0.2);
            border-radius: 12px;
            padding: 15px;
            margin-top: 15px;
        }

        .tide-curve-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .tide-curve-chart {
            height: 100px;
            position: relative;
        }

        .tide-curve-chart svg {
            width: 100%;
            height: 100%;
        }

        .tide-curve-path {
            fill: none;
            stroke: var(--accent-blue);
            stroke-width: 2.5;
        }

        .tide-area-fill {
            fill: url(#tideGradient);
        }

        .tide-now-marker {
            fill: var(--accent-orange);
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }

        .tide-time-marker {
            fill: rgba(255,255,255,0.6);
            font-size: 8px;
        }

        .tide-height-marker {
            fill: rgba(255,255,255,0.4);
            font-size: 7px;
        }

        .tide-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 0.7rem;
            color: rgba(255,255,255,0.6);
        }

        /* Rain Radar */
        .radar-container {
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .radar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .radar-title {
            font-size: 0.9rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .radar-live {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.7rem;
            padding: 3px 8px;
            background: rgba(231,76,60,0.3);
            border-radius: 10px;
        }

        .radar-live .pulse {
            width: 6px;
            height: 6px;
            background: #e74c3c;
            border-radius: 50%;
            animation: pulse-radar 1.5s infinite;
        }

        @keyframes pulse-radar {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        .radar-map {
            height: 200px;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            background: #1a1a2e;
            max-width: 100%;
        }

        .radar-map #radarMap {
            height: 100%;
            width: 100%;
        }

        @media (max-width: 600px) {
            .radar-map {
                height: 180px;
            }
        }

        .radar-controls {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            align-items: center;
        }

        .radar-btn {
            padding: 6px 12px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .radar-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .radar-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
        }

        .radar-timeline {
            flex: 1;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            position: relative;
            cursor: pointer;
        }

        .radar-timeline-progress {
            height: 100%;
            background: var(--accent-blue);
            border-radius: 2px;
            transition: width 0.3s;
        }

        .radar-time-label {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.7);
            min-width: 50px;
            text-align: right;
        }

        .radar-legend {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
            font-size: 0.65rem;
        }

        .radar-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .radar-legend-color {
            width: 12px;
            height: 8px;
            border-radius: 2px;
        }

        .radar-time-display {
            display: flex;
            align-items: baseline;
            gap: 10px;
            margin-top: 10px;
            padding: 8px 12px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }

        .radar-time-main {
            font-size: 1.4rem;
            font-weight: 700;
            color: white;
            font-family: 'SF Mono', 'Monaco', monospace;
        }

        .radar-time-delta {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.6);
        }

        .radar-time-delta.future {
            color: #2ecc71;
        }

        .radar-time-delta.past {
            color: #f39c12;
        }

        .radar-timeline-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .radar-timeline-ticks {
            display: flex;
            justify-content: space-between;
            font-size: 0.6rem;
            color: rgba(255,255,255,0.4);
            padding: 0 2px;
        }

        .radar-frames-list {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 10px;
            max-height: 60px;
            overflow-y: auto;
        }

        .radar-frame-btn {
            padding: 3px 6px;
            font-size: 0.65rem;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 4px;
            color: rgba(255,255,255,0.7);
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'SF Mono', 'Monaco', monospace;
        }

        .radar-frame-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .radar-frame-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        .radar-frame-btn.future {
            border-color: rgba(46,204,113,0.4);
            color: #2ecc71;
        }

        .radar-frame-btn.nowcast {
            background: rgba(46,204,113,0.2);
        }

        /* Carte Marine OpenSeaMap */
        .marine-chart-container {
            background: rgba(0,0,0,0.4);
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            border: 1px solid rgba(255,255,255,0.1);
            position: relative;
            transition: all 0.3s ease;
        }

        .marine-chart-container.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            margin: 0;
            border-radius: 0;
            z-index: 9999;
            padding: 0;
            background: #1a1a2e;
        }

        .marine-chart-container.fullscreen .marine-chart-header {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            z-index: 1001;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 10px;
            margin-bottom: 0;
        }

        .marine-chart-container.fullscreen .marine-chart-map {
            height: 100vh;
            border-radius: 0;
        }

        .marine-chart-container.fullscreen .marine-chart-legend {
            position: absolute;
            bottom: 15px;
            left: 15px;
            right: 15px;
            z-index: 1001;
            background: rgba(0,0,0,0.8);
            padding: 12px 15px;
            border-radius: 10px;
            margin-top: 0;
        }

        .marine-chart-container.fullscreen .marine-chart-controls {
            top: 80px;
            right: 20px;
        }

        .marine-chart-container.fullscreen .layer-controls {
            display: flex;
        }

        .marine-chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .marine-chart-title {
            font-size: 0.9rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .fullscreen-hint {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.4);
            font-weight: normal;
        }

        .marine-chart-container.fullscreen .fullscreen-hint {
            display: none;
        }

        .marine-chart-source {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            background: rgba(0,0,0,0.3);
            padding: 2px 8px;
            border-radius: 10px;
        }

        .marine-chart-map {
            height: 280px;
            border-radius: 10px;
            overflow: hidden;
            background: #1a1a2e;
            cursor: pointer;
        }

        .marine-chart-legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 8px 15px;
            margin-top: 10px;
            font-size: 0.7rem;
            color: rgba(255,255,255,0.7);
        }

        .marine-legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-marker {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .legend-marker.buoy {
            background: #f1c40f;
        }

        .legend-marker.light {
            background: #e74c3c;
        }

        .legend-marker.port {
            background: #3498db;
        }

        .legend-marker.depth {
            background: linear-gradient(180deg, #a8e6cf, #1abc9c, #0a5c4a);
        }

        .legend-marker.anchor {
            background: #9b59b6;
        }

        .legend-marker.restricted {
            background: #e74c3c;
            border: 2px dashed #fff;
        }

        .legend-marker.lane {
            background: transparent;
            border: 2px solid #f39c12;
        }

        .legend-marker.wreck {
            background: #34495e;
        }

        .marine-chart-controls {
            position: absolute;
            top: 55px;
            right: 25px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 1000;
        }

        .marine-zoom-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 6px;
            background: rgba(0,0,0,0.7);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .marine-zoom-btn:hover {
            background: rgba(0,0,0,0.9);
        }

        .marine-zoom-btn.close-btn {
            background: rgba(231,76,60,0.8);
            display: none;
        }

        .marine-zoom-btn.expand-btn {
            background: rgba(46,204,113,0.7);
        }

        .marine-chart-container.fullscreen .marine-zoom-btn.close-btn {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .marine-chart-container.fullscreen .marine-zoom-btn.expand-btn {
            display: none;
        }

        .marine-zoom-btn.gps-btn {
            background: rgba(52,152,219,0.7);
        }

        .marine-zoom-btn.gps-btn.active {
            background: rgba(46,204,113,0.9);
            animation: pulse-gps 1.5s infinite;
        }

        .marine-zoom-btn.fishing-btn {
            background: rgba(230,126,34,0.7);
        }

        .marine-zoom-btn.fishing-btn.active {
            background: rgba(46,204,113,0.9);
        }

        @keyframes pulse-gps {
            0%, 100% { box-shadow: 0 0 0 0 rgba(46,204,113,0.7); }
            50% { box-shadow: 0 0 0 8px rgba(46,204,113,0); }
        }

        /* Marqueur GPS */
        .gps-marker {
            background: transparent;
        }

        .gps-marker-inner {
            width: 30px;
            height: 30px;
            background: rgba(52,152,219,0.3);
            border: 3px solid #3498db;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse-gps-marker 2s infinite;
        }

        .gps-arrow {
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 12px solid #3498db;
        }

        @keyframes pulse-gps-marker {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        /* GPS Status */
        .gps-status {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.5);
            margin-top: 8px;
            padding: 5px 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            text-align: center;
        }

        .gps-status.active {
            color: #2ecc71;
            background: rgba(46,204,113,0.2);
        }

        .gps-status.error {
            color: #e74c3c;
            background: rgba(231,76,60,0.2);
        }

        .gps-center-btn {
            width: 100%;
            padding: 6px 10px;
            margin-top: 5px;
            border: none;
            border-radius: 5px;
            background: rgba(52,152,219,0.3);
            color: white;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .gps-center-btn:hover {
            background: rgba(52,152,219,0.5);
        }

        /* Mode Pêche */
        .fishing-info {
            background: rgba(230,126,34,0.2);
            border-radius: 5px;
            padding: 8px;
            margin-top: 5px;
        }

        .fishing-data {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.8);
            margin: 3px 0;
        }

        .fishing-data span:first-child {
            color: rgba(255,255,255,0.5);
        }

        .fishing-good { color: #2ecc71 !important; }
        .fishing-medium { color: #f1c40f !important; }
        .fishing-poor { color: #e74c3c !important; }

        /* Légende bathymétrie visible */
        .bathy-legend {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 8px 15px;
            border-radius: 8px;
            z-index: 1000;
            display: none;
        }

        .marine-chart-container .bathy-legend {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bathy-gradient {
            width: 150px;
            height: 12px;
            background: linear-gradient(90deg,
                #b8e6ff 0%,
                #7fcdff 15%,
                #4db8ff 25%,
                #1a9fff 35%,
                #0077cc 50%,
                #005599 65%,
                #003366 80%,
                #001a33 100%
            );
            border-radius: 3px;
        }

        .bathy-labels {
            display: flex;
            justify-content: space-between;
            width: 150px;
            font-size: 0.55rem;
            color: rgba(255,255,255,0.6);
            margin-top: 2px;
        }

        .sst-legend {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(0,0,0,0.8);
            padding: 8px 12px;
            border-radius: 8px;
            z-index: 1000;
            display: none;
        }

        .sst-gradient {
            width: 120px;
            height: 12px;
            background: linear-gradient(90deg,
                #313695 0%,
                #4575b4 15%,
                #74add1 30%,
                #abd9e9 45%,
                #fee090 60%,
                #fdae61 75%,
                #f46d43 90%,
                #a50026 100%
            );
            border-radius: 3px;
        }

        .sst-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.55rem;
            color: rgba(255,255,255,0.6);
            margin-top: 2px;
        }

        /* Légende isobathes */
        .contours-legend {
            position: absolute;
            top: 80px;
            right: 70px;
            background: rgba(0,0,0,0.85);
            padding: 10px 12px;
            border-radius: 8px;
            z-index: 1000;
            display: none;
        }

        .contour-items {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .contour-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.65rem;
            color: rgba(255,255,255,0.8);
        }

        .contour-line {
            width: 20px;
            height: 3px;
            border-radius: 1px;
        }

        /* Contrôles de couches */
        .layer-controls {
            position: absolute;
            top: 55px;
            left: 15px;
            z-index: 1001;
            display: none;
            flex-direction: column;
            gap: 5px;
            background: rgba(0,0,0,0.85);
            padding: 12px;
            border-radius: 10px;
            max-width: 220px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .layer-control-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 5px;
        }

        .layer-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 0;
            cursor: pointer;
            font-size: 0.7rem;
            color: rgba(255,255,255,0.8);
            transition: all 0.2s;
        }

        .layer-toggle:hover {
            color: white;
        }

        .layer-toggle input {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .layer-toggle.disabled {
            opacity: 0.4;
            pointer-events: none;
        }

        /* Info bulle sur la carte */
        .map-info-box {
            position: absolute;
            bottom: 60px;
            left: 15px;
            background: rgba(0,0,0,0.85);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.75rem;
            z-index: 1001;
            display: none;
            max-width: 250px;
        }

        .marine-chart-container.fullscreen .map-info-box {
            display: block;
        }

        .map-info-box .coords {
            font-family: 'SF Mono', monospace;
            color: var(--accent-blue);
        }

        .map-info-box .depth-scale {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-top: 8px;
        }

        .depth-gradient {
            width: 100px;
            height: 12px;
            background: linear-gradient(90deg, #a8e6cf 0%, #56ab91 25%, #1abc9c 50%, #0a5c4a 75%, #023020 100%);
            border-radius: 3px;
        }

        .depth-labels {
            display: flex;
            justify-content: space-between;
            width: 100px;
            font-size: 0.6rem;
            color: rgba(255,255,255,0.5);
            margin-top: 2px;
        }

        .map-info-box .info-coords {
            margin-bottom: 5px;
        }

        .map-info-box .info-zoom {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.6);
        }

        .map-info-box .info-sources {
            font-size: 0.6rem;
            color: rgba(255,255,255,0.4);
            margin-top: 5px;
            border-top: 1px solid rgba(255,255,255,0.1);
            padding-top: 5px;
        }

        /* Légende détaillée (fullscreen) */
        .map-legend-detailed {
            position: absolute;
            bottom: 70px;
            right: 15px;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 10px;
            font-size: 0.7rem;
            z-index: 1001;
            display: none;
            max-width: 280px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .marine-chart-container.fullscreen .map-legend-detailed {
            display: block;
        }

        .legend-section {
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .legend-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .legend-section-title {
            font-weight: 600;
            color: white;
            margin-bottom: 6px;
            font-size: 0.75rem;
        }

        .legend-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 3px 0;
            color: rgba(255,255,255,0.8);
        }

        .legend-icon {
            width: 20px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .legend-icon.cardinal-n { background: linear-gradient(180deg, #f1c40f 50%, #000 50%); color: #000; }
        .legend-icon.cardinal-s { background: linear-gradient(180deg, #000 50%, #f1c40f 50%); color: #f1c40f; }
        .legend-icon.cardinal-e { background: linear-gradient(180deg, #000 33%, #f1c40f 33%, #f1c40f 66%, #000 66%); color: #f1c40f; }
        .legend-icon.cardinal-w { background: linear-gradient(180deg, #f1c40f 33%, #000 33%, #000 66%, #f1c40f 66%); color: #000; }

        .legend-icon.light-white { color: #fff; text-shadow: 0 0 5px #fff; background: rgba(255,255,255,0.2); }
        .legend-icon.light-red { color: #e74c3c; text-shadow: 0 0 5px #e74c3c; background: rgba(231,76,60,0.2); }
        .legend-icon.light-green { color: #27ae60; text-shadow: 0 0 5px #27ae60; background: rgba(39,174,96,0.2); }
        .legend-icon.light-yellow { color: #f1c40f; text-shadow: 0 0 5px #f1c40f; background: rgba(241,196,15,0.2); }

        .legend-icon.port-icon { background: #3498db; color: white; }
        .legend-icon.anchor-icon { background: #9b59b6; color: white; }
        .legend-icon.fuel-icon { background: #e67e22; color: white; }
        .legend-icon.repair-icon { background: #7f8c8d; color: white; }

        .legend-icon.danger-icon { background: #c0392b; color: white; }
        .legend-icon.rock-icon { background: #34495e; color: #e74c3c; }
        .legend-icon.restricted-icon { background: rgba(231,76,60,0.3); border: 1px dashed #e74c3c; color: #e74c3c; }
        .legend-icon.cable-icon { background: #f39c12; color: #000; }

        .legend-icon.lane-icon { background: rgba(52,152,219,0.3); border: 1px solid #3498db; color: #3498db; }
        .legend-icon.separation-icon { background: rgba(155,89,182,0.3); color: #9b59b6; }

        .depth-gradient-large {
            width: 100%;
            height: 16px;
            background: linear-gradient(90deg,
                #b8e6ff 0%,      /* 0m - très clair */
                #7fcdff 10%,     /* 2m */
                #4db8ff 20%,     /* 5m */
                #1a9fff 30%,     /* 10m */
                #0077cc 45%,     /* 20m */
                #005599 60%,     /* 50m */
                #003366 80%,     /* 100m */
                #001a33 100%     /* 200m+ */
            );
            border-radius: 4px;
            margin: 8px 0 4px;
        }

        .depth-labels-large {
            display: flex;
            justify-content: space-between;
            font-size: 0.6rem;
            color: rgba(255,255,255,0.5);
        }

        /* Sea State */
        .sea-state-bar {
            height: 6px;
            background: linear-gradient(to right, #00b894, #fdcb6e, #e17055, #d63031, #6c5ce7);
            border-radius: 3px;
            position: relative;
            margin: 15px 0 8px;
        }

        .sea-state-marker {
            position: absolute;
            top: -5px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transform: translateX(-50%);
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: left 0.5s;
        }

        .sea-state-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.65rem;
            opacity: 0.6;
        }

        /* Safety Alert */
        .safety-alert {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .safety-alert.safe {
            background: rgba(46,204,113,0.15);
            border: 1px solid rgba(46,204,113,0.3);
        }

        .safety-alert.warning {
            background: rgba(241,196,15,0.15);
            border: 1px solid rgba(241,196,15,0.3);
        }

        .safety-alert.danger {
            background: rgba(231,76,60,0.15);
            border: 1px solid rgba(231,76,60,0.3);
        }

        .safety-icon {
            font-size: 1.3rem;
        }

        .safety-text .title {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .safety-text .desc {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 4px;
            background: rgba(0,0,0,0.3);
            padding: 4px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .tab-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: transparent;
            color: rgba(255,255,255,0.6);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab-btn.active {
            background: rgba(255,255,255,0.1);
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Loading */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 300px;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 12px;
            font-size: 0.9rem;
            opacity: 0.7;
        }

        /* Daily Forecast */
        .daily-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background: rgba(255,255,255,0.03);
            border-radius: 8px;
            margin-bottom: 6px;
        }

        .daily-day {
            width: 50px;
            font-size: 0.8rem;
        }

        .daily-icon {
            font-size: 1.2rem;
            margin-right: 8px;
        }

        .daily-temps {
            flex: 1;
            display: flex;
            gap: 8px;
            font-size: 0.85rem;
        }

        .daily-high {
            font-weight: 600;
        }

        .daily-low {
            opacity: 0.5;
        }

        .daily-wind {
            font-size: 0.75rem;
            color: var(--accent-blue);
            width: 60px;
            text-align: right;
        }

        .daily-gust {
            font-size: 0.7rem;
            color: var(--accent-orange);
            width: 50px;
            text-align: right;
        }

        /* Error message */
        .error-message {
            background: rgba(231,76,60,0.2);
            border: 1px solid rgba(231,76,60,0.4);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }

        .error-message .icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .error-message .text {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .retry-btn {
            margin-top: 10px;
            padding: 8px 20px;
            background: rgba(231,76,60,0.3);
            border: 1px solid rgba(231,76,60,0.5);
            border-radius: 6px;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
        }

        .retry-btn:hover {
            background: rgba(231,76,60,0.5);
        }

        /* Last update */
        .last-update {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.4);
            text-align: right;
            margin-top: 10px;
        }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 16px;
            padding: 25px;
            width: 90%;
            max-width: 500px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            opacity: 0.7;
        }

        .modal-close:hover {
            opacity: 1;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-label {
            display: block;
            font-size: 0.85rem;
            margin-bottom: 6px;
            color: rgba(255,255,255,0.8);
        }

        .form-input {
            width: 100%;
            padding: 12px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 0.9rem;
            outline: none;
        }

        .form-input:focus {
            border-color: var(--accent-blue);
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .form-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }

        .form-checkbox input {
            width: 18px;
            height: 18px;
        }

        .btn-primary {
            width: 100%;
            padding: 12px;
            background: var(--accent-blue);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary:hover {
            background: #0096c7;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .header {
                flex-direction: column;
                align-items: stretch;
            }

            .search-input {
                width: 100%;
            }

            .search-container {
                flex-wrap: wrap;
            }

            .control-bar {
                flex-direction: column;
                align-items: stretch;
                padding: 10px;
            }

            .control-group {
                flex-wrap: wrap;
            }

            .unit-selector {
                flex-wrap: wrap;
            }

            .current-weather {
                flex-direction: column;
                text-align: center;
            }

            .wind-particles-container {
                height: 120px;
            }

            .wind-particles-overlay {
                padding: 8px 10px;
            }

            .wind-data-speed {
                font-size: 1.8rem;
            }

            .marine-grid, .port-grid, .tides-times {
                grid-template-columns: 1fr;
            }

            .details-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <!-- Offline Banner -->
    <div class="offline-banner" id="offlineBanner">
        <span class="offline-icon">📡</span>
        <span>Mode hors-ligne - Données en cache</span>
        <span class="offline-time" id="offlineTime"></span>
    </div>

    <div class="app-container">
        <header class="header">
            <div class="logo">
                <span class="logo-icon" id="logoIcon">🌊</span>
                <span>Jmee Weather Station</span>
            </div>

            <div class="mode-toggle">
                <button class="mode-btn active" data-mode="weather" id="weatherModeBtn">🌍 Terrestre</button>
                <button class="mode-btn" data-mode="marine" id="marineModeBtn">⚓ Marine</button>
            </div>

            <div class="search-container">
                <input type="text" class="search-input" id="searchInput" placeholder="Ville, port, zone...">
                <button class="btn btn-icon" id="searchBtn">🔍</button>
                <button class="btn btn-icon" id="locationBtn" title="Ma position">📍</button>
                <button class="btn btn-icon btn-add" id="addFavoriteBtn" title="Ajouter aux favoris">⭐</button>
            </div>

            <div class="location-badge" id="locationBadge">
                <span class="dot"></span>
                <span id="locationText">Localisation...</span>
            </div>

            <div class="api-status" id="apiStatus">
                <span class="status-dot"></span>
                <span id="apiStatusText">API Live</span>
            </div>
        </header>

        <div class="control-bar">
            <div class="control-group">
                <span class="control-label">Modèle</span>
                <select class="control-select" id="modelSelect">
                    <option value="arome_france_hd">AROME HD (500m) ⭐</option>
                    <option value="arome_france">AROME (1.3km)</option>
                    <option value="arpege_europe">ARPÈGE Europe (10km)</option>
                    <option value="ecmwf_ifs025">ECMWF IFS (25km)</option>
                    <option value="gfs_seamless">GFS (25km)</option>
                    <option value="icon_seamless">ICON (7km)</option>
                </select>
            </div>

            <div class="control-group">
                <span class="control-label">Vent</span>
                <div class="unit-selector" id="windUnitSelector">
                    <button class="unit-btn active" data-unit="kmh">km/h</button>
                    <button class="unit-btn" data-unit="kt">kt</button>
                    <button class="unit-btn" data-unit="ms">m/s</button>
                    <button class="unit-btn" data-unit="bft">Bft</button>
                </div>
            </div>

            <div class="control-group">
                <span class="control-label">Temp</span>
                <div class="unit-selector" id="tempUnitSelector">
                    <button class="unit-btn active" data-unit="celsius">°C</button>
                    <button class="unit-btn" data-unit="fahrenheit">°F</button>
                </div>
            </div>

            <div class="control-group" id="waveUnitGroup" style="display:none">
                <span class="control-label">Vagues</span>
                <div class="unit-selector" id="waveUnitSelector">
                    <button class="unit-btn active" data-unit="m">m</button>
                    <button class="unit-btn" data-unit="ft">ft</button>
                </div>
            </div>

            <div class="control-group">
                <span class="control-label">Pression</span>
                <div class="unit-selector" id="pressureUnitSelector">
                    <button class="unit-btn active" data-unit="hpa">hPa</button>
                    <button class="unit-btn" data-unit="inhg">inHg</button>
                </div>
            </div>
        </div>

        <div class="favorites-section">
            <div class="favorites-header">
                <div class="favorites-title">⭐ Favoris</div>
            </div>
            <div class="favorites-row" id="favoritesRow"></div>
        </div>

        <main id="mainContent">
            <div class="loading">
                <div class="loading-spinner"></div>
                <p class="loading-text">Géolocalisation en cours...</p>
            </div>
        </main>
    </div>

    <!-- Modal Ajouter Favori -->
    <div class="modal-overlay" id="addFavoriteModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">⭐ Ajouter aux favoris</h3>
                <button class="modal-close" id="closeModal">&times;</button>
            </div>
            <form id="addFavoriteForm">
                <div class="form-group">
                    <label class="form-label">Nom du lieu</label>
                    <input type="text" class="form-input" id="favName" placeholder="Ex: Brest, Port de Marseille..." required>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Latitude</label>
                        <input type="number" step="0.0001" class="form-input" id="favLat" placeholder="48.3904" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Longitude</label>
                        <input type="number" step="0.0001" class="form-input" id="favLon" placeholder="-4.4861" required>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Emoji (optionnel)</label>
                    <input type="text" class="form-input" id="favEmoji" placeholder="🌊" maxlength="2">
                </div>
                <div class="form-group">
                    <label class="form-checkbox">
                        <input type="checkbox" id="favIsPort">
                        <span>C'est un port (afficher infos portuaires)</span>
                    </label>
                </div>
                <div class="form-group">
                    <label class="form-checkbox">
                        <input type="checkbox" id="favIsCoastal" checked>
                        <span>Zone côtière (données marines disponibles)</span>
                    </label>
                </div>
                <button type="submit" class="btn-primary">Ajouter aux favoris</button>
            </form>
        </div>
    </div>

    <script>
        // État de l'application
        const state = {
            currentCity: null,
            currentCoords: null,
            mode: 'weather',
            model: 'arome_france_hd',
            actualModel: null, // Modèle réellement utilisé (peut différer si hors zone)
            units: {
                wind: 'kmh',
                temp: 'celsius',
                wave: 'm',
                pressure: 'hpa'
            },
            weatherData: null,
            marineData: null,
            tidesData: null,
            isLoading: true,
            lastUpdate: null,
            apiError: false,
            favorites: []
        };

        // Favoris par défaut
        const defaultFavorites = [
            { name: 'Paris', lat: 48.8566, lon: 2.3522, emoji: '🗼', isPort: false, isCoastal: false },
            { name: 'Marseille', lat: 43.2965, lon: 5.3698, emoji: '⚓', isPort: true, isCoastal: true },
            { name: 'Brest', lat: 48.3904, lon: -4.4861, emoji: '🌊', isPort: true, isCoastal: true },
            { name: 'Nice', lat: 43.7102, lon: 7.2620, emoji: '☀️', isPort: true, isCoastal: true },
            { name: 'La Rochelle', lat: 46.1603, lon: -1.1511, emoji: '⛵', isPort: true, isCoastal: true },
            { name: 'Saint-Malo', lat: 48.6493, lon: -2.0076, emoji: '🏴‍☠️', isPort: true, isCoastal: true }
        ];

        // Zones marines Météo-France officielles
        const marineZones = {
            // Manche - Mer du Nord
            'pas-de-calais': { name: 'Pas-de-Calais', region: 'Manche - Mer du Nord', coords: { lat: 50.9, lon: 1.8 } },
            'antifer': { name: 'Antifer', region: 'Manche - Mer du Nord', coords: { lat: 49.6, lon: 0.1 } },
            'casquets': { name: 'Casquets', region: 'Manche', coords: { lat: 49.7, lon: -2.2 } },
            'ouessant': { name: 'Ouessant', region: 'Manche', coords: { lat: 48.5, lon: -5.1 } },
            // Atlantique
            'iroise': { name: 'Iroise', region: 'Atlantique', coords: { lat: 48.2, lon: -5.0 } },
            'yeu': { name: 'Yeu', region: 'Atlantique', coords: { lat: 46.7, lon: -2.3 } },
            'rochebonne': { name: 'Rochebonne', region: 'Atlantique', coords: { lat: 46.2, lon: -2.4 } },
            'cantabrico': { name: 'Cantabrico', region: 'Atlantique', coords: { lat: 44.0, lon: -3.0 } },
            'finisterre': { name: 'Finisterre', region: 'Atlantique', coords: { lat: 43.0, lon: -9.5 } },
            // Méditerranée
            'lion': { name: 'Golfe du Lion', region: 'Méditerranée', coords: { lat: 42.5, lon: 4.0 } },
            'provence': { name: 'Provence', region: 'Méditerranée', coords: { lat: 43.0, lon: 6.0 } },
            'ligure': { name: 'Ligure', region: 'Méditerranée', coords: { lat: 43.5, lon: 8.5 } },
            'corse': { name: 'Côtes Corses', region: 'Méditerranée', coords: { lat: 42.0, lon: 9.0 } },
            'sardaigne': { name: 'Sardaigne', region: 'Méditerranée', coords: { lat: 40.5, lon: 8.5 } }
        };

        // Groupes de zones par région
        const marineRegions = {
            'manche': {
                name: 'Manche - Mer du Nord',
                zones: ['pas-de-calais', 'antifer', 'casquets', 'ouessant'],
                icon: '🌊'
            },
            'atlantique': {
                name: 'Atlantique',
                zones: ['iroise', 'yeu', 'rochebonne', 'cantabrico', 'finisterre'],
                icon: '🌊'
            },
            'mediterranee': {
                name: 'Méditerranée',
                zones: ['lion', 'provence', 'ligure', 'corse', 'sardaigne'],
                icon: '☀️'
            }
        };

        // Zone sélectionnée pour le bulletin
        let selectedMarineZone = 'lion';

        // Ports français avec informations
        const portsInfo = {
            'Marseille': { vhf: '12', tidalRange: 'faible', harbor: 'Vieux-Port', facilities: ['Carburant', 'Eau', 'Électricité', 'Sanitaires'] },
            'Brest': { vhf: '16', tidalRange: 'fort', harbor: 'Port de Commerce', facilities: ['Carburant', 'Eau', 'Électricité', 'Grue'] },
            'Nice': { vhf: '09', tidalRange: 'faible', harbor: 'Port Lympia', facilities: ['Carburant', 'Eau', 'Électricité', 'Sanitaires'] },
            'La Rochelle': { vhf: '09', tidalRange: 'fort', harbor: 'Les Minimes', facilities: ['Carburant', 'Eau', 'Électricité', 'Shipchandler'] },
            'Saint-Malo': { vhf: '09', tidalRange: 'très fort', harbor: 'Port des Sablons', facilities: ['Carburant', 'Eau', 'Électricité', 'Grue'] }
        };

        // Configuration des modèles météo
        const models = {
            arome_france_hd: { name: 'AROME HD', resolution: '500m', range: '48h', update: '1h', provider: 'Météo-France', api: 'meteofrance', isHD: true },
            arome_france: { name: 'AROME', resolution: '1.3km', range: '48h', update: '3h', provider: 'Météo-France', api: 'meteofrance', isHD: false },
            arpege_europe: { name: 'ARPÈGE', resolution: '10km', range: '4j', update: '6h', provider: 'Météo-France', api: 'meteofrance', isHD: false },
            ecmwf_ifs025: { name: 'ECMWF IFS', resolution: '25km', range: '10j', update: '6h', provider: 'ECMWF', api: 'ecmwf', isHD: false },
            gfs_seamless: { name: 'GFS', resolution: '25km', range: '16j', update: '6h', provider: 'NOAA', api: 'gfs', isHD: false },
            icon_seamless: { name: 'ICON', resolution: '7km', range: '7j', update: '6h', provider: 'DWD', api: 'icon', isHD: false }
        };

        // Codes météo WMO
        const weatherCodes = {
            0: { icon: '☀️', desc: 'Ciel dégagé' }, 1: { icon: '🌤️', desc: 'Principalement dégagé' },
            2: { icon: '⛅', desc: 'Partiellement nuageux' }, 3: { icon: '☁️', desc: 'Couvert' },
            45: { icon: '🌫️', desc: 'Brouillard' }, 48: { icon: '🌫️', desc: 'Brouillard givrant' },
            51: { icon: '🌦️', desc: 'Bruine légère' }, 53: { icon: '🌦️', desc: 'Bruine modérée' },
            55: { icon: '🌧️', desc: 'Bruine dense' }, 61: { icon: '🌧️', desc: 'Pluie légère' },
            63: { icon: '🌧️', desc: 'Pluie modérée' }, 65: { icon: '🌧️', desc: 'Pluie forte' },
            71: { icon: '🌨️', desc: 'Neige légère' }, 73: { icon: '🌨️', desc: 'Neige modérée' },
            75: { icon: '❄️', desc: 'Neige forte' }, 80: { icon: '🌦️', desc: 'Averses légères' },
            81: { icon: '🌧️', desc: 'Averses modérées' }, 82: { icon: '⛈️', desc: 'Averses violentes' },
            95: { icon: '⛈️', desc: 'Orage' }, 96: { icon: '⛈️', desc: 'Orage avec grêle' }
        };

        // États de la mer (Douglas)
        const seaStates = [
            { name: 'Calme', desc: 'Mer d\'huile', maxHeight: 0 },
            { name: 'Ridée', desc: 'Vaguelettes', maxHeight: 0.1 },
            { name: 'Belle', desc: 'Petites vagues', maxHeight: 0.5 },
            { name: 'Peu agitée', desc: 'Vagues modérées', maxHeight: 1.25 },
            { name: 'Agitée', desc: 'Vagues fortes', maxHeight: 2.5 },
            { name: 'Forte', desc: 'Grosses vagues', maxHeight: 4 },
            { name: 'Très forte', desc: 'Très grosses vagues', maxHeight: 6 },
            { name: 'Grosse', desc: 'Vagues énormes', maxHeight: 9 },
            { name: 'Très grosse', desc: 'Déferlantes', maxHeight: 14 },
            { name: 'Énorme', desc: 'Phénoménale', maxHeight: Infinity }
        ];

        // Charger les favoris depuis localStorage
        function loadFavorites() {
            const saved = localStorage.getItem('meteoAppFavorites');
            if (saved) {
                state.favorites = JSON.parse(saved);
            } else {
                state.favorites = [...defaultFavorites];
                saveFavorites();
            }
            renderFavorites();
        }

        // Sauvegarder les favoris
        function saveFavorites() {
            localStorage.setItem('meteoAppFavorites', JSON.stringify(state.favorites));
        }

        // Sauvegarder les préférences utilisateur
        function savePreferences() {
            const prefs = {
                units: state.units,
                mode: state.mode,
                model: state.model,
                lastLocation: state.currentCoords ? {
                    lat: state.currentCoords.lat,
                    lon: state.currentCoords.lon,
                    name: state.currentCity,
                    isPort: state.currentIsPort || false
                } : null
            };
            localStorage.setItem('meteoAppPreferences', JSON.stringify(prefs));
        }

        // ========== MODE OFFLINE ==========
        let isOnline = navigator.onLine;
        let lastDataTimestamp = null;

        function initOfflineMode() {
            // Écouter les changements de connexion
            window.addEventListener('online', handleOnline);
            window.addEventListener('offline', handleOffline);

            // Vérifier l'état initial
            if (!navigator.onLine) {
                handleOffline();
            }

            // Enregistrer le Service Worker si supporté
            if ('serviceWorker' in navigator) {
                registerServiceWorker();
            }
        }

        async function registerServiceWorker() {
            try {
                // Créer le Service Worker dynamiquement (inline)
                const swCode = `
                    const CACHE_NAME = 'jmee-weather-v1';
                    const STATIC_ASSETS = [
                        './',
                        './jmeeweather.html',
                        'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css',
                        'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js'
                    ];

                    // Installation - mise en cache des assets statiques
                    self.addEventListener('install', event => {
                        event.waitUntil(
                            caches.open(CACHE_NAME).then(cache => {
                                return cache.addAll(STATIC_ASSETS);
                            })
                        );
                        self.skipWaiting();
                    });

                    // Activation - nettoyage des anciens caches
                    self.addEventListener('activate', event => {
                        event.waitUntil(
                            caches.keys().then(keys => {
                                return Promise.all(
                                    keys.filter(key => key !== CACHE_NAME)
                                        .map(key => caches.delete(key))
                                );
                            })
                        );
                        self.clients.claim();
                    });

                    // Fetch - stratégie Network First avec fallback cache
                    self.addEventListener('fetch', event => {
                        // Ignorer les requêtes non-GET
                        if (event.request.method !== 'GET') return;

                        event.respondWith(
                            fetch(event.request)
                                .then(response => {
                                    // Mettre en cache la réponse
                                    const responseClone = response.clone();
                                    caches.open(CACHE_NAME).then(cache => {
                                        cache.put(event.request, responseClone);
                                    });
                                    return response;
                                })
                                .catch(() => {
                                    // Fallback sur le cache
                                    return caches.match(event.request);
                                })
                        );
                    });
                `;

                const blob = new Blob([swCode], { type: 'application/javascript' });
                const swUrl = URL.createObjectURL(blob);

                // Note: Pour un vrai déploiement, le SW doit être dans un fichier séparé
                // Pour l'instant, on utilise uniquement le cache localStorage
                console.log('Service Worker: Mode localStorage activé');
            } catch (e) {
                console.warn('Service Worker non disponible:', e);
            }
        }

        function handleOnline() {
            isOnline = true;
            document.body.classList.remove('offline-mode');
            document.getElementById('offlineBanner').classList.remove('show');

            // Mettre à jour le statut API
            const apiStatus = document.getElementById('apiStatus');
            if (apiStatus) {
                apiStatus.classList.remove('offline');
            }

            // Rafraîchir les données automatiquement
            if (state.currentCoords) {
                console.log('Connexion rétablie - Actualisation des données...');
                loadWeatherForCoords(state.currentCoords.lat, state.currentCoords.lon, state.currentCity);
            }
        }

        function handleOffline() {
            isOnline = false;
            document.body.classList.add('offline-mode');

            const banner = document.getElementById('offlineBanner');
            banner.classList.add('show');

            // Afficher l'heure des dernières données
            updateOfflineTime();

            // Mettre à jour le statut API
            const apiStatus = document.getElementById('apiStatus');
            const apiStatusText = document.getElementById('apiStatusText');
            if (apiStatus) {
                apiStatus.classList.add('offline');
            }
            if (apiStatusText) {
                apiStatusText.textContent = 'Mode hors-ligne';
            }

            // Charger les données en cache
            loadCachedData();
        }

        function updateOfflineTime() {
            const timeEl = document.getElementById('offlineTime');
            if (timeEl && lastDataTimestamp) {
                const diff = Date.now() - lastDataTimestamp;
                const minutes = Math.floor(diff / 60000);
                const hours = Math.floor(minutes / 60);

                if (hours > 0) {
                    timeEl.textContent = `(données de ${hours}h${minutes % 60}min)`;
                } else if (minutes > 0) {
                    timeEl.textContent = `(données de ${minutes}min)`;
                } else {
                    timeEl.textContent = '(données récentes)';
                }
            }
        }

        // Sauvegarder les données météo en cache
        function cacheWeatherData() {
            if (!state.weatherData || !state.currentCoords) return;

            const cacheData = {
                timestamp: Date.now(),
                coords: state.currentCoords,
                city: state.currentCity,
                isPort: state.currentIsPort,
                weatherData: state.weatherData,
                marineData: state.marineData,
                tidesData: state.tidesData,
                model: state.model,
                actualModel: state.actualModel
            };

            try {
                localStorage.setItem('meteoAppWeatherCache', JSON.stringify(cacheData));
                lastDataTimestamp = cacheData.timestamp;
                console.log('Données météo mises en cache');
            } catch (e) {
                console.warn('Erreur cache localStorage:', e);
                // Essayer de libérer de l'espace
                try {
                    localStorage.removeItem('meteoAppWeatherCache');
                    localStorage.setItem('meteoAppWeatherCache', JSON.stringify(cacheData));
                } catch (e2) {
                    console.error('Impossible de mettre en cache:', e2);
                }
            }
        }

        // Charger les données depuis le cache
        function loadCachedData() {
            try {
                const cached = localStorage.getItem('meteoAppWeatherCache');
                if (!cached) {
                    showError('Aucune donnée en cache disponible. Connectez-vous à Internet.');
                    return false;
                }

                const cacheData = JSON.parse(cached);
                lastDataTimestamp = cacheData.timestamp;

                // Restaurer l'état
                state.currentCoords = cacheData.coords;
                state.currentCity = cacheData.city;
                state.currentIsPort = cacheData.isPort;
                state.weatherData = cacheData.weatherData;
                state.marineData = cacheData.marineData;
                state.tidesData = cacheData.tidesData;
                state.actualModel = cacheData.actualModel;
                state.lastUpdate = new Date(cacheData.timestamp);

                // Mettre à jour l'interface
                const locationText = document.getElementById('locationText');
                if (locationText) {
                    locationText.textContent = cacheData.city || 'Position';
                }

                // Afficher les données
                renderCurrentView();

                // Afficher l'indicateur de cache
                showCacheIndicator();

                console.log('Données chargées depuis le cache');
                return true;
            } catch (e) {
                console.error('Erreur chargement cache:', e);
                return false;
            }
        }

        function showCacheIndicator() {
            if (!lastDataTimestamp) return;

            const diff = Date.now() - lastDataTimestamp;
            const minutes = Math.floor(diff / 60000);

            let className = 'cache-indicator';
            let text = '';

            if (minutes < 30) {
                className += ' fresh';
                text = '✓ Données récentes';
            } else if (minutes < 120) {
                className += ' stale';
                text = `⚠ Données de ${minutes}min`;
            } else {
                className += ' old';
                const hours = Math.floor(minutes / 60);
                text = `⚠ Données de ${hours}h`;
            }

            // Ajouter l'indicateur près du statut API
            const apiStatus = document.getElementById('apiStatus');
            if (apiStatus) {
                let indicator = document.getElementById('cacheIndicator');
                if (!indicator) {
                    indicator = document.createElement('span');
                    indicator.id = 'cacheIndicator';
                    apiStatus.parentNode.insertBefore(indicator, apiStatus.nextSibling);
                }
                indicator.className = className;
                indicator.textContent = text;
            }
        }

        // Vérifier si on peut utiliser le réseau
        function canUseNetwork() {
            return navigator.onLine;
        }

        // Charger les préférences utilisateur
        function loadPreferences() {
            const saved = localStorage.getItem('meteoAppPreferences');
            if (saved) {
                try {
                    const prefs = JSON.parse(saved);
                    // Restaurer les unités
                    if (prefs.units) {
                        state.units = { ...state.units, ...prefs.units };
                        // Mettre à jour l'UI des sélecteurs d'unités
                        updateUnitSelectorsUI();
                    }
                    // Restaurer le mode
                    if (prefs.mode) {
                        state.mode = prefs.mode;
                        updateModeUI();
                    }
                    // Restaurer le modèle
                    if (prefs.model) {
                        state.model = prefs.model;
                        updateModelSelectUI();
                    }
                    // Retourner la dernière localisation
                    return prefs.lastLocation;
                } catch (e) {
                    console.warn('Erreur chargement préférences:', e);
                }
            }
            return null;
        }

        // Mettre à jour l'UI des sélecteurs d'unités
        function updateUnitSelectorsUI() {
            Object.keys(state.units).forEach(unitType => {
                const selector = document.getElementById(unitType + 'UnitSelector');
                if (selector) {
                    selector.querySelectorAll('.unit-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.unit === state.units[unitType]);
                    });
                }
            });
        }

        // Mettre à jour l'UI du mode
        function updateModeUI() {
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === state.mode);
            });
            // Mettre à jour l'affichage des unités de vagues selon le mode
            const waveUnitGroup = document.getElementById('waveUnitGroup');
            if (waveUnitGroup) {
                waveUnitGroup.style.display = state.mode === 'marine' ? 'block' : 'none';
            }
            // Mettre à jour le logo
            const logoIcon = document.getElementById('logoIcon');
            if (logoIcon) {
                logoIcon.textContent = state.mode === 'marine' ? '⚓' : '🌊';
            }
        }

        // Mettre à jour l'UI du modèle
        function updateModelSelectUI() {
            const modelSelect = document.getElementById('modelSelect');
            if (modelSelect && state.model) {
                modelSelect.value = state.model;
            }
        }

        // Rendre les favoris
        function renderFavorites() {
            const container = document.getElementById('favoritesRow');
            container.innerHTML = state.favorites.map((fav, index) => `
                <button class="favorite-chip ${fav.isPort ? 'port' : ''}"
                        data-index="${index}"
                        data-lat="${fav.lat}"
                        data-lon="${fav.lon}"
                        data-name="${fav.name}"
                        data-coastal="${fav.isCoastal}"
                        data-port="${fav.isPort}">
                    ${fav.emoji || '📍'} ${fav.name}
                    <span class="delete-fav" data-delete="${index}">✕</span>
                </button>
            `).join('');
        }

        // Détecter le fuseau horaire approximatif selon les coordonnées
        function getTimezoneForCoords(lat, lon) {
            // Amérique du Nord
            if (lon >= -130 && lon <= -60) {
                if (lon >= -130 && lon <= -115) return 'America/Los_Angeles';
                if (lon >= -115 && lon <= -100) return 'America/Denver';
                if (lon >= -100 && lon <= -85) return 'America/Chicago';
                if (lon >= -85 && lon <= -60) return 'America/New_York';
            }
            // Mexique / Amérique Centrale
            if (lat >= 14 && lat <= 33 && lon >= -118 && lon <= -86) {
                return 'America/Mexico_City';
            }
            // Canada Est
            if (lat >= 45 && lon >= -80 && lon <= -50) {
                return 'America/Toronto';
            }
            // Europe
            if (lon >= -10 && lon <= 40 && lat >= 35 && lat <= 72) {
                if (lon <= 0) return 'Europe/London';
                if (lon <= 15) return 'Europe/Paris';
                return 'Europe/Moscow';
            }
            // Asie
            if (lon >= 100 && lon <= 145) return 'Asia/Tokyo';
            if (lon >= 70 && lon < 100) return 'Asia/Kolkata';
            // Océanie
            if (lon >= 110 && lon <= 180 && lat <= 0) return 'Australia/Sydney';
            // Défaut
            return 'auto';
        }

        // Vérifier si les coordonnées sont dans la zone de couverture d'un modèle
        function isInModelCoverage(lat, lon, modelKey) {
            // AROME HD et AROME: France métropolitaine étendue
            if (modelKey === 'arome_france_hd' || modelKey === 'arome_france') {
                return lat >= 41 && lat <= 52 && lon >= -6 && lon <= 10;
            }
            // ARPÈGE: Europe
            if (modelKey === 'arpege_europe') {
                return lat >= 20 && lat <= 72 && lon >= -32 && lon <= 42;
            }
            // ICON: principalement Europe mais plus large
            if (modelKey === 'icon_seamless') {
                return lat >= -90 && lat <= 90; // Global
            }
            // GFS et ECMWF: Global
            return true;
        }

        // Obtenir le meilleur modèle pour une localisation
        function getBestModelForLocation(lat, lon, preferredModel) {
            if (isInModelCoverage(lat, lon, preferredModel)) {
                return preferredModel;
            }
            // Fallback vers GFS (couverture mondiale)
            return 'gfs_seamless';
        }

        // API Météo
        async function fetchWeatherData(lat, lon, modelKey) {
            // Vérifier la couverture et basculer si nécessaire
            const actualModel = getBestModelForLocation(lat, lon, modelKey);
            const model = models[actualModel];

            // Stocker le modèle réellement utilisé pour l'affichage
            state.actualModel = actualModel;

            let baseUrl = 'https://api.open-meteo.com/v1/';

            if (model.api === 'meteofrance') baseUrl += 'meteofrance';
            else if (model.api === 'ecmwf') baseUrl += 'ecmwf';
            else if (model.api === 'gfs') baseUrl += 'gfs';
            else if (model.api === 'icon') baseUrl += 'dwd-icon';
            else baseUrl += 'forecast';

            // Détecter le fuseau horaire approprié
            const timezone = getTimezoneForCoords(lat, lon);

            const params = new URLSearchParams({
                latitude: lat,
                longitude: lon,
                hourly: 'temperature_2m,relative_humidity_2m,apparent_temperature,precipitation,weather_code,pressure_msl,cloud_cover,wind_speed_10m,wind_direction_10m,wind_gusts_10m',
                daily: 'weather_code,temperature_2m_max,temperature_2m_min,wind_speed_10m_max,wind_gusts_10m_max,wind_direction_10m_dominant',
                current: 'temperature_2m,relative_humidity_2m,apparent_temperature,is_day,precipitation,weather_code,cloud_cover,pressure_msl,wind_speed_10m,wind_direction_10m,wind_gusts_10m',
                timezone: timezone,
                forecast_days: '7'
            });

            if (model.api === 'meteofrance') params.append('models', actualModel);

            const response = await fetch(`${baseUrl}?${params.toString()}`);
            if (!response.ok) throw new Error(`API Error: ${response.status}`);
            const data = await response.json();

            // Si pressure_msl est null dans current (cas AROME HD), utiliser les données horaires
            if (data.current && (data.current.pressure_msl === null || data.current.pressure_msl === undefined)) {
                // Utiliser la première valeur horaire disponible
                if (data.hourly && data.hourly.pressure_msl) {
                    const validPressure = data.hourly.pressure_msl.find(p => p !== null && p !== undefined);
                    if (validPressure) {
                        data.current.pressure_msl = validPressure;
                    } else {
                        // Fallback: faire une requête standard sans modèle spécifique
                        try {
                            const fallbackResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=pressure_msl&timezone=Europe/Paris`);
                            const fallbackData = await fallbackResponse.json();
                            if (fallbackData.current?.pressure_msl) {
                                data.current.pressure_msl = fallbackData.current.pressure_msl;
                            }
                        } catch(e) {
                            console.warn('Fallback pressure fetch failed', e);
                        }
                    }
                }
            }

            // Même chose pour les données horaires si elles sont null
            if (data.hourly && data.hourly.pressure_msl) {
                const hasNullPressure = data.hourly.pressure_msl.some(p => p === null);
                if (hasNullPressure) {
                    try {
                        const fallbackResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=pressure_msl&timezone=Europe/Paris&forecast_days=2`);
                        const fallbackData = await fallbackResponse.json();
                        if (fallbackData.hourly?.pressure_msl) {
                            data.hourly.pressure_msl = fallbackData.hourly.pressure_msl;
                        }
                    } catch(e) {
                        console.warn('Fallback hourly pressure fetch failed', e);
                    }
                }
            }

            return data;
        }

        // API Marine
        async function fetchMarineData(lat, lon) {
            const params = new URLSearchParams({
                latitude: lat,
                longitude: lon,
                hourly: 'wave_height,wave_direction,wave_period,swell_wave_height,swell_wave_direction,swell_wave_period',
                current: 'wave_height,wave_direction,wave_period,swell_wave_height,swell_wave_direction,swell_wave_period',
                timezone: 'Europe/Paris',
                forecast_days: '7'
            });

            const response = await fetch(`https://marine-api.open-meteo.com/v1/marine?${params.toString()}`);
            if (!response.ok) throw new Error(`Marine API Error: ${response.status}`);
            return await response.json();
        }

        // Générer des données de marées simulées (en attendant une vraie API)
        function generateTidesData(lat, lon) {
            const now = new Date();
            const baseHeight = 3 + Math.random() * 2;
            const amplitude = 1.5 + Math.random() * 3;
            const coefficient = 60 + Math.floor(Math.random() * 60);

            // Calculer les heures de marée basées sur la position lunaire approximative
            const lunarOffset = (lon / 15) * 60; // minutes de décalage
            const baseTime = new Date(now);
            baseTime.setMinutes(baseTime.getMinutes() + lunarOffset);

            const tides = [];
            for (let i = 0; i < 4; i++) {
                const tideTime = new Date(baseTime);
                tideTime.setHours(tideTime.getHours() + i * 6 + Math.floor(Math.random() * 2));
                tides.push({
                    time: tideTime,
                    height: i % 2 === 0 ? baseHeight + amplitude : baseHeight - amplitude,
                    type: i % 2 === 0 ? 'high' : 'low'
                });
            }

            // Calculer le niveau actuel
            const currentPhase = ((now.getHours() * 60 + now.getMinutes()) % (6 * 60)) / (6 * 60);
            const currentHeight = baseHeight + Math.sin(currentPhase * Math.PI * 2) * amplitude;

            return {
                coefficient,
                currentHeight: Math.round(currentHeight * 10) / 10,
                tides: tides.sort((a, b) => a.time - b.time),
                range: amplitude * 2
            };
        }

        // Générer le bulletin côtier
        function generateCoastalBulletin(cityName, weatherData, marineData) {
            const wind = weatherData.current.wind_speed_10m;
            const gust = weatherData.current.wind_gusts_10m;
            const windDir = getWindDirection(weatherData.current.wind_direction_10m);
            const waveHeight = marineData?.current?.wave_height || 0;
            const swellHeight = marineData?.current?.swell_wave_height || 0;
            const swellDir = marineData?.current?.swell_wave_direction || 0;

            const beaufort = kmhToBeaufort(wind);
            const visibility = weatherData.current.cloud_cover > 80 ? 'Réduite' : 'Bonne';

            let seaDesc = 'Belle à peu agitée';
            if (waveHeight > 2.5) seaDesc = 'Agitée à forte';
            else if (waveHeight > 1.25) seaDesc = 'Peu agitée à agitée';
            else if (waveHeight > 0.5) seaDesc = 'Belle à peu agitée';

            const now = new Date();
            const bulletinDate = now.toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long' });
            const bulletinTime = now.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });

            return {
                zone: cityName,
                date: bulletinDate,
                time: bulletinTime,
                sections: [
                    {
                        title: 'Situation générale',
                        text: `Vent de secteur ${windDir} ${beaufort} à ${beaufort + 1} Beaufort, ${Math.round(wind)} à ${Math.round(gust)} km/h en rafales.`
                    },
                    {
                        title: 'État de la mer',
                        text: `${seaDesc}. Vagues de ${waveHeight.toFixed(1)}m. ${swellHeight > 0.3 ? `Houle de ${getWindDirection(swellDir)} de ${swellHeight.toFixed(1)}m.` : 'Pas de houle significative.'}`
                    },
                    {
                        title: 'Visibilité',
                        text: `${visibility}. ${weatherData.current.precipitation > 0 ? 'Passages pluvieux possibles.' : ''}`
                    },
                    {
                        title: 'Évolution',
                        text: `Tendance ${weatherData.hourly.wind_speed_10m[12] > wind ? 'au renforcement' : 'à l\'atténuation'} du vent dans les prochaines heures.`
                    }
                ]
            };
        }

        // Générer le bulletin marine détaillé pour une zone
        async function generateMarineBulletin(zoneKey) {
            const zone = marineZones[zoneKey];
            if (!zone) return null;

            const { lat, lon } = zone.coords;

            try {
                // Récupérer les données météo pour cette zone
                const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,wind_speed_10m,wind_direction_10m,wind_gusts_10m,cloud_cover,precipitation,weather_code&hourly=wind_speed_10m,wind_gusts_10m,wind_direction_10m,precipitation&timezone=Europe/Paris&forecast_days=2`);
                const weatherData = await weatherResponse.json();

                // Récupérer les données marines
                const marineResponse = await fetch(`https://marine-api.open-meteo.com/v1/marine?latitude=${lat}&longitude=${lon}&current=wave_height,wave_direction,wave_period,swell_wave_height,swell_wave_direction,swell_wave_period&hourly=wave_height,swell_wave_height&timezone=Europe/Paris&forecast_days=2`);
                const marineData = await marineResponse.json();

                const current = weatherData.current;
                const marine = marineData.current;
                const hourlyWind = weatherData.hourly.wind_speed_10m;
                const hourlyWave = marineData.hourly.wave_height;

                const wind = current.wind_speed_10m || 0;
                const gust = current.wind_gusts_10m || 0;
                const windDeg = current.wind_direction_10m || 0;
                const waveHeight = marine?.wave_height || 0;
                const wavePeriod = marine?.wave_period || 0;
                const swellHeight = marine?.swell_wave_height || 0;
                const swellDir = marine?.swell_wave_direction || 0;
                const swellPeriod = marine?.swell_wave_period || 0;

                const beaufort = kmhToBeaufort(wind);
                const gustBeaufort = kmhToBeaufort(gust);
                const seaStateIdx = getSeaState(waveHeight);
                const seaState = seaStates[seaStateIdx];

                // Déterminer le niveau d'alerte
                let warningLevel = null;
                let warningText = '';
                if (beaufort >= 8 || waveHeight >= 6) {
                    warningLevel = 'danger';
                    warningText = 'AVIS DE COUP DE VENT - Navigation fortement déconseillée';
                } else if (beaufort >= 6 || waveHeight >= 4) {
                    warningLevel = 'warning';
                    warningText = 'Conditions difficiles - Prudence recommandée';
                }

                // Prévisions par période
                const forecasts = [
                    { period: 'Ce matin', windIdx: 0 },
                    { period: 'Cet après-midi', windIdx: 6 },
                    { period: 'Ce soir', windIdx: 12 },
                    { period: 'Cette nuit', windIdx: 18 },
                    { period: 'Demain matin', windIdx: 24 },
                    { period: 'Demain après-midi', windIdx: 30 }
                ].slice(0, 3).map(f => ({
                    period: f.period,
                    wind: hourlyWind[f.windIdx] || wind,
                    wave: hourlyWave[f.windIdx] || waveHeight
                }));

                const now = new Date();

                return {
                    zone: zone.name,
                    region: zone.region,
                    date: now.toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' }),
                    time: now.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }),
                    warning: warningLevel ? { level: warningLevel, text: warningText } : null,
                    wind: {
                        speed: wind,
                        gust: gust,
                        direction: getWindDirection(windDeg),
                        directionDeg: windDeg,
                        beaufort: beaufort,
                        gustBeaufort: gustBeaufort
                    },
                    sea: {
                        state: seaState.name,
                        stateDesc: seaState.desc,
                        waveHeight: waveHeight,
                        wavePeriod: wavePeriod
                    },
                    swell: {
                        height: swellHeight,
                        direction: getWindDirection(swellDir),
                        directionDeg: swellDir,
                        period: swellPeriod
                    },
                    visibility: current.cloud_cover > 80 ? 'Moyenne à réduite' : current.cloud_cover > 50 ? 'Bonne à moyenne' : 'Bonne',
                    precipitation: current.precipitation > 0,
                    forecasts: forecasts
                };
            } catch (e) {
                console.error('Erreur génération bulletin marine:', e);
                return null;
            }
        }

        // Rendu du bulletin marine détaillé
        function renderMarineBulletin(bulletin) {
            if (!bulletin) return '<div class="panel-card"><p style="opacity:0.6;text-align:center;">Chargement du bulletin...</p></div>';

            return `
                <div class="marine-bulletin">
                    <div class="marine-bulletin-header">
                        <div class="marine-bulletin-title">
                            ⚓ Bulletin Marine - ${bulletin.zone}
                        </div>
                        <div class="zone-selector">
                            <select class="zone-select" id="marineZoneSelect" onchange="changeMarineZone(this.value)">
                                <optgroup label="Manche - Mer du Nord">
                                    ${marineRegions.manche.zones.map(z => `<option value="${z}" ${z === selectedMarineZone ? 'selected' : ''}>${marineZones[z].name}</option>`).join('')}
                                </optgroup>
                                <optgroup label="Atlantique">
                                    ${marineRegions.atlantique.zones.map(z => `<option value="${z}" ${z === selectedMarineZone ? 'selected' : ''}>${marineZones[z].name}</option>`).join('')}
                                </optgroup>
                                <optgroup label="Méditerranée">
                                    ${marineRegions.mediterranee.zones.map(z => `<option value="${z}" ${z === selectedMarineZone ? 'selected' : ''}>${marineZones[z].name}</option>`).join('')}
                                </optgroup>
                            </select>
                        </div>
                    </div>

                    <div class="marine-bulletin-meta">
                        <span>📅 ${bulletin.date}</span>
                        <span>🕐 ${bulletin.time}</span>
                        <span>📍 ${bulletin.region}</span>
                    </div>

                    ${bulletin.warning ? `
                        <div class="bulletin-warning ${bulletin.warning.level}">
                            <span class="bulletin-warning-icon">${bulletin.warning.level === 'danger' ? '🚨' : '⚠️'}</span>
                            <span class="bulletin-warning-text">${bulletin.warning.text}</span>
                        </div>
                    ` : ''}

                    <div class="bulletin-block">
                        <div class="bulletin-block-title">💨 Vent</div>
                        <div class="bulletin-block-content">
                            Secteur <strong>${bulletin.wind.direction}</strong> (${bulletin.wind.directionDeg}°),
                            force <strong>${bulletin.wind.beaufort}</strong> à <strong>${bulletin.wind.gustBeaufort}</strong> Beaufort.
                            <br>Vitesse ${Math.round(bulletin.wind.speed)} km/h, rafales jusqu'à <strong>${Math.round(bulletin.wind.gust)} km/h</strong>.
                        </div>
                    </div>

                    <div class="bulletin-block">
                        <div class="bulletin-block-title">🌊 État de la mer</div>
                        <div class="bulletin-block-content">
                            Mer <strong>${bulletin.sea.state.toLowerCase()}</strong> (${bulletin.sea.stateDesc.toLowerCase()}).
                            <br>Hauteur des vagues: <strong>${bulletin.sea.waveHeight.toFixed(1)} m</strong>, période ${Math.round(bulletin.sea.wavePeriod)} s.
                        </div>
                    </div>

                    ${bulletin.swell.height > 0.3 ? `
                        <div class="bulletin-block">
                            <div class="bulletin-block-title">〰️ Houle</div>
                            <div class="bulletin-block-content">
                                Houle de secteur <strong>${bulletin.swell.direction}</strong>,
                                hauteur <strong>${bulletin.swell.height.toFixed(1)} m</strong>,
                                période ${Math.round(bulletin.swell.period)} s.
                            </div>
                        </div>
                    ` : ''}

                    <div class="bulletin-block">
                        <div class="bulletin-block-title">👁️ Visibilité</div>
                        <div class="bulletin-block-content">
                            ${bulletin.visibility}. ${bulletin.precipitation ? 'Passages pluvieux ou averses.' : 'Temps sec.'}
                        </div>
                    </div>

                    <div class="bulletin-block">
                        <div class="bulletin-block-title">📊 Prévisions</div>
                        <div class="bulletin-forecast-grid">
                            ${bulletin.forecasts.map(f => `
                                <div class="bulletin-forecast-item">
                                    <div class="bulletin-forecast-period">${f.period}</div>
                                    <div class="bulletin-forecast-wind">${kmhToBeaufort(f.wind)} Bft</div>
                                    <div class="bulletin-forecast-sea">${f.wave.toFixed(1)}m</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        // Changer la zone marine et recharger le bulletin
        async function changeMarineZone(zoneKey) {
            selectedMarineZone = zoneKey;
            const bulletinContainer = document.getElementById('marineBulletinContainer');
            if (bulletinContainer) {
                bulletinContainer.innerHTML = '<div class="panel-card"><p style="opacity:0.6;text-align:center;">Chargement...</p></div>';
                const bulletin = await generateMarineBulletin(zoneKey);
                bulletinContainer.innerHTML = renderMarineBulletin(bulletin);
            }
        }

        // Conversions
        function convertWind(valueKmh, toUnit) {
            if (valueKmh === undefined || valueKmh === null) return 0;
            switch (toUnit) {
                case 'kt': return Math.round(valueKmh * 0.539957);
                case 'ms': return Math.round(valueKmh * 10 / 36 * 10) / 10;
                case 'bft': return kmhToBeaufort(valueKmh);
                default: return Math.round(valueKmh);
            }
        }

        function kmhToBeaufort(kmh) {
            const scales = [1, 6, 12, 20, 29, 39, 50, 62, 75, 89, 103, 118];
            for (let i = 0; i < scales.length; i++) {
                if (kmh < scales[i]) return i;
            }
            return 12;
        }

        function getWindUnitLabel() {
            return { kmh: 'km/h', kt: 'kt', ms: 'm/s', bft: 'Bft' }[state.units.wind];
        }

        function convertTemp(celsius) {
            if (celsius === undefined || celsius === null) return 0;
            return state.units.temp === 'fahrenheit' ? Math.round(celsius * 9 / 5 + 32) : Math.round(celsius);
        }

        function getTempUnit() {
            return state.units.temp === 'celsius' ? '°C' : '°F';
        }

        function convertWave(meters) {
            if (meters === undefined || meters === null) return 0;
            return state.units.wave === 'ft' ? Math.round(meters * 3.28084 * 10) / 10 : Math.round(meters * 10) / 10;
        }

        function getWaveUnit() {
            return state.units.wave === 'm' ? 'm' : 'ft';
        }

        function convertPressure(hpa) {
            if (hpa === undefined || hpa === null) return 0;
            return state.units.pressure === 'inhg' ? Math.round(hpa * 0.02953 * 100) / 100 : Math.round(hpa);
        }

        function getPressureUnit() {
            return state.units.pressure === 'hpa' ? 'hPa' : 'inHg';
        }

        function getWindDirection(deg) {
            if (deg === undefined || deg === null) return 'N';
            const dirs = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSO', 'SO', 'OSO', 'O', 'ONO', 'NO', 'NNO'];
            return dirs[Math.round(deg / 22.5) % 16];
        }

        function getSeaState(waveHeight) {
            for (let i = 0; i < seaStates.length; i++) {
                if (waveHeight <= seaStates[i].maxHeight) return i;
            }
            return 9;
        }

        function getWeatherIcon(code, isDay = true) {
            const weather = weatherCodes[code] || weatherCodes[0];
            if (!isDay && code <= 3) return code === 0 ? '🌙' : '☁️';
            return weather.icon;
        }

        function getWeatherDesc(code) {
            return (weatherCodes[code] || weatherCodes[0]).desc;
        }

        // Géocodage
        async function geocodeCity(query) {
            const response = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=5&language=fr&format=json`);
            const data = await response.json();
            if (data.results && data.results.length > 0) {
                const result = data.results[0];
                return {
                    name: result.name + (result.admin1 ? `, ${result.admin1}` : ''),
                    lat: result.latitude,
                    lon: result.longitude
                };
            }
            throw new Error('Ville non trouvée');
        }

        // DOM Elements
        const mainContent = document.getElementById('mainContent');
        const searchInput = document.getElementById('searchInput');
        const searchBtn = document.getElementById('searchBtn');
        const locationBtn = document.getElementById('locationBtn');
        const addFavoriteBtn = document.getElementById('addFavoriteBtn');
        const weatherModeBtn = document.getElementById('weatherModeBtn');
        const marineModeBtn = document.getElementById('marineModeBtn');
        const logoIcon = document.getElementById('logoIcon');
        const locationText = document.getElementById('locationText');
        const modelSelect = document.getElementById('modelSelect');
        const waveUnitGroup = document.getElementById('waveUnitGroup');
        const favoritesRow = document.getElementById('favoritesRow');
        const apiStatus = document.getElementById('apiStatus');
        const apiStatusText = document.getElementById('apiStatusText');
        const addFavoriteModal = document.getElementById('addFavoriteModal');
        const addFavoriteForm = document.getElementById('addFavoriteForm');
        const closeModal = document.getElementById('closeModal');

        // Initialisation
        document.addEventListener('DOMContentLoaded', () => {
            // Initialiser le mode offline
            initOfflineMode();

            loadFavorites();
            const lastLocation = loadPreferences();
            setupEventListeners();

            // Restaurer la dernière localisation ou géolocaliser
            if (lastLocation && lastLocation.lat && lastLocation.lon) {
                state.currentIsPort = lastLocation.isPort || false;
                loadWeatherForCoords(lastLocation.lat, lastLocation.lon, lastLocation.name || 'Position sauvegardée');
            } else {
                initGeolocation();
            }
        });

        function setupEventListeners() {
            searchBtn.addEventListener('click', handleSearch);
            searchInput.addEventListener('keypress', e => e.key === 'Enter' && handleSearch());
            locationBtn.addEventListener('click', initGeolocation);

            weatherModeBtn.addEventListener('click', () => setMode('weather'));
            marineModeBtn.addEventListener('click', () => setMode('marine'));

            modelSelect.addEventListener('change', e => {
                state.model = e.target.value;
                savePreferences(); // Sauvegarder le modèle choisi
                if (state.currentCoords) {
                    loadWeatherForCoords(state.currentCoords.lat, state.currentCoords.lon, state.currentCity);
                }
            });

            // Unit selectors
            document.querySelectorAll('.unit-selector').forEach(selector => {
                selector.querySelectorAll('.unit-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        selector.querySelectorAll('.unit-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        const unitType = selector.id.replace('UnitSelector', '');
                        state.units[unitType] = btn.dataset.unit;
                        savePreferences(); // Sauvegarder les préférences
                        renderCurrentView();
                    });
                });
            });

            // Favorites
            favoritesRow.addEventListener('click', e => {
                const deleteBtn = e.target.closest('.delete-fav');
                if (deleteBtn) {
                    e.stopPropagation();
                    const index = parseInt(deleteBtn.dataset.delete);
                    state.favorites.splice(index, 1);
                    saveFavorites();
                    renderFavorites();
                    return;
                }

                const chip = e.target.closest('.favorite-chip');
                if (chip) {
                    document.querySelectorAll('.favorite-chip').forEach(c => c.classList.remove('active'));
                    chip.classList.add('active');
                    const lat = parseFloat(chip.dataset.lat);
                    const lon = parseFloat(chip.dataset.lon);
                    const name = chip.dataset.name;
                    const isPort = chip.dataset.port === 'true';
                    state.currentIsPort = isPort;
                    loadWeatherForCoords(lat, lon, name);
                }
            });

            // Modal favoris
            addFavoriteBtn.addEventListener('click', () => {
                if (state.currentCoords) {
                    document.getElementById('favLat').value = state.currentCoords.lat.toFixed(4);
                    document.getElementById('favLon').value = state.currentCoords.lon.toFixed(4);
                    document.getElementById('favName').value = state.currentCity || '';
                }
                addFavoriteModal.classList.add('active');
            });

            closeModal.addEventListener('click', () => {
                addFavoriteModal.classList.remove('active');
            });

            addFavoriteModal.addEventListener('click', e => {
                if (e.target === addFavoriteModal) {
                    addFavoriteModal.classList.remove('active');
                }
            });

            addFavoriteForm.addEventListener('submit', e => {
                e.preventDefault();
                const newFav = {
                    name: document.getElementById('favName').value,
                    lat: parseFloat(document.getElementById('favLat').value),
                    lon: parseFloat(document.getElementById('favLon').value),
                    emoji: document.getElementById('favEmoji').value || '📍',
                    isPort: document.getElementById('favIsPort').checked,
                    isCoastal: document.getElementById('favIsCoastal').checked
                };
                state.favorites.push(newFav);
                saveFavorites();
                renderFavorites();
                addFavoriteModal.classList.remove('active');
                addFavoriteForm.reset();
            });
        }

        function initGeolocation() {
            showLoading('Géolocalisation en cours...');

            // Vérifier si on est en HTTPS ou localhost (requis pour géolocalisation)
            const isSecure = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1' || location.protocol === 'file:';

            if (!isSecure) {
                console.warn('Géolocalisation requiert HTTPS. Utilisation de Paris par défaut.');
                showLoading('Chargement de Paris (géolocalisation requiert HTTPS)...');
                loadWeatherForCoords(48.8566, 2.3522, 'Paris');
                return;
            }

            if (navigator.geolocation) {
                // Timeout de secours si la géolocalisation prend trop de temps
                const fallbackTimeout = setTimeout(() => {
                    console.warn('Géolocalisation timeout - utilisation de Paris');
                    loadWeatherForCoords(48.8566, 2.3522, 'Paris');
                }, 8000);

                navigator.geolocation.getCurrentPosition(
                    position => {
                        clearTimeout(fallbackTimeout);
                        const { latitude, longitude } = position.coords;
                        console.log('Position obtenue:', latitude, longitude);
                        loadWeatherForCoords(latitude, longitude, 'Ma position');
                        document.getElementById('locationBadge').classList.add('live');
                    },
                    error => {
                        clearTimeout(fallbackTimeout);
                        let errorMsg = 'Erreur inconnue';
                        switch(error.code) {
                            case error.PERMISSION_DENIED:
                                errorMsg = 'Permission refusée';
                                break;
                            case error.POSITION_UNAVAILABLE:
                                errorMsg = 'Position indisponible';
                                break;
                            case error.TIMEOUT:
                                errorMsg = 'Timeout';
                                break;
                        }
                        console.warn('Géolocalisation échouée:', errorMsg, error);
                        showLoading(`Géolocalisation échouée (${errorMsg}). Chargement de Paris...`);
                        loadWeatherForCoords(48.8566, 2.3522, 'Paris');
                    },
                    {
                        timeout: 7000,
                        enableHighAccuracy: false,  // Plus rapide avec false
                        maximumAge: 300000  // Accepter une position de moins de 5 minutes
                    }
                );
            } else {
                console.warn('Géolocalisation non supportée');
                loadWeatherForCoords(48.8566, 2.3522, 'Paris');
            }
        }

        async function loadWeatherForCoords(lat, lon, cityName) {
            showLoading(`Chargement des données ${models[state.model].name}...`);

            try {
                state.currentCoords = { lat, lon };
                state.currentCity = cityName;
                locationText.textContent = cityName;
                savePreferences(); // Sauvegarder la dernière localisation

                const weatherData = await fetchWeatherData(lat, lon, state.model);
                state.weatherData = weatherData;
                state.lastUpdate = new Date();

                try {
                    const marineData = await fetchMarineData(lat, lon);
                    state.marineData = marineData;
                } catch (e) {
                    state.marineData = null;
                }

                state.tidesData = generateTidesData(lat, lon);

                apiStatus.classList.remove('error');
                // Afficher le modèle réellement utilisé (peut différer si hors zone)
                const usedModel = state.actualModel || state.model;
                const modelInfo = models[usedModel].name;
                const fallbackNote = (usedModel !== state.model) ? ' (auto)' : '';
                apiStatusText.textContent = `API Live - ${modelInfo}${fallbackNote}`;
                state.apiError = false;

                renderCurrentView();

                // Sauvegarder en cache pour le mode offline
                cacheWeatherData();

            } catch (error) {
                console.error('Erreur API:', error);
                state.apiError = true;
                apiStatus.classList.add('error');
                apiStatusText.textContent = 'Erreur API';
                showError('Impossible de charger les données météo.');

                // En cas d'erreur, essayer de charger les données en cache
                if (!isOnline) {
                    loadCachedData();
                }
            }
        }

        async function handleSearch() {
            const query = searchInput.value.trim();
            if (query) {
                showLoading(`Recherche de "${query}"...`);
                try {
                    const location = await geocodeCity(query);
                    document.querySelectorAll('.favorite-chip').forEach(c => c.classList.remove('active'));
                    document.getElementById('locationBadge').classList.remove('live');
                    loadWeatherForCoords(location.lat, location.lon, location.name);
                    searchInput.value = '';
                } catch (error) {
                    showError(`Ville "${query}" non trouvée`);
                }
            }
        }

        function setMode(mode) {
            state.mode = mode;
            weatherModeBtn.classList.toggle('active', mode === 'weather');
            marineModeBtn.classList.toggle('active', mode === 'marine');
            logoIcon.textContent = mode === 'marine' ? '⚓' : '🌊';
            waveUnitGroup.style.display = mode === 'marine' ? 'block' : 'none';
            savePreferences(); // Sauvegarder les préférences
            renderCurrentView();
        }

        function showLoading(text = 'Chargement...') {
            state.isLoading = true;
            mainContent.innerHTML = `
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <p class="loading-text">${text}</p>
                </div>
            `;
        }

        function showError(message) {
            mainContent.innerHTML = `
                <div class="error-message">
                    <div class="icon">⚠️</div>
                    <div class="text">${message}</div>
                    <button class="retry-btn" onclick="initGeolocation()">Réessayer</button>
                </div>
            `;
        }

        function renderCurrentView() {
            if (!state.weatherData) return;
            state.isLoading = false;

            if (state.mode === 'marine') {
                if (state.marineData) {
                    renderMarine();
                } else {
                    mainContent.innerHTML = `
                        <div class="error-message">
                            <div class="icon">🌊</div>
                            <div class="text">Données marines non disponibles pour cette position.<br>Essayez une ville côtière.</div>
                        </div>
                    `;
                }
            } else {
                renderWeather();
            }
        }

        // Rendu du graphique vent/rafales
        function renderWindChart(hourlyWind, hourlyGust, hours = 24) {
            const windData = hourlyWind.slice(0, hours);
            const gustData = hourlyGust.slice(0, hours);

            const maxValue = Math.max(...gustData, ...windData) + 10;
            const minValue = 0;

            const windPoints = windData.map((v, i) => {
                const x = 5 + (i / (windData.length - 1)) * 90;
                const y = 95 - ((v - minValue) / (maxValue - minValue)) * 85;
                return `${x},${y}`;
            }).join(' ');

            const gustPoints = gustData.map((v, i) => {
                const x = 5 + (i / (gustData.length - 1)) * 90;
                const y = 95 - ((v - minValue) / (maxValue - minValue)) * 85;
                return `${x},${y}`;
            }).join(' ');

            const windAreaPoints = `5,95 ${windPoints} 95,95`;

            const timeLabels = ['Maintenant', '+6h', '+12h', '+18h', '+24h'];
            if (hours > 24) {
                timeLabels[4] = '+48h';
            }

            return `
                <div class="wind-chart-container">
                    <div class="wind-chart-header">
                        <div class="wind-chart-title">📊 Vent & Rafales (${hours}h)</div>
                        <div class="wind-chart-legend">
                            <div class="legend-item">
                                <span class="legend-dot wind"></span>
                                <span>Vent moyen</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-dot gust"></span>
                                <span>Rafales</span>
                            </div>
                        </div>
                    </div>
                    <div class="wind-chart">
                        <svg viewBox="0 0 100 100" preserveAspectRatio="none">
                            <defs>
                                <linearGradient id="windGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" style="stop-color:rgba(0,180,216,0.4)"/>
                                    <stop offset="100%" style="stop-color:rgba(0,180,216,0.05)"/>
                                </linearGradient>
                                <linearGradient id="gustGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" style="stop-color:rgba(255,107,53,0.2)"/>
                                    <stop offset="100%" style="stop-color:rgba(255,107,53,0.02)"/>
                                </linearGradient>
                            </defs>
                            <!-- Grid -->
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="25" x2="95" y2="25"/>
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="50" x2="95" y2="50"/>
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="75" x2="95" y2="75"/>
                            <!-- Wind area -->
                            <polygon class="wind-area" points="${windAreaPoints}"/>
                            <!-- Gust line -->
                            <polyline class="wind-line gust" points="${gustPoints}"/>
                            <!-- Wind line -->
                            <polyline class="wind-line main" points="${windPoints}"/>
                            <!-- Scale labels -->
                            <text x="2" y="12" fill="rgba(255,255,255,0.4)" font-size="6">${Math.round(maxValue)} ${getWindUnitLabel()}</text>
                            <text x="2" y="52" fill="rgba(255,255,255,0.4)" font-size="6">${Math.round(maxValue/2)}</text>
                            <text x="2" y="95" fill="rgba(255,255,255,0.4)" font-size="6">0</text>
                        </svg>
                    </div>
                    <div class="wind-chart-labels">
                        ${timeLabels.map(l => `<span>${l}</span>`).join('')}
                    </div>
                </div>
            `;
        }

        // Rendu du graphique de houle
        function renderWaveChart(hourlyWaveHeight, hours = 24) {
            const waveData = hourlyWaveHeight?.slice(0, hours) || [];
            if (waveData.length === 0) return '';

            const maxValue = Math.max(...waveData) + 0.5;
            const minValue = 0;

            const points = waveData.map((v, i) => {
                const x = 5 + (i / (waveData.length - 1)) * 90;
                const y = 95 - ((v - minValue) / (maxValue - minValue)) * 85;
                return `${x},${y}`;
            }).join(' ');

            const areaPoints = `5,95 ${points} 95,95`;

            return `
                <div class="wave-chart-container">
                    <div class="wind-chart-header">
                        <div class="wind-chart-title">🌊 Hauteur des vagues (${hours}h)</div>
                    </div>
                    <div class="wave-chart">
                        <svg viewBox="0 0 100 100" preserveAspectRatio="none">
                            <defs>
                                <linearGradient id="waveGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" style="stop-color:rgba(155,89,182,0.5)"/>
                                    <stop offset="100%" style="stop-color:rgba(155,89,182,0.05)"/>
                                </linearGradient>
                            </defs>
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="25" x2="95" y2="25"/>
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="50" x2="95" y2="50"/>
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="75" x2="95" y2="75"/>
                            <polygon class="wave-area-fill" points="${areaPoints}"/>
                            <polyline class="wave-line-chart" points="${points}"/>
                            <text x="2" y="12" fill="rgba(255,255,255,0.4)" font-size="6">${maxValue.toFixed(1)}${getWaveUnit()}</text>
                            <text x="2" y="52" fill="rgba(255,255,255,0.4)" font-size="6">${(maxValue/2).toFixed(1)}</text>
                            <text x="2" y="95" fill="rgba(255,255,255,0.4)" font-size="6">0</text>
                        </svg>
                    </div>
                    <div class="wind-chart-labels">
                        <span>Maintenant</span>
                        <span>+6h</span>
                        <span>+12h</span>
                        <span>+18h</span>
                        <span>+24h</span>
                    </div>
                </div>
            `;
        }

        // Rendu de la courbe de marée
        function renderTideCurve(tidesData) {
            if (!tidesData) return '';

            const now = new Date();
            const startOfDay = new Date(now);
            startOfDay.setHours(0, 0, 0, 0);

            // Générer une courbe sinusoïdale pour 24h
            const points = [];
            const baseHeight = tidesData.currentHeight;
            const amplitude = tidesData.range / 2;

            for (let i = 0; i <= 24; i++) {
                const hour = i;
                const phase = (hour / 12.4) * Math.PI * 2; // période de marée ~12.4h
                const height = baseHeight + Math.sin(phase - Math.PI/2) * amplitude;
                const x = 5 + (i / 24) * 90;
                const y = 90 - ((height / (baseHeight + amplitude + 1)) * 80);
                points.push(`${x},${y}`);
            }

            const pathPoints = points.join(' ');
            const areaPoints = `5,95 ${pathPoints} 95,95`;

            // Position actuelle sur la courbe
            const currentHour = now.getHours() + now.getMinutes() / 60;
            const nowX = 5 + (currentHour / 24) * 90;
            const nowPhase = (currentHour / 12.4) * Math.PI * 2;
            const nowHeight = baseHeight + Math.sin(nowPhase - Math.PI/2) * amplitude;
            const nowY = 90 - ((nowHeight / (baseHeight + amplitude + 1)) * 80);

            return `
                <div class="tide-curve-container">
                    <div class="tide-curve-header">
                        <div class="wind-chart-title">📈 Courbe de marée (24h)</div>
                        <div style="font-size:0.75rem;color:rgba(255,255,255,0.6)">Coef. ${tidesData.coefficient}</div>
                    </div>
                    <div class="tide-curve-chart">
                        <svg viewBox="0 0 100 100" preserveAspectRatio="none">
                            <defs>
                                <linearGradient id="tideGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" style="stop-color:rgba(0,119,182,0.5)"/>
                                    <stop offset="100%" style="stop-color:rgba(0,119,182,0.05)"/>
                                </linearGradient>
                            </defs>
                            <!-- Grid -->
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="30" x2="95" y2="30"/>
                            <line stroke="rgba(255,255,255,0.1)" x1="5" y1="60" x2="95" y2="60"/>
                            <!-- Area fill -->
                            <polygon class="tide-area-fill" points="${areaPoints}"/>
                            <!-- Curve -->
                            <polyline class="tide-curve-path" points="${pathPoints}"/>
                            <!-- Now marker -->
                            <line x1="${nowX}" y1="5" x2="${nowX}" y2="95" stroke="var(--accent-orange)" stroke-width="1" stroke-dasharray="3 2"/>
                            <circle class="tide-now-marker" cx="${nowX}" cy="${nowY}" r="4"/>
                            <!-- Height labels -->
                            <text x="2" y="15" fill="rgba(255,255,255,0.4)" font-size="5">${(baseHeight + amplitude).toFixed(1)}m</text>
                            <text x="2" y="85" fill="rgba(255,255,255,0.4)" font-size="5">${(baseHeight - amplitude).toFixed(1)}m</text>
                        </svg>
                    </div>
                    <div class="tide-labels">
                        <span>00h</span>
                        <span>06h</span>
                        <span>12h</span>
                        <span>18h</span>
                        <span>24h</span>
                    </div>
                    <div style="text-align:center;margin-top:10px;font-size:0.85rem;">
                        <span style="color:var(--accent-orange);font-weight:600;">${tidesData.currentHeight}m</span>
                        <span style="opacity:0.6;"> niveau actuel</span>
                    </div>
                </div>
            `;
        }

        // Rendu du radar de pluie
        function renderRainRadar(lat, lon) {
            return `
                <div class="radar-container">
                    <div class="radar-header">
                        <div class="radar-title">🌧️ Radar de pluie</div>
                        <div class="radar-live">
                            <span class="pulse"></span>
                            <span>Live</span>
                        </div>
                    </div>
                    <div class="radar-map">
                        <div id="radarMap"></div>
                    </div>
                    <div class="radar-time-display" id="radarTimeDisplay">
                        <div class="radar-time-main" id="radarTimeMain">--:--</div>
                        <div class="radar-time-delta" id="radarTimeDelta">Chargement...</div>
                    </div>
                    <div class="radar-controls">
                        <button class="radar-btn" id="radarPlayBtn" onclick="playRadar()">▶️</button>
                        <div class="radar-timeline-wrapper">
                            <div class="radar-timeline">
                                <div class="radar-timeline-progress" id="radarProgress" style="width: 100%"></div>
                            </div>
                            <div class="radar-timeline-ticks" id="radarTimelineTicks"></div>
                        </div>
                    </div>
                    <div class="radar-frames-list" id="radarFramesList"></div>
                    <div class="radar-legend">
                        <div class="radar-legend-item">
                            <span class="radar-legend-color" style="background: #88ddff"></span>
                            <span>Légère</span>
                        </div>
                        <div class="radar-legend-item">
                            <span class="radar-legend-color" style="background: #00bb00"></span>
                            <span>Modérée</span>
                        </div>
                        <div class="radar-legend-item">
                            <span class="radar-legend-color" style="background: #ffff00"></span>
                            <span>Forte</span>
                        </div>
                        <div class="radar-legend-item">
                            <span class="radar-legend-color" style="background: #ff8800"></span>
                            <span>Intense</span>
                        </div>
                        <div class="radar-legend-item">
                            <span class="radar-legend-color" style="background: #ff0000"></span>
                            <span>Très intense</span>
                        </div>
                    </div>
                </div>
            `;
        }

        // Carte Marine OpenSeaMap
        let marineChartMap = null;

        function renderMarineChart(lat, lon) {
            return `
                <div class="marine-chart-container" id="marineChartContainer">
                    <div class="marine-chart-header">
                        <div class="marine-chart-title">
                            🗺️ Carte Marine
                            <span class="fullscreen-hint">(double-clic pour agrandir)</span>
                        </div>
                        <div class="marine-chart-source">OpenSeaMap</div>
                    </div>
                    <div class="marine-chart-map" id="marineChartMap"></div>

                    <!-- Contrôles de couches (visible en fullscreen) -->
                    <div class="layer-controls" id="layerControls">
                        <div class="layer-control-title">📑 Couches cartographiques</div>
                        <label class="layer-toggle">
                            <input type="checkbox" id="layerSeamarks" checked onchange="toggleLayer('seamark', this.checked)">
                            ⚓ Balises, bouées & marques
                        </label>
                        <label class="layer-toggle">
                            <input type="checkbox" id="layerDepth" checked onchange="toggleLayer('depth', this.checked)">
                            🌊 Sondes de profondeur
                        </label>
                        <label class="layer-toggle">
                            <input type="checkbox" id="layerHarbours" checked onchange="toggleLayer('harbours', this.checked)">
                            🏠 Ports, marinas & mouillages
                        </label>
                        <label class="layer-toggle">
                            <input type="checkbox" id="layerBathy" onchange="toggleLayer('bathy', this.checked)">
                            🌊 Bathymétrie colorée
                        </label>
                        <label class="layer-toggle">
                            <input type="checkbox" id="layerContours" onchange="toggleLayer('contours', this.checked)">
                            〰️ Isobathes (lignes profondeur)
                        </label>
                        <label class="layer-toggle">
                            <input type="checkbox" id="layerSST" onchange="toggleLayer('sst', this.checked)">
                            🌡️ Température de mer (SST)
                        </label>

                        <div class="layer-control-title" style="margin-top:12px">🎣 Mode Pêche</div>
                        <label class="layer-toggle">
                            <input type="checkbox" id="layerFishing" onchange="toggleFishingMode(this.checked)">
                            🐟 Zones favorables pêche
                        </label>
                        <div id="fishingInfo" class="fishing-info" style="display:none;">
                            <div class="fishing-data">
                                <span>SST:</span> <span id="sstValue">--</span>°C
                            </div>
                            <div class="fishing-data">
                                <span>Conditions:</span> <span id="fishingCondition">--</span>
                            </div>
                        </div>

                        <div class="layer-control-title" style="margin-top:12px">📍 GPS & Tracking</div>
                        <label class="layer-toggle">
                            <input type="checkbox" id="gpsTracking" onchange="toggleGPSTracking(this.checked)">
                            📡 Suivi GPS temps réel
                        </label>
                        <label class="layer-toggle">
                            <input type="checkbox" id="gpsTrackShow" onchange="toggleGPSTrack(this.checked)">
                            〰️ Afficher la trace
                        </label>
                        <button class="gps-center-btn" onclick="centerOnGPS()">📍 Centrer sur ma position</button>
                        <div id="gpsStatus" class="gps-status">GPS inactif</div>
                    </div>

                    <!-- Légende détaillée (visible en fullscreen) -->
                    <div class="map-legend-detailed" id="mapLegendDetailed">
                        <div class="legend-section">
                            <div class="legend-section-title">🚨 Balisage latéral (AISM-A)</div>
                            <div class="legend-row"><span class="legend-icon" style="background:#e74c3c">▲</span> Bâbord (rouge) - à gauche en entrant</div>
                            <div class="legend-row"><span class="legend-icon" style="background:#27ae60">▲</span> Tribord (vert) - à droite en entrant</div>
                        </div>
                        <div class="legend-section">
                            <div class="legend-section-title">⚠️ Balisage cardinal</div>
                            <div class="legend-row"><span class="legend-icon cardinal-n">▲▲</span> Nord - passer au Nord</div>
                            <div class="legend-row"><span class="legend-icon cardinal-s">▼▼</span> Sud - passer au Sud</div>
                            <div class="legend-row"><span class="legend-icon cardinal-e">▲▼</span> Est - passer à l'Est</div>
                            <div class="legend-row"><span class="legend-icon cardinal-w">▼▲</span> Ouest - passer à l'Ouest</div>
                        </div>
                        <div class="legend-section">
                            <div class="legend-section-title">💡 Feux & Phares</div>
                            <div class="legend-row"><span class="legend-icon light-white">★</span> Feu blanc</div>
                            <div class="legend-row"><span class="legend-icon light-red">★</span> Feu rouge</div>
                            <div class="legend-row"><span class="legend-icon light-green">★</span> Feu vert</div>
                            <div class="legend-row"><span class="legend-icon light-yellow">★</span> Feu jaune/orange</div>
                        </div>
                        <div class="legend-section">
                            <div class="legend-section-title">🌊 Profondeurs (GEBCO)</div>
                            <div class="depth-gradient-large"></div>
                            <div class="depth-labels-large">
                                <span>0m</span><span>5m</span><span>10m</span><span>20m</span><span>50m</span><span>100m</span><span>200m+</span>
                            </div>
                        </div>
                        <div class="legend-section">
                            <div class="legend-section-title">⚓ Infrastructures</div>
                            <div class="legend-row"><span class="legend-icon port-icon">⚓</span> Port / Marina</div>
                            <div class="legend-row"><span class="legend-icon anchor-icon">⚓</span> Zone de mouillage</div>
                            <div class="legend-row"><span class="legend-icon fuel-icon">⛽</span> Station carburant</div>
                            <div class="legend-row"><span class="legend-icon repair-icon">🔧</span> Réparations</div>
                        </div>
                        <div class="legend-section">
                            <div class="legend-section-title">⛔ Dangers & Restrictions</div>
                            <div class="legend-row"><span class="legend-icon danger-icon">☠️</span> Épave / Obstruction</div>
                            <div class="legend-row"><span class="legend-icon rock-icon">▲</span> Rocher / Récif</div>
                            <div class="legend-row"><span class="legend-icon restricted-icon">⊘</span> Zone interdite / Réglementée</div>
                            <div class="legend-row"><span class="legend-icon cable-icon">〰️</span> Câble sous-marin</div>
                        </div>
                        <div class="legend-section">
                            <div class="legend-section-title">🧭 Navigation</div>
                            <div class="legend-row"><span class="legend-icon lane-icon">→</span> Chenal / Rail de navigation</div>
                            <div class="legend-row"><span class="legend-icon separation-icon">║</span> Dispositif de séparation du trafic</div>
                        </div>
                    </div>

                    <!-- Info box compact -->
                    <div class="map-info-box" id="mapInfoBox">
                        <div class="info-coords">📍 <span class="coords" id="mapCoords">${lat.toFixed(4)}°N, ${lon.toFixed(4)}°E</span></div>
                        <div class="info-zoom">🔍 Zoom: <span id="mapZoomLevel">13</span></div>
                        <div class="info-sources">Sources: OpenSeaMap, GEBCO</div>
                    </div>

                    <!-- Légende compacte (mode normal) -->
                    <div class="marine-chart-legend">
                        <div class="marine-legend-item"><span class="legend-marker" style="background:#e74c3c">◀</span> Bâbord</div>
                        <div class="marine-legend-item"><span class="legend-marker" style="background:#27ae60">▶</span> Tribord</div>
                        <div class="marine-legend-item"><span class="legend-marker" style="background:#f1c40f">●</span> Cardinal</div>
                        <div class="marine-legend-item"><span class="legend-marker light">★</span> Phare/Feu</div>
                        <div class="marine-legend-item"><span class="legend-marker port">⚓</span> Port</div>
                        <div class="marine-legend-item"><span class="legend-marker depth"></span> Profondeur</div>
                        <div class="marine-legend-item"><span class="legend-marker" style="background:#e74c3c">☠</span> Danger</div>
                        <div class="marine-legend-item"><span class="legend-marker" style="background:#9b59b6">⊘</span> Interdit</div>
                    </div>
                    <div class="marine-chart-controls">
                        <button class="marine-zoom-btn close-btn" onclick="toggleMarineFullscreen()" title="Fermer (Escape)">✕</button>
                        <button class="marine-zoom-btn expand-btn" onclick="toggleMarineFullscreen()" title="Plein écran">⛶</button>
                        <button class="marine-zoom-btn" onclick="marineChartZoom(1)" title="Zoom +">➕</button>
                        <button class="marine-zoom-btn" onclick="marineChartZoom(-1)" title="Zoom -">➖</button>
                        <button class="marine-zoom-btn" onclick="marineChartCenter()" title="Recentrer">📍</button>
                        <button class="marine-zoom-btn" onclick="toggleMapStyle()" title="Changer le style">🎨</button>
                        <button class="marine-zoom-btn gps-btn" id="gpsToggleBtn" onclick="toggleGPSTracking()" title="Suivi GPS">📡</button>
                        <button class="marine-zoom-btn fishing-btn" id="fishingToggleBtn" onclick="toggleFishingMode()" title="Mode Pêche">🎣</button>
                    </div>
                </div>
            `;
        }

        async function initMarineChart(lat, lon) {
            // Charger Leaflet si pas déjà chargé
            if (!window.L) {
                const leafletCSS = document.createElement('link');
                leafletCSS.rel = 'stylesheet';
                leafletCSS.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
                document.head.appendChild(leafletCSS);

                await new Promise((resolve) => {
                    const script = document.createElement('script');
                    script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
                    script.onload = resolve;
                    document.head.appendChild(script);
                });
            }

            await new Promise(r => setTimeout(r, 100));

            const mapContainer = document.getElementById('marineChartMap');
            if (!mapContainer) return;

            if (marineChartMap) {
                marineChartMap.remove();
            }

            marineChartMap = L.map('marineChartMap', {
                zoomControl: false,
                attributionControl: false
            }).setView([lat, lon], 13);

            // Couches de base
            marineChartMap._baseLayers = {
                light: L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { maxZoom: 18 }),
                dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { maxZoom: 18 }),
                satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { maxZoom: 18 }),
                osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 18 })
            };
            marineChartMap._currentBaseLayer = 'light';
            marineChartMap._baseLayers.light.addTo(marineChartMap);

            // Couche GEBCO bathymétrie colorée (fond marin avec relief)
            marineChartMap._gebcoLayer = L.tileLayer.wms('https://wms.gebco.net/mapserv?', {
                layers: 'GEBCO_LATEST_SUB_ICE_TOPO',
                format: 'image/png',
                transparent: true,
                opacity: 0.4,
                maxZoom: 18
            });

            // Couche OpenSeaMap (données marines: bouées, phares, ports, etc.)
            marineChartMap._seaLayer = L.tileLayer('https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
                maxZoom: 18,
                opacity: 1
            }).addTo(marineChartMap);

            // Couche de bathymétrie (profondeurs sondes) - OpenSeaMap
            marineChartMap._depthLayer = L.tileLayer('https://tiles.openseamap.org/depth/{z}/{x}/{y}.png', {
                maxZoom: 18,
                opacity: 0.7
            }).addTo(marineChartMap);

            // Couche des ports/harbours/sport
            marineChartMap._harbourLayer = L.tileLayer('https://tiles.openseamap.org/sport/{z}/{x}/{y}.png', {
                maxZoom: 18,
                opacity: 0.9
            }).addTo(marineChartMap);

            // Marqueur position actuelle (statique)
            marineChartMap._homeMarker = L.circleMarker([lat, lon], {
                radius: 10,
                fillColor: '#e74c3c',
                color: '#fff',
                weight: 3,
                opacity: 1,
                fillOpacity: 0.9
            }).addTo(marineChartMap).bindPopup(`
                <div style="text-align:center">
                    <b>${state.currentCity || 'Position'}</b><br>
                    <small>Lat: ${lat.toFixed(4)}° | Lon: ${lon.toFixed(4)}°</small>
                </div>
            `);

            // Marqueur GPS temps réel (initialement caché)
            marineChartMap._gpsMarker = L.marker([lat, lon], {
                icon: L.divIcon({
                    className: 'gps-marker',
                    html: '<div class="gps-marker-inner"><div class="gps-arrow"></div></div>',
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                })
            });

            // Cercle de précision GPS
            marineChartMap._gpsAccuracy = L.circle([lat, lon], {
                radius: 50,
                color: '#3498db',
                fillColor: '#3498db',
                fillOpacity: 0.15,
                weight: 1
            });

            // Trace du parcours GPS
            marineChartMap._gpsTrack = L.polyline([], {
                color: '#e74c3c',
                weight: 3,
                opacity: 0.7
            });

            // Stocker les coordonnées pour recentrer
            marineChartMap._homeCoords = [lat, lon];
            marineChartMap._gpsTracking = false;
            marineChartMap._gpsWatchId = null;
            marineChartMap._gpsTrackPoints = [];

            // Mettre à jour les coordonnées au survol
            marineChartMap.on('mousemove', (e) => {
                const coordsEl = document.getElementById('mapCoords');
                if (coordsEl) {
                    coordsEl.textContent = `${e.latlng.lat.toFixed(4)}°N, ${e.latlng.lng.toFixed(4)}°E`;
                }
            });

            // Mettre à jour le niveau de zoom
            marineChartMap.on('zoomend', () => {
                const zoomEl = document.getElementById('mapZoomLevel');
                if (zoomEl) {
                    zoomEl.textContent = marineChartMap.getZoom();
                }
            });

            // Double-clic pour fullscreen (évite le conflit avec le pan)
            marineChartMap.doubleClickZoom.disable(); // Désactiver le zoom par double-clic
            marineChartMap.on('dblclick', () => {
                const container = document.getElementById('marineChartContainer');
                if (container && !container.classList.contains('fullscreen')) {
                    toggleMarineFullscreen();
                }
            });
        }

        // Toggle fullscreen
        function toggleMarineFullscreen() {
            const container = document.getElementById('marineChartContainer');
            if (!container) return;

            container.classList.toggle('fullscreen');

            // Invalider la taille de la carte après la transition
            setTimeout(() => {
                if (marineChartMap) {
                    marineChartMap.invalidateSize();
                }
            }, 350);

            // Fermer avec Escape
            if (container.classList.contains('fullscreen')) {
                document.addEventListener('keydown', handleEscapeKey);
            } else {
                document.removeEventListener('keydown', handleEscapeKey);
            }
        }

        function handleEscapeKey(e) {
            if (e.key === 'Escape') {
                const container = document.getElementById('marineChartContainer');
                if (container && container.classList.contains('fullscreen')) {
                    toggleMarineFullscreen();
                }
            }
        }

        // Changer le style de carte
        let mapStyleIndex = 0;
        const mapStyles = ['light', 'dark', 'satellite', 'osm'];

        function toggleMapStyle() {
            if (!marineChartMap || !marineChartMap._baseLayers) return;

            // Retirer la couche actuelle
            marineChartMap.removeLayer(marineChartMap._baseLayers[marineChartMap._currentBaseLayer]);

            // Passer au style suivant
            mapStyleIndex = (mapStyleIndex + 1) % mapStyles.length;
            marineChartMap._currentBaseLayer = mapStyles[mapStyleIndex];

            // Ajouter la nouvelle couche (en dessous des autres)
            marineChartMap._baseLayers[marineChartMap._currentBaseLayer].addTo(marineChartMap);
            marineChartMap._baseLayers[marineChartMap._currentBaseLayer].bringToBack();
        }

        // Toggle des couches
        function toggleLayer(layerName, show) {
            if (!marineChartMap) return;

            // Initialiser les couches SST et Bathy si nécessaires
            if (layerName === 'sst' && !marineChartMap._sstLayer) {
                // Couche SST (température de surface) - NOAA/CMEMS
                marineChartMap._sstLayer = L.tileLayer.wms('https://nrt.cmems-du.eu/thredds/wms/METOFFICE-GLO-SST-L4-NRT-OBS-SST-V2', {
                    layers: 'analysed_sst',
                    format: 'image/png',
                    transparent: true,
                    opacity: 0.6,
                    styles: 'boxfill/rainbow',
                    colorscalerange: '270,305' // Kelvin
                });
            }

            if (layerName === 'bathy' && !marineChartMap._bathyLayer) {
                // Bathymétrie colorée - GEBCO WMS
                marineChartMap._bathyLayer = L.tileLayer.wms('https://wms.gebco.net/mapserv?', {
                    layers: 'GEBCO_LATEST',
                    format: 'image/png',
                    transparent: true,
                    opacity: 0.5
                });
            }

            if (layerName === 'contours' && !marineChartMap._contoursLayer) {
                // Isobathes (lignes de profondeur) - EMODnet Bathymetry
                marineChartMap._contoursLayer = L.tileLayer.wms('https://ows.emodnet-bathymetry.eu/wms', {
                    layers: 'contours',
                    format: 'image/png',
                    transparent: true,
                    opacity: 0.8,
                    styles: ''
                });
            }

            const layers = {
                seamark: marineChartMap._seaLayer,
                depth: marineChartMap._depthLayer,
                harbours: marineChartMap._harbourLayer,
                gebco: marineChartMap._gebcoLayer,
                sst: marineChartMap._sstLayer,
                contours: marineChartMap._contoursLayer,
                bathy: marineChartMap._bathyLayer
            };

            const layer = layers[layerName];
            if (layer) {
                if (show) {
                    layer.addTo(marineChartMap);
                    // Afficher la légende correspondante
                    if (layerName === 'bathy') {
                        showBathyLegend(true);
                    }
                    if (layerName === 'sst') {
                        showSSTLegend(true);
                    }
                    if (layerName === 'contours') {
                        showContoursLegend(true);
                    }
                } else {
                    if (marineChartMap.hasLayer(layer)) {
                        marineChartMap.removeLayer(layer);
                    }
                    if (layerName === 'bathy') {
                        showBathyLegend(false);
                    }
                    if (layerName === 'sst') {
                        showSSTLegend(false);
                    }
                    if (layerName === 'contours') {
                        showContoursLegend(false);
                    }
                }
            }
        }

        function showBathyLegend(show) {
            let legend = document.getElementById('bathyLegend');
            if (!legend && show) {
                const container = document.getElementById('marineChartContainer');
                if (container) {
                    legend = document.createElement('div');
                    legend.id = 'bathyLegend';
                    legend.className = 'bathy-legend';
                    legend.innerHTML = `
                        <span style="font-size:0.7rem;color:rgba(255,255,255,0.7)">Profondeur:</span>
                        <div>
                            <div class="bathy-gradient"></div>
                            <div class="bathy-labels">
                                <span>0m</span>
                                <span>50m</span>
                                <span>200m</span>
                                <span>1000m+</span>
                            </div>
                        </div>
                    `;
                    container.appendChild(legend);
                }
            }
            if (legend) {
                legend.style.display = show ? 'flex' : 'none';
            }
        }

        function showSSTLegend(show) {
            let legend = document.getElementById('sstLegend');
            if (!legend && show) {
                const container = document.getElementById('marineChartContainer');
                if (container) {
                    legend = document.createElement('div');
                    legend.id = 'sstLegend';
                    legend.className = 'sst-legend';
                    legend.innerHTML = `
                        <div style="font-size:0.7rem;color:rgba(255,255,255,0.7);margin-bottom:3px">Temp. mer (SST):</div>
                        <div class="sst-gradient"></div>
                        <div class="sst-labels">
                            <span>5°C</span>
                            <span>15°C</span>
                            <span>25°C</span>
                        </div>
                    `;
                    container.appendChild(legend);
                }
            }
            if (legend) {
                legend.style.display = show ? 'block' : 'none';
            }
        }

        function showContoursLegend(show) {
            let legend = document.getElementById('contoursLegend');
            if (!legend && show) {
                const container = document.getElementById('marineChartContainer');
                if (container) {
                    legend = document.createElement('div');
                    legend.id = 'contoursLegend';
                    legend.className = 'contours-legend';
                    legend.innerHTML = `
                        <div style="font-size:0.7rem;color:rgba(255,255,255,0.7);margin-bottom:5px">〰️ Isobathes (EMODnet)</div>
                        <div class="contour-items">
                            <div class="contour-item"><span class="contour-line" style="background:#a8d8ff"></span> 0-10m</div>
                            <div class="contour-item"><span class="contour-line" style="background:#7bc8ff"></span> 10-20m</div>
                            <div class="contour-item"><span class="contour-line" style="background:#4db8ff"></span> 20-50m</div>
                            <div class="contour-item"><span class="contour-line" style="background:#1a9fff"></span> 50-100m</div>
                            <div class="contour-item"><span class="contour-line" style="background:#0077cc"></span> 100-200m</div>
                            <div class="contour-item"><span class="contour-line" style="background:#005599"></span> 200-500m</div>
                            <div class="contour-item"><span class="contour-line" style="background:#003366"></span> 500m+</div>
                        </div>
                    `;
                    container.appendChild(legend);
                }
            }
            if (legend) {
                legend.style.display = show ? 'block' : 'none';
            }
        }

        function marineChartZoom(delta) {
            if (marineChartMap) {
                marineChartMap.setZoom(marineChartMap.getZoom() + delta);
            }
        }

        function marineChartCenter() {
            if (marineChartMap && marineChartMap._homeCoords) {
                marineChartMap.setView(marineChartMap._homeCoords, 13);
            }
        }

        // ========== SUIVI GPS TEMPS RÉEL ==========
        function toggleGPSTracking(forceState) {
            if (!marineChartMap) return;

            const isActive = typeof forceState === 'boolean' ? forceState : !marineChartMap._gpsTracking;
            const btn = document.getElementById('gpsToggleBtn');
            const checkbox = document.getElementById('gpsTracking');
            const statusEl = document.getElementById('gpsStatus');

            if (isActive) {
                // Démarrer le suivi GPS
                if (!navigator.geolocation) {
                    if (statusEl) {
                        statusEl.textContent = 'GPS non disponible';
                        statusEl.className = 'gps-status error';
                    }
                    return;
                }

                marineChartMap._gpsTracking = true;
                if (btn) btn.classList.add('active');
                if (checkbox) checkbox.checked = true;
                if (statusEl) {
                    statusEl.textContent = 'Acquisition GPS...';
                    statusEl.className = 'gps-status';
                }

                // Ajouter le marqueur GPS
                marineChartMap._gpsMarker.addTo(marineChartMap);
                marineChartMap._gpsAccuracy.addTo(marineChartMap);

                // Démarrer le suivi
                marineChartMap._gpsWatchId = navigator.geolocation.watchPosition(
                    (position) => updateGPSPosition(position),
                    (error) => handleGPSError(error),
                    {
                        enableHighAccuracy: true,
                        maximumAge: 5000,
                        timeout: 10000
                    }
                );
            } else {
                // Arrêter le suivi GPS
                marineChartMap._gpsTracking = false;
                if (btn) btn.classList.remove('active');
                if (checkbox) checkbox.checked = false;
                if (statusEl) {
                    statusEl.textContent = 'GPS inactif';
                    statusEl.className = 'gps-status';
                }

                if (marineChartMap._gpsWatchId) {
                    navigator.geolocation.clearWatch(marineChartMap._gpsWatchId);
                    marineChartMap._gpsWatchId = null;
                }

                // Retirer le marqueur GPS
                if (marineChartMap.hasLayer(marineChartMap._gpsMarker)) {
                    marineChartMap.removeLayer(marineChartMap._gpsMarker);
                }
                if (marineChartMap.hasLayer(marineChartMap._gpsAccuracy)) {
                    marineChartMap.removeLayer(marineChartMap._gpsAccuracy);
                }
            }
        }

        function updateGPSPosition(position) {
            if (!marineChartMap || !marineChartMap._gpsTracking) return;

            const lat = position.coords.latitude;
            const lon = position.coords.longitude;
            const accuracy = position.coords.accuracy;
            const heading = position.coords.heading;
            const speed = position.coords.speed;

            // Mettre à jour le marqueur
            marineChartMap._gpsMarker.setLatLng([lat, lon]);
            marineChartMap._gpsAccuracy.setLatLng([lat, lon]);
            marineChartMap._gpsAccuracy.setRadius(accuracy);

            // Rotation selon le cap
            if (heading !== null && !isNaN(heading)) {
                const markerEl = document.querySelector('.gps-marker-inner');
                if (markerEl) {
                    markerEl.style.transform = `rotate(${heading}deg)`;
                }
            }

            // Ajouter au track si activé
            if (document.getElementById('gpsTrackShow')?.checked) {
                marineChartMap._gpsTrackPoints.push([lat, lon]);
                marineChartMap._gpsTrack.setLatLngs(marineChartMap._gpsTrackPoints);
                if (!marineChartMap.hasLayer(marineChartMap._gpsTrack)) {
                    marineChartMap._gpsTrack.addTo(marineChartMap);
                }
            }

            // Mettre à jour le statut
            const statusEl = document.getElementById('gpsStatus');
            if (statusEl) {
                const speedKmh = speed ? (speed * 3.6).toFixed(1) : '--';
                statusEl.innerHTML = `📍 ${lat.toFixed(5)}°, ${lon.toFixed(5)}°<br>Précision: ${accuracy.toFixed(0)}m | Vitesse: ${speedKmh} km/h`;
                statusEl.className = 'gps-status active';
            }

            // Mettre à jour les coordonnées affichées
            const coordsEl = document.getElementById('mapCoords');
            if (coordsEl) {
                coordsEl.textContent = `${lat.toFixed(4)}°N, ${lon.toFixed(4)}°E`;
            }
        }

        function handleGPSError(error) {
            const statusEl = document.getElementById('gpsStatus');
            if (statusEl) {
                let msg = 'Erreur GPS';
                if (error.code === 1) msg = 'GPS refusé par l\'utilisateur';
                if (error.code === 2) msg = 'Position indisponible';
                if (error.code === 3) msg = 'Timeout GPS';
                statusEl.textContent = msg;
                statusEl.className = 'gps-status error';
            }
        }

        function centerOnGPS() {
            if (!marineChartMap) return;

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lon = position.coords.longitude;
                    marineChartMap.setView([lat, lon], 15);
                },
                (error) => handleGPSError(error),
                { enableHighAccuracy: true }
            );
        }

        function toggleGPSTrack(show) {
            if (!marineChartMap) return;

            if (show) {
                if (marineChartMap._gpsTrackPoints.length > 0) {
                    marineChartMap._gpsTrack.setLatLngs(marineChartMap._gpsTrackPoints);
                    marineChartMap._gpsTrack.addTo(marineChartMap);
                }
            } else {
                if (marineChartMap.hasLayer(marineChartMap._gpsTrack)) {
                    marineChartMap.removeLayer(marineChartMap._gpsTrack);
                }
            }
        }

        // ========== MODE PÊCHE ==========
        let fishingModeActive = false;
        let seaSurfaceTemp = null;

        async function toggleFishingMode(forceState) {
            const isActive = typeof forceState === 'boolean' ? forceState : !fishingModeActive;
            fishingModeActive = isActive;

            const btn = document.getElementById('fishingToggleBtn');
            const checkbox = document.getElementById('layerFishing');
            const infoEl = document.getElementById('fishingInfo');

            if (isActive) {
                if (btn) btn.classList.add('active');
                if (checkbox) checkbox.checked = true;
                if (infoEl) infoEl.style.display = 'block';

                // Charger les données SST et activer la couche
                await loadFishingData();
                toggleLayer('sst', true);
                document.getElementById('layerSST').checked = true;
            } else {
                if (btn) btn.classList.remove('active');
                if (checkbox) checkbox.checked = false;
                if (infoEl) infoEl.style.display = 'none';

                toggleLayer('sst', false);
                document.getElementById('layerSST').checked = false;
            }
        }

        async function loadFishingData() {
            if (!state.currentCoords) return;

            const { lat, lon } = state.currentCoords;

            try {
                // Récupérer la température de surface de mer via Open-Meteo Marine
                const response = await fetch(
                    `https://api.open-meteo.com/v1/marine?latitude=${lat}&longitude=${lon}&current=sea_surface_temperature&hourly=sea_surface_temperature`
                );

                if (response.ok) {
                    const data = await response.json();
                    seaSurfaceTemp = data.current?.sea_surface_temperature;

                    updateFishingDisplay();
                }
            } catch (e) {
                console.warn('Erreur chargement données pêche:', e);
                // Fallback: estimation basée sur la saison et la latitude
                estimateFishingConditions();
            }
        }

        function updateFishingDisplay() {
            const sstEl = document.getElementById('sstValue');
            const conditionEl = document.getElementById('fishingCondition');

            if (sstEl) {
                sstEl.textContent = seaSurfaceTemp !== null ? seaSurfaceTemp.toFixed(1) : '--';
            }

            if (conditionEl && seaSurfaceTemp !== null) {
                // Évaluer les conditions de pêche
                let condition = '';
                let cssClass = '';

                // Conditions générales de pêche selon la température
                // (varie selon les espèces ciblées)
                if (seaSurfaceTemp >= 14 && seaSurfaceTemp <= 22) {
                    condition = 'Excellentes (bar, dorade)';
                    cssClass = 'fishing-good';
                } else if (seaSurfaceTemp >= 10 && seaSurfaceTemp <= 26) {
                    condition = 'Bonnes (selon espèces)';
                    cssClass = 'fishing-medium';
                } else if (seaSurfaceTemp < 10) {
                    condition = 'Froides (morue, lieu)';
                    cssClass = 'fishing-medium';
                } else {
                    condition = 'Eau chaude (thon, espadon)';
                    cssClass = 'fishing-medium';
                }

                conditionEl.textContent = condition;
                conditionEl.className = cssClass;
            }
        }

        function estimateFishingConditions() {
            // Estimation basée sur la saison
            const month = new Date().getMonth();
            const lat = state.currentCoords?.lat || 45;

            // Estimation grossière de la SST
            let baseSst = 15; // Température de base
            const seasonalVariation = 8 * Math.sin((month - 3) * Math.PI / 6); // Max en août
            const latitudeEffect = -(lat - 45) * 0.5; // Plus froid vers le nord

            seaSurfaceTemp = baseSst + seasonalVariation + latitudeEffect;
            updateFishingDisplay();
        }

        // ========== COUCHES BATHYMÉTRIE & SST ==========

        // État et fonctions du radar
        let radarMap = null;
        let radarLayer = null;
        let radarFrames = [];
        let currentRadarFrame = 0;
        let radarPlaying = false;
        let radarInterval = null;

        async function initRadar(lat, lon) {
            // Charger Leaflet si pas déjà chargé
            if (!window.L) {
                const leafletCSS = document.createElement('link');
                leafletCSS.rel = 'stylesheet';
                leafletCSS.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
                document.head.appendChild(leafletCSS);

                await new Promise((resolve) => {
                    const script = document.createElement('script');
                    script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
                    script.onload = resolve;
                    document.head.appendChild(script);
                });
            }

            // Attendre que le DOM soit prêt
            await new Promise(r => setTimeout(r, 100));

            const mapContainer = document.getElementById('radarMap');
            if (!mapContainer) return;

            // Initialiser la carte
            if (radarMap) {
                radarMap.remove();
            }

            radarMap = L.map('radarMap', {
                zoomControl: false,
                attributionControl: false
            }).setView([lat, lon], 8);

            // Fond de carte sombre
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                maxZoom: 19
            }).addTo(radarMap);

            // Marqueur position
            L.circleMarker([lat, lon], {
                radius: 6,
                fillColor: '#ff6b35',
                color: '#fff',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.8
            }).addTo(radarMap);

            // Charger les données RainViewer
            try {
                const response = await fetch('https://api.rainviewer.com/public/weather-maps.json');
                const data = await response.json();

                // Séparer passé et prévisions (nowcast)
                const pastFrames = data.radar.past || [];
                const nowcastFrames = data.radar.nowcast || [];

                // Marquer les frames nowcast
                nowcastFrames.forEach(f => f.isNowcast = true);

                radarFrames = pastFrames.concat(nowcastFrames);
                currentRadarFrame = pastFrames.length - 1; // Commencer au présent

                renderRadarFramesList();
                updateRadarFrame();
            } catch (e) {
                console.error('Erreur RainViewer:', e);
            }
        }

        // Afficher la liste des horaires disponibles
        function renderRadarFramesList() {
            const container = document.getElementById('radarFramesList');
            const ticksContainer = document.getElementById('radarTimelineTicks');
            if (!container) return;

            const now = new Date();

            // Générer les boutons pour chaque frame
            container.innerHTML = radarFrames.map((frame, index) => {
                const time = new Date(frame.time * 1000);
                const diffMinutes = Math.round((time - now) / 60000);
                const timeStr = time.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });

                const isFuture = diffMinutes > 0;
                const isNowcast = frame.isNowcast;
                const classes = ['radar-frame-btn'];
                if (index === currentRadarFrame) classes.push('active');
                if (isFuture) classes.push('future');
                if (isNowcast) classes.push('nowcast');

                return `<button class="${classes.join(' ')}" onclick="selectRadarFrame(${index})" title="${isFuture ? 'Prévision' : 'Passé'}: ${diffMinutes > 0 ? '+' : ''}${diffMinutes} min">
                    ${timeStr}
                </button>`;
            }).join('');

            // Générer les ticks de la timeline (premier, milieu, dernier)
            if (ticksContainer && radarFrames.length > 0) {
                const firstTime = new Date(radarFrames[0].time * 1000);
                const lastTime = new Date(radarFrames[radarFrames.length - 1].time * 1000);
                const midIndex = Math.floor(radarFrames.length / 2);
                const midTime = new Date(radarFrames[midIndex].time * 1000);

                const formatTick = (d) => d.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });

                ticksContainer.innerHTML = `
                    <span>${formatTick(firstTime)}</span>
                    <span>|</span>
                    <span>${formatTick(midTime)}</span>
                    <span>|</span>
                    <span>${formatTick(lastTime)}</span>
                `;
            }
        }

        // Sélectionner une frame spécifique
        function selectRadarFrame(index) {
            currentRadarFrame = index;
            updateRadarFrame();

            // Mettre à jour les boutons actifs
            document.querySelectorAll('.radar-frame-btn').forEach((btn, i) => {
                btn.classList.toggle('active', i === index);
            });
        }

        function updateRadarFrame() {
            if (!radarMap || radarFrames.length === 0) return;

            const frame = radarFrames[currentRadarFrame];
            const tileUrl = `https://tilecache.rainviewer.com${frame.path}/256/{z}/{x}/{y}/4/1_1.png`;

            if (radarLayer) {
                radarMap.removeLayer(radarLayer);
            }

            radarLayer = L.tileLayer(tileUrl, {
                opacity: 0.7,
                zIndex: 1000
            }).addTo(radarMap);

            // Mettre à jour l'affichage du temps
            const time = new Date(frame.time * 1000);
            const now = new Date();
            const diffMinutes = Math.round((time - now) / 60000);

            // Formater l'heure locale
            const localTime = time.toLocaleTimeString('fr-FR', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            });

            // Affichage principal de l'heure
            const timeMain = document.getElementById('radarTimeMain');
            if (timeMain) {
                timeMain.textContent = localTime;
            }

            // Affichage du delta et type
            const timeDelta = document.getElementById('radarTimeDelta');
            if (timeDelta) {
                let deltaText;
                let typeText = frame.isNowcast ? '📡 Prévision' : '📍 Observation';

                if (Math.abs(diffMinutes) <= 5) {
                    deltaText = 'Maintenant';
                } else if (diffMinutes > 0) {
                    deltaText = `dans ${diffMinutes} min`;
                } else {
                    deltaText = `il y a ${Math.abs(diffMinutes)} min`;
                }

                timeDelta.textContent = `${typeText} • ${deltaText}`;
                timeDelta.className = 'radar-time-delta ' + (diffMinutes > 0 ? 'future' : 'past');
            }

            // Mettre à jour la barre de progression
            const progress = document.getElementById('radarProgress');
            if (progress) {
                progress.style.width = `${((currentRadarFrame + 1) / radarFrames.length) * 100}%`;
            }
        }

        function playRadar() {
            const playBtn = document.getElementById('radarPlayBtn');

            if (radarPlaying) {
                radarPlaying = false;
                clearInterval(radarInterval);
                if (playBtn) playBtn.textContent = '▶️';
                return;
            }

            radarPlaying = true;
            if (playBtn) playBtn.textContent = '⏸️';
            currentRadarFrame = 0;

            radarInterval = setInterval(() => {
                currentRadarFrame = (currentRadarFrame + 1) % radarFrames.length;
                updateRadarFrame();

                // Mettre à jour les boutons actifs
                document.querySelectorAll('.radar-frame-btn').forEach((btn, i) => {
                    btn.classList.toggle('active', i === currentRadarFrame);
                });

                if (currentRadarFrame === radarFrames.length - 1) {
                    setTimeout(() => {
                        if (radarPlaying) {
                            currentRadarFrame = 0;
                        }
                    }, 2000);
                }
            }, 700);
        }

        // Rendu de la rose des vents SVG
        // Widget vent compact style Windy
        // Wind particles animation state
        let windParticlesAnimation = null;
        let windParticles = [];

        function renderWindWidget(windSpeed, windGust, windDir) {
            const beaufort = kmhToBeaufort(windSpeed);
            const gustBeaufort = kmhToBeaufort(windGust);
            const dirText = getWindDirection(windDir);

            // Générer les segments Beaufort (points)
            let bfDots = '';
            for (let i = 0; i < 12; i++) {
                let cls = 'bf-seg';
                if (i < beaufort) cls += ' active';
                else if (i < gustBeaufort) cls += ' gust';
                bfDots += `<div class="${cls}"></div>`;
            }

            // ID unique pour le canvas
            const canvasId = 'windCanvas' + Date.now();

            // Stocker les données pour l'animation
            window.currentWindData = { speed: windSpeed, gust: windGust, dir: windDir };

            return `
                <div class="wind-particles-container">
                    <canvas id="${canvasId}" class="wind-particles-canvas"></canvas>
                    <div class="wind-particles-overlay">
                        <div class="wind-data-box">
                            <div class="wind-data-speed">
                                ${convertWind(windSpeed, state.units.wind)}<span class="unit">${getWindUnitLabel()}</span>
                            </div>
                            <div class="wind-data-dir">${dirText} (${Math.round(windDir)}°)</div>
                            <div class="wind-data-beaufort">${bfDots}</div>
                        </div>
                        <div class="wind-gust-box">
                            <div class="wind-gust-val">${convertWind(windGust, state.units.wind)}</div>
                            <div class="wind-gust-lbl">Rafales</div>
                        </div>
                    </div>
                    <div class="wind-compass-overlay">
                        <svg viewBox="0 0 55 55">
                            <circle cx="27.5" cy="27.5" r="25" fill="rgba(0,0,0,0.5)" stroke="rgba(255,255,255,0.2)" stroke-width="1"/>
                            <text x="27.5" y="9" fill="rgba(255,255,255,0.7)" font-size="7" text-anchor="middle" font-weight="bold">N</text>
                            <text x="27.5" y="51" fill="rgba(255,255,255,0.4)" font-size="6" text-anchor="middle">S</text>
                            <text x="49" y="30" fill="rgba(255,255,255,0.4)" font-size="6" text-anchor="middle">E</text>
                            <text x="6" y="30" fill="rgba(255,255,255,0.4)" font-size="6" text-anchor="middle">O</text>
                            <g transform="rotate(${windDir + 180}, 27.5, 27.5)">
                                <path d="M27.5,8 L24,20 L27.5,17 L31,20 Z" fill="#4fc3f7"/>
                                <line x1="27.5" y1="17" x2="27.5" y2="40" stroke="#4fc3f7" stroke-width="2"/>
                            </g>
                            <circle cx="27.5" cy="27.5" r="3" fill="white"/>
                        </svg>
                    </div>
                </div>
            `;
        }

        // Initialiser l'animation des particules de vent
        function initWindParticles(canvasId) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * 2;
            canvas.height = rect.height * 2;
            ctx.scale(2, 2);

            const width = rect.width;
            const height = rect.height;

            // Récupérer les données de vent
            const windData = window.currentWindData || { speed: 0, gust: 0, dir: 270 };
            const windSpeed = windData.speed || 0;
            const gustSpeed = windData.gust || 0;

            // Si pas de vent (< 2 km/h), afficher un canvas calme sans animation
            if (windSpeed < 2) {
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.font = '14px -apple-system, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Vent calme', width / 2, height / 2);
                return;
            }

            // +90 pour convertir la direction météo (d'où vient le vent) en direction de flux (où va le vent)
            const windRad = (windData.dir + 90) * Math.PI / 180;
            const normalizedSpeed = Math.min(windSpeed / 10, 4); // Vitesse plus douce

            // Créer les particules réparties sur toute la surface
            const particleCount = Math.min(60 + Math.floor(windSpeed), 150);
            windParticles = [];

            for (let i = 0; i < particleCount; i++) {
                const isGust = gustSpeed > windSpeed * 1.2 && Math.random() < 0.2;
                windParticles.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    length: 15 + Math.random() * 25,
                    speed: 0.3 + Math.random() * normalizedSpeed,
                    opacity: 0.4 + Math.random() * 0.4,
                    isGust: isGust,
                    // Décalage de phase pour que les particules ne soient pas synchronisées
                    phase: Math.random() * Math.PI * 2
                });
            }

            if (windParticlesAnimation) {
                cancelAnimationFrame(windParticlesAnimation);
            }

            function animate() {
                if (!document.getElementById(canvasId)) {
                    cancelAnimationFrame(windParticlesAnimation);
                    return;
                }

                ctx.clearRect(0, 0, width, height);

                windParticles.forEach(p => {
                    const endX = p.x + Math.cos(windRad) * p.length;
                    const endY = p.y + Math.sin(windRad) * p.length;

                    // Dessiner le vecteur/particule
                    if (p.isGust) {
                        ctx.strokeStyle = `rgba(231, 76, 60, ${p.opacity})`; // Rouge pour les rafales
                        ctx.lineWidth = 2;
                    } else {
                        ctx.strokeStyle = `rgba(79, 195, 247, ${p.opacity})`; // Bleu pour le vent
                        ctx.lineWidth = 1.5;
                    }

                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(endX, endY);
                    ctx.lineCap = 'round';
                    ctx.stroke();

                    // Petite pointe de flèche
                    const arrowSize = 4;
                    const arrowAngle = Math.PI / 6;
                    ctx.beginPath();
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(
                        endX - arrowSize * Math.cos(windRad - arrowAngle),
                        endY - arrowSize * Math.sin(windRad - arrowAngle)
                    );
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(
                        endX - arrowSize * Math.cos(windRad + arrowAngle),
                        endY - arrowSize * Math.sin(windRad + arrowAngle)
                    );
                    ctx.stroke();

                    // Déplacer la particule
                    p.x += Math.cos(windRad) * p.speed;
                    p.y += Math.sin(windRad) * p.speed;

                    // Wrap around - réapparaître de l'autre côté avec position Y aléatoire
                    const margin = 50;
                    if (p.x > width + margin) {
                        p.x = -margin;
                        p.y = Math.random() * height;
                    } else if (p.x < -margin) {
                        p.x = width + margin;
                        p.y = Math.random() * height;
                    }
                    if (p.y > height + margin) {
                        p.y = -margin;
                        p.x = Math.random() * width;
                    } else if (p.y < -margin) {
                        p.y = height + margin;
                        p.x = Math.random() * width;
                    }
                });

                windParticlesAnimation = requestAnimationFrame(animate);
            }

            animate();
        }

        // Observer pour initialiser le canvas quand il apparaît
        function setupWindParticlesObserver() {
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1) {
                            const canvas = node.querySelector?.('.wind-particles-canvas') ||
                                          (node.classList?.contains('wind-particles-canvas') ? node : null);
                            if (canvas && canvas.id) {
                                setTimeout(() => initWindParticles(canvas.id), 100);
                            }
                        }
                    });
                });
            });

            observer.observe(document.body, { childList: true, subtree: true });
        }

        // Initialiser l'observer au chargement
        document.addEventListener('DOMContentLoaded', setupWindParticlesObserver);

        // Prédiction de pluie par tranches
        function renderRainForecast(hourlyPrecip, hourlyWeatherCode) {
            // Heure actuelle
            const now = new Date();

            // Tranches: 10min, 30min, 1h, 2h, 5h avec les minutes à ajouter
            const slots = [
                { label: '10\'', index: 0, addMinutes: 10 },
                { label: '30\'', index: 0, addMinutes: 30 },
                { label: '1h', index: 1, addMinutes: 60 },
                { label: '2h', index: 2, addMinutes: 120 },
                { label: '5h', index: 5, addMinutes: 300 }
            ];

            // Calculer les précipitations pour chaque tranche
            const rainData = slots.map((slot, i) => {
                const precip = hourlyPrecip[slot.index] || 0;
                const code = hourlyWeatherCode[slot.index] || 0;

                // Calculer l'heure locale correspondante
                const futureTime = new Date(now.getTime() + slot.addMinutes * 60000);
                const localTime = futureTime.toLocaleTimeString('fr-FR', {
                    hour: '2-digit',
                    minute: '2-digit'
                });

                // Pour 10min et 30min, interpoler depuis l'heure actuelle
                let amount = precip;
                if (i === 0) amount = precip * 0.17; // ~10min
                if (i === 1) amount = precip * 0.5;  // ~30min

                let level = 'none';
                let icon = '☀️';

                if (amount > 0 && amount < 0.5) { level = 'light'; icon = '🌦️'; }
                else if (amount >= 0.5 && amount < 2) { level = 'moderate'; icon = '🌧️'; }
                else if (amount >= 2) { level = 'heavy'; icon = '⛈️'; }
                else if (code >= 51 && code <= 67) { level = 'light'; icon = '🌧️'; }
                else if (code >= 80 && code <= 82) { level = 'moderate'; icon = '🌧️'; }
                else if (code >= 95) { level = 'heavy'; icon = '⛈️'; }

                return { ...slot, amount, level, icon, localTime };
            });

            // Déterminer le statut global
            const maxLevel = rainData.reduce((max, r) => {
                if (r.level === 'heavy') return 'heavy';
                if (r.level === 'moderate' && max !== 'heavy') return 'moderate';
                if (r.level === 'light' && max === 'none') return 'light';
                return max;
            }, 'none');

            const statusText = {
                none: 'Pas de pluie',
                light: 'Pluie légère',
                moderate: 'Pluie modérée',
                heavy: 'Fortes pluies'
            };

            // Mini bar pour les 60 prochaines minutes (6 segments de 10min)
            const miniBar = [];
            for (let i = 0; i < 6; i++) {
                const p = (hourlyPrecip[0] || 0) * (1 - i * 0.1);
                let lvl = 0;
                if (p > 0 && p < 0.3) lvl = 1;
                else if (p >= 0.3 && p < 1) lvl = 2;
                else if (p >= 1 && p < 2) lvl = 3;
                else if (p >= 2 && p < 5) lvl = 4;
                else if (p >= 5) lvl = 5;
                miniBar.push(lvl);
            }

            return `
                <div class="rain-forecast">
                    <div class="rain-forecast-header">
                        <div class="rain-forecast-title">🌧️ Prévision pluie</div>
                        <div class="rain-status ${maxLevel === 'none' ? 'dry' : maxLevel}">${statusText[maxLevel]}</div>
                    </div>
                    <div class="rain-timeline">
                        ${rainData.map(r => `
                            <div class="rain-slot ${r.level !== 'none' ? (r.level === 'heavy' ? 'heavy-rain' : 'has-rain') : ''}">
                                <div class="rain-slot-time">${r.label}</div>
                                <div class="rain-slot-icon">${r.icon}</div>
                                <div class="rain-slot-amount ${r.level}">${r.amount > 0 ? r.amount.toFixed(1) + 'mm' : '-'}</div>
                                <div class="rain-slot-hour">${r.localTime}</div>
                            </div>
                        `).join('')}
                    </div>
                    <div class="rain-mini-bar">
                        ${miniBar.map(lvl => `<div class="rain-mini-segment ${lvl > 0 ? 'level-' + lvl : ''}"></div>`).join('')}
                    </div>
                </div>
            `;
        }

        // Rendu de l'indicateur de houle compact
        function renderSwellIndicator(swellHeight, swellDir, swellPeriod) {
            return `
                <div class="swell-indicator">
                    <div class="swell-compass" style="width:60px;height:60px;">
                        <svg viewBox="0 0 60 60">
                            <circle cx="30" cy="30" r="26" fill="rgba(0,0,0,0.3)" stroke="rgba(155,89,182,0.3)" stroke-width="1"/>
                            <text x="30" y="9" fill="rgba(255,255,255,0.5)" font-size="6" text-anchor="middle">N</text>
                            <text x="30" y="56" fill="rgba(255,255,255,0.4)" font-size="5" text-anchor="middle">S</text>
                            <text x="54" y="32" fill="rgba(255,255,255,0.4)" font-size="5" text-anchor="middle">E</text>
                            <text x="6" y="32" fill="rgba(255,255,255,0.4)" font-size="5" text-anchor="middle">O</text>
                            <g transform="rotate(${swellDir}, 30, 30)">
                                <path d="M30,10 L27,22 L30,19 L33,22 Z" fill="var(--accent-purple)"/>
                                <line x1="30" y1="19" x2="30" y2="42" stroke="var(--accent-purple)" stroke-width="2"/>
                            </g>
                        </svg>
                    </div>
                    <div class="swell-info" style="flex:1;">
                        <div class="swell-title" style="font-size:0.8rem;margin-bottom:6px;">🌊 Houle</div>
                        <div class="swell-details" style="gap:15px;">
                            <div class="swell-detail">
                                <div class="value" style="font-size:1.1rem;">${getWindDirection(swellDir)}</div>
                                <div class="label">Dir.</div>
                            </div>
                            <div class="swell-detail">
                                <div class="value" style="font-size:1.1rem;">${convertWave(swellHeight)}${getWaveUnit()}</div>
                                <div class="label">Haut.</div>
                            </div>
                            <div class="swell-detail">
                                <div class="value" style="font-size:1.1rem;">${Math.round(swellPeriod || 0)}s</div>
                                <div class="label">Période</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Rendu des marées
        function renderTides(tidesData) {
            if (!tidesData) return '';

            const now = new Date();
            const nextTides = tidesData.tides.filter(t => t.time > now).slice(0, 2);

            return `
                <div class="tides-container">
                    <div class="tides-header">
                        <div class="tides-title">🌊 Marées</div>
                        <div class="tides-coefficient">Coef. ${tidesData.coefficient}</div>
                    </div>
                    <div style="text-align:center;margin-bottom:15px;">
                        <span style="font-size:1.5rem;font-weight:600;">${tidesData.currentHeight}m</span>
                        <span style="font-size:0.8rem;opacity:0.7;"> niveau actuel</span>
                    </div>
                    <div class="tides-times">
                        ${nextTides.map(tide => `
                            <div class="tide-time">
                                <div class="tide-icon">${tide.type === 'high' ? '⬆️' : '⬇️'}</div>
                                <div class="tide-info">
                                    <div class="time">${tide.time.toLocaleTimeString('fr-FR', {hour: '2-digit', minute: '2-digit'})}</div>
                                    <div class="height">${tide.height.toFixed(1)}m</div>
                                    <div class="label">${tide.type === 'high' ? 'Pleine mer' : 'Basse mer'}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    <div style="margin-top:10px;font-size:0.75rem;opacity:0.6;text-align:center;">
                        Marnage: ${tidesData.range.toFixed(1)}m
                    </div>
                </div>
            `;
        }

        // Rendu des infos port
        function renderPortInfo(cityName) {
            const port = portsInfo[cityName];
            if (!port) return '';

            return `
                <div class="port-info">
                    <div class="port-header">
                        <div class="port-title">⚓ ${port.harbor}</div>
                    </div>
                    <div class="port-grid">
                        <div class="port-item">
                            <div class="value">VHF ${port.vhf}</div>
                            <div class="label">Canal radio</div>
                        </div>
                        <div class="port-item">
                            <div class="value">${port.tidalRange}</div>
                            <div class="label">Marnage</div>
                        </div>
                    </div>
                    <div style="margin-top:12px;font-size:0.75rem;">
                        <strong>Services:</strong> ${port.facilities.join(' • ')}
                    </div>
                </div>
            `;
        }

        // Rendu du bulletin côtier
        function renderBulletin(bulletin) {
            if (!bulletin) return '';

            return `
                <div class="bulletin-container">
                    <div class="bulletin-header">
                        <div class="bulletin-title">📋 Bulletin Côtier</div>
                        <div class="bulletin-zone">${bulletin.zone}</div>
                    </div>
                    <div class="bulletin-date">${bulletin.date} - ${bulletin.time}</div>
                    <div class="bulletin-content">
                        ${bulletin.sections.map(section => `
                            <div class="bulletin-section">
                                <div class="bulletin-section-title">${section.title}</div>
                                <div class="bulletin-section-text">${section.text}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function renderWeather() {
            const data = state.weatherData;
            const current = data.current;
            const model = models[state.model];
            const date = new Date().toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long' });

            // Générer le bulletin côtier si données marines disponibles
            const bulletin = state.marineData ? generateCoastalBulletin(state.currentCity, data, state.marineData) : null;

            const hourlyData = data.hourly.time.slice(0, 48).map((t, i) => ({
                time: new Date(t).getHours().toString().padStart(2, '0') + ':00',
                temp: data.hourly.temperature_2m[i],
                wind: data.hourly.wind_speed_10m[i],
                windGust: data.hourly.wind_gusts_10m[i],
                weatherCode: data.hourly.weather_code[i],
                isDay: new Date(t).getHours() >= 6 && new Date(t).getHours() < 20
            }));

            const dailyData = data.daily.time.map((t, i) => ({
                day: ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'][new Date(t).getDay()],
                high: data.daily.temperature_2m_max[i],
                low: data.daily.temperature_2m_min[i],
                weatherCode: data.daily.weather_code[i],
                wind: data.daily.wind_speed_10m_max[i],
                windGust: data.daily.wind_gusts_10m_max[i]
            }));

            mainContent.innerHTML = `
                <div class="main-grid">
                    <div class="left-panel">
                        <div class="weather-card">
                            <div class="current-weather">
                                <span class="weather-icon-large">${getWeatherIcon(current.weather_code, current.is_day === 1)}</span>
                                <div class="weather-info">
                                    <h1 class="city-name">${state.currentCity}</h1>
                                    <p class="weather-date">${date}</p>
                                    <div class="temp-display">
                                        <span class="temp-main">${convertTemp(current.temperature_2m)}${getTempUnit()}</span>
                                        <span class="temp-feels">Ressenti ${convertTemp(current.apparent_temperature)}${getTempUnit()}</span>
                                    </div>
                                    <p class="weather-desc">${getWeatherDesc(current.weather_code)}</p>
                                </div>
                            </div>

                            <!-- Widget Vent Compact -->
                            ${renderWindWidget(current.wind_speed_10m, current.wind_gusts_10m, current.wind_direction_10m)}

                            <!-- Prévision Pluie -->
                            ${renderRainForecast(data.hourly.precipitation, data.hourly.weather_code)}

                            <div class="details-grid">
                                <div class="detail-item">
                                    <div class="detail-icon">💧</div>
                                    <div class="detail-value">${current.relative_humidity_2m}%</div>
                                    <div class="detail-label">Humidité</div>
                                </div>
                                <div class="detail-item">
                                    <div class="detail-icon">📊</div>
                                    <div class="detail-value">${convertPressure(current.pressure_msl)}${getPressureUnit()}</div>
                                    <div class="detail-label">Pression</div>
                                </div>
                                <div class="detail-item">
                                    <div class="detail-icon">☁️</div>
                                    <div class="detail-value">${current.cloud_cover}%</div>
                                    <div class="detail-label">Couverture</div>
                                </div>
                                <div class="detail-item">
                                    <div class="detail-icon">🌧️</div>
                                    <div class="detail-value">${current.precipitation}mm</div>
                                    <div class="detail-label">Précipitations</div>
                                </div>
                            </div>

                            <div class="last-update">
                                Mise à jour: ${state.lastUpdate?.toLocaleTimeString('fr-FR')} - Source: Open-Meteo / ${model.provider}
                            </div>
                        </div>

                        <!-- Graphique Vent/Rafales -->
                        ${renderWindChart(data.hourly.wind_speed_10m, data.hourly.wind_gusts_10m, 24)}

                        <!-- Radar de pluie -->
                        ${renderRainRadar(state.currentCoords.lat, state.currentCoords.lon)}

                        <div class="tabs">
                            <button class="tab-btn active" data-tab="hourly">⏱️ Horaire</button>
                            <button class="tab-btn" data-tab="daily">📅 7 jours</button>
                        </div>

                        <div class="tab-content active" id="tab-hourly">
                            <div class="weather-card">
                                <div class="panel-title">Prévisions horaires (48h)</div>
                                <div class="hourly-scroll">
                                    ${hourlyData.map((h, i) => `
                                        <div class="hour-item ${i === 0 ? 'active' : ''}">
                                            <div class="hour-time">${h.time}</div>
                                            <div class="hour-icon">${getWeatherIcon(h.weatherCode, h.isDay)}</div>
                                            <div class="hour-temp">${convertTemp(h.temp)}°</div>
                                            <div class="hour-wind">${convertWind(h.wind, state.units.wind)}</div>
                                            <div class="hour-gust">↑${convertWind(h.windGust, state.units.wind)}</div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        </div>

                        <div class="tab-content" id="tab-daily">
                            <div class="weather-card">
                                <div class="panel-title">Prévisions 7 jours</div>
                                ${dailyData.map((d, i) => `
                                    <div class="daily-item">
                                        <div class="daily-day">${i === 0 ? 'Auj.' : d.day}</div>
                                        <span class="daily-icon">${getWeatherIcon(d.weatherCode, true)}</span>
                                        <div class="daily-temps">
                                            <span class="daily-high">${convertTemp(d.high)}°</span>
                                            <span class="daily-low">${convertTemp(d.low)}°</span>
                                        </div>
                                        <div class="daily-wind">${convertWind(d.wind, state.units.wind)} ${getWindUnitLabel()}</div>
                                        <div class="daily-gust">↑${convertWind(d.windGust, state.units.wind)}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>

                    <div class="side-panel">
                        <!-- Pression atmosphérique -->
                        <div class="panel-card">
                            <div class="panel-title">📊 Pression atmosphérique</div>
                            <div style="text-align:center;margin-bottom:10px;">
                                <span style="font-size:2rem;font-weight:700;">${convertPressure(current.pressure_msl)}</span>
                                <span style="font-size:0.9rem;opacity:0.7;">${getPressureUnit()}</span>
                            </div>
                            ${renderPressureChart(data.hourly.pressure_msl.slice(0, 40))}
                        </div>

                        <!-- Bulletin côtier si disponible -->
                        ${bulletin ? renderBulletin(bulletin) : ''}

                        <!-- Infos modèle -->
                        <div class="panel-card">
                            <div class="panel-title">ℹ️ Modèle ${model.name}</div>
                            <div class="marine-grid" style="gap:8px">
                                <div class="marine-item">
                                    <div class="marine-info">
                                        <div class="value">${model.resolution}</div>
                                        <div class="label">Résolution</div>
                                    </div>
                                </div>
                                <div class="marine-item">
                                    <div class="marine-info">
                                        <div class="value">${model.range}</div>
                                        <div class="label">Portée</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            setupTabs();
            // Initialiser le radar après le rendu
            setTimeout(() => initRadar(state.currentCoords.lat, state.currentCoords.lon), 200);
        }

        function renderMarine() {
            const weather = state.weatherData;
            const marine = state.marineData;
            const model = models[state.model];
            const current = weather.current;
            const marineCurrent = marine.current;

            const waveHeight = marineCurrent.wave_height || 0;
            const seaStateIndex = getSeaState(waveHeight);
            const seaState = seaStates[seaStateIndex];

            const safetyLevel = seaStateIndex <= 3 ? 'safe' : seaStateIndex <= 5 ? 'warning' : 'danger';
            const safetyIcon = safetyLevel === 'safe' ? '✅' : safetyLevel === 'warning' ? '⚠️' : '🚨';
            const safetyTitle = safetyLevel === 'safe' ? 'Conditions favorables' :
                               safetyLevel === 'warning' ? 'Prudence recommandée' : 'Navigation déconseillée';

            const bulletin = generateCoastalBulletin(state.currentCity, weather, marine);

            const marineHourly = marine.hourly.time.slice(0, 48).map((t, i) => ({
                time: new Date(t).getHours().toString().padStart(2, '0') + ':00',
                waveHeight: marine.hourly.wave_height[i],
                wind: weather.hourly.wind_speed_10m[i],
                windGust: weather.hourly.wind_gusts_10m[i]
            }));

            mainContent.innerHTML = `
                <div class="safety-alert ${safetyLevel}">
                    <span class="safety-icon">${safetyIcon}</span>
                    <div class="safety-text">
                        <div class="title">${safetyTitle}</div>
                        <div class="desc">Mer ${seaState.name.toLowerCase()} - ${seaState.desc}</div>
                    </div>
                    <span class="model-tag ${model.isHD ? 'hd' : ''}">${model.name}</span>
                </div>

                <div class="main-grid">
                    <div class="left-panel">
                        <div class="weather-card">
                            <div class="panel-title">🌊 État de la mer <span class="model-tag ${model.isHD ? 'hd' : ''}">${model.name} ${model.resolution}</span></div>

                            <div class="wave-visual">
                                <div class="wave-line"></div>
                                <div class="wave-stats">
                                    <div class="wave-height-value">${convertWave(waveHeight)}${getWaveUnit()}</div>
                                    <div class="wave-height-label">Hauteur des vagues</div>
                                </div>
                            </div>

                            <div class="sea-state-bar">
                                <div class="sea-state-marker" style="left: ${(seaStateIndex / 9) * 100}%"></div>
                            </div>
                            <div class="sea-state-labels">
                                <span>Calme</span>
                                <span>Agitée</span>
                                <span>Forte</span>
                                <span>Grosse</span>
                                <span>Énorme</span>
                            </div>

                            <!-- Widget Vent Compact Marine -->
                            ${renderWindWidget(current.wind_speed_10m, current.wind_gusts_10m, current.wind_direction_10m)}

                            <!-- Prévision Pluie -->
                            ${renderRainForecast(weather.hourly.precipitation, weather.hourly.weather_code)}

                            <!-- Indicateur de houle -->
                            ${renderSwellIndicator(
                                marineCurrent.swell_wave_height || 0,
                                marineCurrent.swell_wave_direction || 0,
                                marineCurrent.swell_wave_period || 0
                            )}

                            <!-- Graphique hauteur des vagues -->
                            ${renderWaveChart(marine.hourly.wave_height, 24)}

                            <!-- Graphique Vent/Rafales Marine -->
                            ${renderWindChart(weather.hourly.wind_speed_10m, weather.hourly.wind_gusts_10m, 24)}

                            <div class="marine-grid" style="margin-top:15px">
                                <div class="marine-item">
                                    <span class="marine-icon">🌊</span>
                                    <div class="marine-info">
                                        <div class="value">${Math.round(marineCurrent.wave_period || 0)}s</div>
                                        <div class="label">Période vagues</div>
                                    </div>
                                </div>
                                <div class="marine-item">
                                    <span class="marine-icon">🧭</span>
                                    <div class="marine-info">
                                        <div class="value">${getWindDirection(marineCurrent.wave_direction || 0)}</div>
                                        <div class="label">Dir. vagues</div>
                                    </div>
                                </div>
                            </div>

                            <div class="last-update">
                                Mise à jour: ${state.lastUpdate?.toLocaleTimeString('fr-FR')} - Source: Open-Meteo Marine
                            </div>
                        </div>

                        <div class="weather-card">
                            <div class="panel-title">⏱️ Prévisions horaires</div>
                            <div class="hourly-scroll">
                                ${marineHourly.map((h, i) => `
                                    <div class="hour-item ${i === 0 ? 'active' : ''}">
                                        <div class="hour-time">${h.time}</div>
                                        <div class="hour-icon">🌊</div>
                                        <div class="hour-temp">${convertWave(h.waveHeight)}${getWaveUnit()}</div>
                                        <div class="hour-wind">${convertWind(h.wind, state.units.wind)}</div>
                                        <div class="hour-gust">↑${convertWind(h.windGust, state.units.wind)}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>

                    <div class="side-panel">
                        <!-- Bulletin Marine Détaillé Météo-France -->
                        <div id="marineBulletinContainer">
                            <div class="panel-card"><p style="opacity:0.6;text-align:center;">Chargement du bulletin marine...</p></div>
                        </div>

                        <!-- Marées avec courbe -->
                        ${renderTides(state.tidesData)}
                        ${renderTideCurve(state.tidesData)}

                        <!-- Carte Marine OpenSeaMap -->
                        ${renderMarineChart(state.currentCoords.lat, state.currentCoords.lon)}

                        <!-- Radar de pluie -->
                        ${renderRainRadar(state.currentCoords.lat, state.currentCoords.lon)}

                        <!-- Info Port -->
                        ${renderPortInfo(state.currentCity)}

                        <div class="panel-card">
                            <div class="panel-title">📈 Pression (40h)</div>
                            ${renderPressureChart(weather.hourly.pressure_msl.slice(0, 40))}
                        </div>
                    </div>
                </div>
            `;

            // Initialiser la carte marine et le radar après le rendu
            setTimeout(() => {
                initMarineChart(state.currentCoords.lat, state.currentCoords.lon);
                initRadar(state.currentCoords.lat, state.currentCoords.lon);
            }, 200);

            // Charger le bulletin marine détaillé
            setTimeout(async () => {
                const bulletin = await generateMarineBulletin(selectedMarineZone);
                const container = document.getElementById('marineBulletinContainer');
                if (container) {
                    container.innerHTML = renderMarineBulletin(bulletin);
                }
            }, 100);
        }

        function renderPressureChart(pressureData) {
            if (!pressureData?.length) return '<p>Données non disponibles</p>';

            const minP = Math.min(...pressureData) - 3;
            const maxP = Math.max(...pressureData) + 3;

            const points = pressureData.map((p, i) => {
                const x = 5 + (i / (pressureData.length - 1)) * 90;
                const y = 95 - ((p - minP) / (maxP - minP)) * 90;
                return `${x},${y}`;
            }).join(' ');

            const trendDiff = pressureData.length >= 8 ?
                (pressureData.slice(-4).reduce((a, b) => a + b, 0) / 4) -
                (pressureData.slice(0, 4).reduce((a, b) => a + b, 0) / 4) : 0;

            return `
                <div class="pressure-chart">
                    <svg class="chart-svg" viewBox="0 0 100 100" preserveAspectRatio="none">
                        <defs>
                            <linearGradient id="pressureGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" style="stop-color:rgba(0,180,216,0.3)"/>
                                <stop offset="100%" style="stop-color:rgba(0,180,216,0.02)"/>
                            </linearGradient>
                        </defs>
                        <line class="chart-grid" x1="5" y1="25" x2="95" y2="25"/>
                        <line class="chart-grid" x1="5" y1="50" x2="95" y2="50"/>
                        <line class="chart-grid" x1="5" y1="75" x2="95" y2="75"/>
                        <polygon class="chart-area" points="5,95 ${points} 95,95"/>
                        <polyline class="chart-line" points="${points}"/>
                    </svg>
                </div>
                <div class="pressure-stats">
                    <div class="pressure-stat">
                        <div class="value">${convertPressure(pressureData[0])}${getPressureUnit()}</div>
                        <div class="label">Actuelle</div>
                    </div>
                    <div class="pressure-stat">
                        <div class="value ${trendDiff > 1 ? 'trend-up' : trendDiff < -1 ? 'trend-down' : 'trend-stable'}">
                            ${trendDiff > 1 ? '↗️ Hausse' : trendDiff < -1 ? '↘️ Baisse' : '➡️ Stable'}
                        </div>
                        <div class="label">Tendance</div>
                    </div>
                </div>
            `;
        }

        function setupTabs() {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    btn.classList.add('active');
                    document.getElementById(`tab-${btn.dataset.tab}`)?.classList.add('active');
                });
            });
        }
    </script>
</body>
</html>
